<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>leeing的登山之旅</title>
  
  <subtitle>前往空气稀薄地带</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://1eeing.github.io/"/>
  <updated>2018-08-07T10:22:08.000Z</updated>
  <id>http://1eeing.github.io/</id>
  
  <author>
    <name>leeing</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>【网络篇】Http、Https、Http 2.0 及 DNS</title>
    <link href="http://1eeing.github.io/2018/08/07/HTTP/"/>
    <id>http://1eeing.github.io/2018/08/07/HTTP/</id>
    <published>2018-08-07T10:08:30.000Z</published>
    <updated>2018-08-07T10:22:08.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="HTTP"><a href="#HTTP" class="headerlink" title="HTTP"></a>HTTP</h1><p>HTTP协议是个无状态协议，不会保存状态。</p><h2 id="POST和GET的区别"><a href="#POST和GET的区别" class="headerlink" title="POST和GET的区别"></a>POST和GET的区别</h2><p>先引入副作用和幂等的概念。<br>副作用指对服务器上的资源做改变，搜索是无副作用的，注册是副作用的。</p><p>幂等指发送M和N次请求（两者不同且都大于1），服务器上资源的状态一致，比如注册10个和11个账号是不幂等的，对文章进行更改10次和11次是幂等的。</p><p>在规范的应用场景上说，GET多用于无副作用、幂等的场景，例如搜索关键字。POST多用于副作用、不幂等的场景，例如注册。</p><p>在技术上说：</p><ul><li>GET请求能缓存，POST不能</li><li>POST相对GET安全一点点，因为GET请求都包含在URL里，且会被浏览器保存历史记录，POST不会，但是在抓包的情况下都是一样的。</li><li>POST可以通过request body来传输比GET更多的数据，GET没有这个技术</li><li>URL有长度限制，会影响GET请求，但是这个长度限制是浏览器规定的，不是RFC规定的</li><li>POST支持更多编码类型且不对数据类型限制</li></ul><a id="more"></a><h2 id="常见状态码"><a href="#常见状态码" class="headerlink" title="常见状态码"></a>常见状态码</h2><h3 id="2XX-成功"><a href="#2XX-成功" class="headerlink" title="2XX 成功"></a>2XX 成功</h3><ul><li>200 OK，表示从客户端发来的请求在服务器端被正确处理</li><li>204 No content，表示请求成功，但响应报文不含实体的主体部分</li><li>205 Reset Content，表示请求成功，但响应报文不含实体的主体部分，但是与204不同自傲与要求请求方重置内容</li><li>206 Partial Content，进行范围请求</li></ul><h3 id="3XX-重定向"><a href="#3XX-重定向" class="headerlink" title="3XX 重定向"></a>3XX 重定向</h3><ul><li>301 moved permanently，永久性重定向，表示资源已被分配了新的URL</li><li>302 found，临时性重定向，表示资源临时被分配了新的URL</li><li>303 see other，表示资源存在着另一个URL，应使用GET方法定向获取资源</li><li>304 not modified，表示服务器允许访问资源，但因发生请求未满足条件的情况</li><li>307 temporary redirect，临时重定向，同302</li></ul><h3 id="4XX-客户端错误"><a href="#4XX-客户端错误" class="headerlink" title="4XX 客户端错误"></a>4XX 客户端错误</h3><ul><li>400 bad request，请求报文存在语法错误</li><li>401 unauthorized，表示发送的请求需要有通过HTTP认证的认证信息</li><li>403 forbidden，表示对请求资源的访问被服务器拒绝</li><li>404 not found，表示在服务器上没有找到请求的资源</li></ul><h3 id="5XX-服务器错误"><a href="#5XX-服务器错误" class="headerlink" title="5XX 服务器错误"></a>5XX 服务器错误</h3><ul><li>500 internal server error，表示服务器端在执行请求时发生了错误</li><li>501 Not Implemented，表示服务器不支持当前请求所需要的某个功能</li><li>503 service unavailable，表示服务器暂时处于超负载或正在停机维护，无法处理请求</li></ul><h2 id="HTTP首部"><a href="#HTTP首部" class="headerlink" title="HTTP首部"></a>HTTP首部</h2><table><thead><tr><th>通用字段</th><th style="text-align:center">作用</th></tr></thead><tbody><tr><td>Cache-Control</td><td style="text-align:center">控制缓存的行为</td></tr><tr><td>Connection</td><td style="text-align:center">浏览器想要优先使用的链接类型，比如keep-alive</td></tr><tr><td>Date</td><td style="text-align:center">创建报文时间</td></tr><tr><td>Pragma</td><td style="text-align:center">报文指令</td></tr><tr><td>Via</td><td style="text-align:center">代理服务器相关信息</td></tr><tr><td>Transfer-Encoding</td><td style="text-align:center">传输编码方式</td></tr><tr><td>Upgrade</td><td style="text-align:center">要求客户端升级协议</td></tr><tr><td>Warning</td><td style="text-align:center">在内容中可能存在错误</td></tr></tbody></table><table><thead><tr><th>请求字段</th><th style="text-align:center">作用</th></tr></thead><tbody><tr><td>Accept</td><td style="text-align:center">能正确接收的媒体类型</td></tr><tr><td>Accept-Charset</td><td style="text-align:center">能正确接收的字符集</td></tr><tr><td>Accept-Encoding</td><td style="text-align:center">能正确接收的编码格式列表</td></tr><tr><td>Accept-Language</td><td style="text-align:center">能正确接收的语言列表</td></tr><tr><td>Expect</td><td style="text-align:center">期待服务端的指定行为</td></tr><tr><td>From</td><td style="text-align:center">请求方邮箱地址</td></tr><tr><td>Host</td><td style="text-align:center">服务器的域名</td></tr><tr><td>if-Match</td><td style="text-align:center">两端资源标记比较</td></tr><tr><td>if-Modified-Since</td><td style="text-align:center">本地资源未修改返回304（比较时间）</td></tr><tr><td>if-None-Match</td><td style="text-align:center">本地资源未修改返回304（比较标记）</td></tr><tr><td>User-Agent</td><td style="text-align:center">客户端信息</td></tr><tr><td>Max-Forwards</td><td style="text-align:center">限制可被代理及王网关转发的次数</td></tr><tr><td>Proxy-Authorization</td><td style="text-align:center">向代理服务器发送验证信息</td></tr><tr><td>Range</td><td style="text-align:center">请求某个内容的一部分</td></tr><tr><td>Referer</td><td style="text-align:center">表示浏览器所访问的前一个页面</td></tr><tr><td>TE</td><td style="text-align:center">传输编码方式</td></tr></tbody></table><table><thead><tr><th>响应字段</th><th style="text-align:center">作用</th></tr></thead><tbody><tr><td>Accept-Ranges</td><td style="text-align:center">是否支持某些种类的范围</td></tr><tr><td>Age</td><td style="text-align:center">资源在代理缓存中存在的时间</td></tr><tr><td>ETag</td><td style="text-align:center">资源标识</td></tr><tr><td>Location</td><td style="text-align:center">客户端重定向到某个URL</td></tr><tr><td>Proxy-Authenticate</td><td style="text-align:center">向代理服务器发送验证信息</td></tr><tr><td>Server</td><td style="text-align:center">服务器名字</td></tr><tr><td>WWW-Authenticate</td><td style="text-align:center">获取资源需要的验证信息</td></tr></tbody></table><table><thead><tr><th>实体字段</th><th style="text-align:center">作用</th></tr></thead><tbody><tr><td>Allow</td><td style="text-align:center">资源的正确请求方式</td></tr><tr><td>Content-Encoding</td><td style="text-align:center">内容的编码格式</td></tr><tr><td>Content-Language</td><td style="text-align:center">内容使用的语言</td></tr><tr><td>Content-Length</td><td style="text-align:center">request body 长度</td></tr><tr><td>Content-Location</td><td style="text-align:center">返回数据的备用地址</td></tr><tr><td>Content-MD5</td><td style="text-align:center">Base64加密格式的内容 MD5校验值</td></tr><tr><td>Content-Range</td><td style="text-align:center">内容的位置范围</td></tr><tr><td>Content-Type</td><td style="text-align:center">内容的媒体类型</td></tr><tr><td>Expires</td><td style="text-align:center">内容的过期时间</td></tr><tr><td>Last_modified</td><td style="text-align:center">内容的最后修改时间</td></tr></tbody></table><hr><h1 id="HTTPS"><a href="#HTTPS" class="headerlink" title="HTTPS"></a>HTTPS</h1><p>HTTPS还是通过了HTTP来传输信息，但是信息通过TLS协议进行了加密。</p><h2 id="TLS"><a href="#TLS" class="headerlink" title="TLS"></a>TLS</h2><p>TLS协议位于传输层智商，应用层之下。首次进行TLS协议传输需要两个RTT，接下来可以通过Session Resumption 减少到一个RTT。</p><p>在TLS中使用了两种加密技术，分别为：对称加密和非对称加密。</p><h3 id="对称加密"><a href="#对称加密" class="headerlink" title="对称加密"></a>对称加密</h3><p>对称加密就是两边拥有相同的秘钥，两边都知道如何将密文加密解密。</p><h3 id="非对称加密"><a href="#非对称加密" class="headerlink" title="非对称加密"></a>非对称加密</h3><p>有公钥私钥之分，公钥所有人都可以知道，可以将数据用公钥加密，但是将数据解密必须使用私钥解密，私钥只有分发公钥的一方才知道。</p><p>TSL握手过程如下：<br><img src="https://user-gold-cdn.xitu.io/2018/5/12/1635260126b3a10c?w=1558&amp;h=1006&amp;f=webp&amp;s=59424" alt="https://user-gold-cdn.xitu.io/2018/5/12/1635260126b3a10c?w=1558&amp;h=1006&amp;f=webp&amp;s=59424"></p><ol><li>客户端发送一个随机值，需要的协议和加密方式</li><li>服务端收到客户端的随机值，自己也产生一个随机值，并根据客户端需求的协议和加密方式来使用对应的方式，发送自己的证书（如果需要验证客户端证书需要说明）</li><li>客户端收到服务端的证书并验证是否有效，验证通过会再生成一个随机值，通过服务端证书的公钥去加密这个随机值并发送给服务端，如果服务端需要验证客户端证书的话会附带证书</li><li>服务端收到加密过的随机值并使用私钥解密获得第三个随机值，这时候两端都拥有了三个随机值，可以通过这三个随机值按照之前约定的加密方式生成密钥，接下来的通信就可以通过该密钥来加密解密。</li></ol><p>通过以上步骤可知，在TLS握手阶段，两端使用非对称加密的方式来通信，但是因为非对称加密损耗的性能比对称加密大，所以在正式传输数据时，两端使用对称加密的方式通信。</p><blockquote><p>以上说明的都是TLS 1.2协议的握手情况，在1.3协议中，首次建立连接只需要一个RTT，后面恢复连接不需要RTT了。</p></blockquote><hr><h1 id="HTTP-2-0"><a href="#HTTP-2-0" class="headerlink" title="HTTP 2.0"></a>HTTP 2.0</h1><p>HTTP 2.0相比于HTTP 1.X，可以说是大幅度提高了web的性能。</p><p>在HTTP 1.X中，为了性能考虑，我们会引入雪碧图、将小图内联、使用多个域名等等的方式。这一切都是因为浏览器限制了同一个域名下的请求数量，当页面中需要请求很多资源的时候，队头阻塞（Head of line blocking）会导致在达到最大请求数量时，剩余的资源需要等待其他资源请求完成后才能发起请求。</p><p>在HTTP 1.X中，因为队头阻塞的原因，你会发现请求是这样的<br><img src="https://user-gold-cdn.xitu.io/2018/5/12/163542c96df8563d?w=518&amp;h=642&amp;f=png&amp;s=72417" alt="https://user-gold-cdn.xitu.io/2018/5/12/163542c96df8563d?w=518&amp;h=642&amp;f=png&amp;s=72417"></p><p>在HTTP 2.0中，因为引入了多路复用，你会发现请求是这样的<br><img src="https://user-gold-cdn.xitu.io/2018/5/12/163542c9d3128c7a?w=900&amp;h=616&amp;f=png&amp;s=71014" alt="https://user-gold-cdn.xitu.io/2018/5/12/163542c9d3128c7a?w=900&amp;h=616&amp;f=png&amp;s=71014"></p><h2 id="二进制传输"><a href="#二进制传输" class="headerlink" title="二进制传输"></a>二进制传输</h2><p>HTTP 2.0中所有加强性能的核心点在于此。在之前的HTTP版本中，我们是通过文本的方式传输数据。<br>在HTTP 2.0中引入了新的编码机制，所有传输的数据都会被分割，并采用二进制格式编码。</p><p><img src="https://user-gold-cdn.xitu.io/2018/5/12/163543c25e5e9f23?w=874&amp;h=459&amp;f=png&amp;s=26320" alt="https://user-gold-cdn.xitu.io/2018/5/12/163543c25e5e9f23?w=874&amp;h=459&amp;f=png&amp;s=26320"></p><h2 id="多路复用"><a href="#多路复用" class="headerlink" title="多路复用"></a>多路复用</h2><p>在 HTTP 2.0 中，有两个非常重要的概念，分别是帧(frame)和流(stream)。<br>帧代表着最小的数据单位，每个帧会表示出该帧属于哪个流，流也就是多个帧组成的数据流。</p><p>多路复用，就是在一个TCP连接中可以存在多条流。换句话说，也就是可以发送多个请求，对端可以通过帧中的标识知道属于哪个请求。通过这个技术，可以避免 HTTP 旧版本中的队头阻塞问题，极大的提高传输性能。</p><h2 id="Header压缩"><a href="#Header压缩" class="headerlink" title="Header压缩"></a>Header压缩</h2><p>在 HTTP 1.X 中，我们使用文本的形式传输header，在header携带cookie的情况下，可能每次都需要重复传输几百到几千的字节。</p><p>在 HTTP 2.0 中，使用了HPACK压缩格式对传输的header进行编码，减少了header的大小。并在两端维护了索引表，用于记录出现过的header，后面再传输过程中就可以传输已经记录过的header的键名，对端收到数据后就可以通过键名找到对应的值。</p><h2 id="服务端Push"><a href="#服务端Push" class="headerlink" title="服务端Push"></a>服务端Push</h2><p>在 HTTP 2.0 中，服务端可以在客户端某个请求后，主动推送其他资源。</p><p>可以想象以下情况：<br>某些资源客户端是一定会请求的，这时就可以采取服务端push的技术，提前给客户端推送必要的资源，这样就可以相对减少一点延迟时间。当然在浏览器兼容的情况下你也可以使用prefetch。</p><h2 id="QUIC"><a href="#QUIC" class="headerlink" title="QUIC"></a>QUIC</h2><p>这是一个谷歌出品的基于UDP实现的同为传输层的协议，目标很远大，希望替代TCP协议。</p><ul><li>该协议支持多路复用，虽然 HTTP 2.0 也支持多路复用，但是下层仍是TCP，因为TCP的重传机制，只要一个包丢失就得判断丢失包并且重传，导致发生队头阻塞的问题，但是UDP没有这个机制。</li><li>实现了自己的加密协议，通过类似TCP的TFO机制可以实现O-RTT，当然TLS 1.3已经实现了O-RTT了</li><li>支持重传和纠错机制（向前恢复），在只丢失一个包的情况下不需要重传，使用纠错机制恢复丢失的包<ul><li>纠错机制：通过异或的方式，算出发出去的数据的异或值并单独发出一个包，服务端在发现有一个包丢失的情况下，通过其他数据包和异或值包算出丢失包</li><li>在丢失两个包或以上的情况就使用重传机制，因为算不出来了。</li></ul></li></ul><hr><h1 id="DNS"><a href="#DNS" class="headerlink" title="DNS"></a>DNS</h1><p>DNS的作用就是通过域名查询到具体的IP。</p><p>因为IP存在数字和英文的组合（IPv6），很不利于人类记忆，所以就出现了域名。你可以把域名看成是某个IP的别名，DNS就是去查询这个别名的真正名称是什么。</p><p>在TCP握手之前就已经进行了DNS查询，这个查询是操作系统自己做的。当你在浏览器中想访问<code>www.leeing.site</code>时，会进行以下操作：</p><ol><li>操作系统会首先在本地缓存中查询</li><li>没有的话会去系统配置的DNS服务器中查询</li><li>如果这时候还没得话，会直接去DNS根服务器查询，这一步查询会找出负责<code>site</code>这个一级域名的服务器</li><li>然后去该服务器查询<code>leeing</code>这个二级域名</li><li>接下来三级域名的查询其实是我们配置的，你可以给<code>www</code>这个域名配置一个IP，然后还可以给别的三级域名配置一个IP</li></ol><p>以上介绍的是DNS迭代查询，还有种是递归查询，区别就是前者是由客户端去做请求，后者是由系统配置的DNS服务器做请求，得到结果后将数据返回给客户端。</p><blockquote><p>PS：DNS是基于UDP做的查询</p></blockquote><hr><h1 id="从输入URL到页面加载完成的过程？"><a href="#从输入URL到页面加载完成的过程？" class="headerlink" title="从输入URL到页面加载完成的过程？"></a>从输入URL到页面加载完成的过程？</h1><ol><li>首先做DNS查询，如果这一步做了只能DNS解析的话，会提供访问速度最快的IP地址回来</li><li>接下来是TCP握手，应用层会下发数据给传输层，这里TCP协议会指明两端的端口号，然后下发给网络层。网络层中的IP协议会确定IP地址，并且指示了数据传输中如何跳转路由器。然后包会再被封装到数据链路层的数据帧结构中，最后就是物理层面的传输了</li><li>TCP握手结束后会进行TLS握手，然后就开始正式的传输数据</li><li>数据在进入服务端之前，可能还会先经过负载均衡的服务器，它的作用就是将请求合理的分发到多台服务器上，这时假设服务端会响应一个HTML文件</li><li>首先浏览器会判断状态码是什么，如果是200那就继续解析，如果是400或500的话就会报错，如果300的话会进行重定向，这里会有个重定向计数器，避免过多次的重定向，超过次数也会报错。</li><li>浏览器开始解析文件，如果是gzip格式的话会先解压一下，然后通过文件的编码格式知道该如何去解码文件。</li><li>文件解码成功后会正式开始渲染流程，先会根据HTML构建DOM树，有CSS的话会去构建CSSOM树。如果遇到<code>script</code>标签的话，会判断是否存在 <code>async</code> 或者 <code>defer</code> ，前者会并行进行下载并执行JS，后者会先下载文件，然后等待HTML解析完成后顺序执行，如果以上都没有，就会阻塞住渲染刘恒直到JS执行完毕。遇到文件下载的会去下载文件，这里如果使用HTTP 2.0协议的话会极大的提高多图的下载效率。</li><li>初始的HTML被完全加载和解析后会触发<code>DOMContentLoaded</code>事件</li><li>CSSOM树和DOM树构建完成后会开始生成Render树，这一步就是确定页面元素的布局、样式等等诸多方面的东西</li><li>在生成Render树的过程中，浏览器就开始调用GPU绘制，合成图层，将内容显示在屏幕上了。</li></ol>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;HTTP&quot;&gt;&lt;a href=&quot;#HTTP&quot; class=&quot;headerlink&quot; title=&quot;HTTP&quot;&gt;&lt;/a&gt;HTTP&lt;/h1&gt;&lt;p&gt;HTTP协议是个无状态协议，不会保存状态。&lt;/p&gt;
&lt;h2 id=&quot;POST和GET的区别&quot;&gt;&lt;a href=&quot;#POST和GET的区别&quot; class=&quot;headerlink&quot; title=&quot;POST和GET的区别&quot;&gt;&lt;/a&gt;POST和GET的区别&lt;/h2&gt;&lt;p&gt;先引入副作用和幂等的概念。&lt;br&gt;副作用指对服务器上的资源做改变，搜索是无副作用的，注册是副作用的。&lt;/p&gt;
&lt;p&gt;幂等指发送M和N次请求（两者不同且都大于1），服务器上资源的状态一致，比如注册10个和11个账号是不幂等的，对文章进行更改10次和11次是幂等的。&lt;/p&gt;
&lt;p&gt;在规范的应用场景上说，GET多用于无副作用、幂等的场景，例如搜索关键字。POST多用于副作用、不幂等的场景，例如注册。&lt;/p&gt;
&lt;p&gt;在技术上说：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;GET请求能缓存，POST不能&lt;/li&gt;
&lt;li&gt;POST相对GET安全一点点，因为GET请求都包含在URL里，且会被浏览器保存历史记录，POST不会，但是在抓包的情况下都是一样的。&lt;/li&gt;
&lt;li&gt;POST可以通过request body来传输比GET更多的数据，GET没有这个技术&lt;/li&gt;
&lt;li&gt;URL有长度限制，会影响GET请求，但是这个长度限制是浏览器规定的，不是RFC规定的&lt;/li&gt;
&lt;li&gt;POST支持更多编码类型且不对数据类型限制&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
      <category term="学习笔记" scheme="http://1eeing.github.io/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="基础知识" scheme="http://1eeing.github.io/tags/%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"/>
    
      <category term="计算机通识" scheme="http://1eeing.github.io/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E9%80%9A%E8%AF%86/"/>
    
      <category term="网络" scheme="http://1eeing.github.io/tags/%E7%BD%91%E7%BB%9C/"/>
    
      <category term="学习笔记" scheme="http://1eeing.github.io/tags/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
      <category term="HTTP" scheme="http://1eeing.github.io/tags/HTTP/"/>
    
      <category term="HTTPS" scheme="http://1eeing.github.io/tags/HTTPS/"/>
    
      <category term="HTTP 2.0" scheme="http://1eeing.github.io/tags/HTTP-2-0/"/>
    
      <category term="DNS" scheme="http://1eeing.github.io/tags/DNS/"/>
    
  </entry>
  
  <entry>
    <title>【网络篇】UDP 和 TCP</title>
    <link href="http://1eeing.github.io/2018/08/07/UDP/"/>
    <id>http://1eeing.github.io/2018/08/07/UDP/</id>
    <published>2018-08-07T05:55:12.000Z</published>
    <updated>2018-08-07T10:17:20.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="UDP"><a href="#UDP" class="headerlink" title="UDP"></a>UDP</h1><h2 id="面向报文"><a href="#面向报文" class="headerlink" title="面向报文"></a>面向报文</h2><p>UDP是一个面向报文（报文可以理解为一段段的数据）的协议。意思就是UDP只是报文的搬运工，不会对报文进行任何拆分和拼接操作。</p><p>具体来说</p><ul><li>在发送端，应用层将数据传递给传输层的UDP协议，UDP只会给数据增加一个UDP头标识下是UDP协议，然后就传递给网络层了</li><li>在接收端，网络层将数据传递给传输层，UDP只去除IP报文头就传递给应用层，不会任何拼接操作</li></ul><h2 id="不可靠性"><a href="#不可靠性" class="headerlink" title="不可靠性"></a>不可靠性</h2><ol><li>UDP是无连接的，也就是说通信不需要建立和断开。</li><li>UDP是不可靠的，协议收到什么数据就传递什么数据，并且也不会备份数据，对方能不能收到也不关心。</li><li>UDP没有拥塞控制，一直会以恒定的速度发送数据。即使网络条件不好，也不会对发送速率进行调整。<ul><li>弊端：在网络条件不好的情况下会导致丢包</li><li>优点：在某些实时性要求高的场景（比如电话会议），就需要使用UDP而不是TCP</li></ul></li></ol><a id="more"></a><h2 id="高效"><a href="#高效" class="headerlink" title="高效"></a>高效</h2><p>因为UDP没有TCP那么复杂，需要保证数据不丢失且有序到达，所以UDP的头部开销小，只有八字节，相比TCP的至少二十字节要少得多，在传输数据报文时是很高效的。</p><p>头部包含了以下数据</p><ul><li>两个十六位的端口号，分别为源端口（可选字段）和目标端口</li><li>整个数据报文的长度</li><li>整个数据报文的校验和（IPv4可选字段），该字段用于发现头部信息和数据中的错误</li></ul><h2 id="传输方式"><a href="#传输方式" class="headerlink" title="传输方式"></a>传输方式</h2><p>UDP不止支持一对一的传输方式，同样支持一对多，多对多，多对一的方式，也就是说UDP提供了单播、多播、广播的功能。</p><h1 id="TCP"><a href="#TCP" class="headerlink" title="TCP"></a>TCP</h1><h2 id="头部"><a href="#头部" class="headerlink" title="头部"></a>头部</h2><p>TCP头部比UDP复杂的多，对于TCP头部来说，以下几个字段是很重要的</p><ul><li>Sequence number，这个序号保证了TCP传输的报文都是有序的，对端可以通过序号的顺序拼接报文。</li><li>Acknowledgement Number，这个序号表示数据接收端期望接收的下一个字节的编号是多少，同时也表示上一个序号的数据已经收到</li><li>Window Size，窗口大小，表示还能接收多少字节的数据，用于流量控制</li><li>标识符<ul><li>URG=1：该字段为一表示本数据报的数据部分包含紧急信息，是一个高优先级数据报文，此时紧急指针有效。紧急数据一定位于当前数据包数据部分的最前面，紧急指针表明了紧急数据的尾部。</li><li>ACK=1：该字段为一表示确认号字段有效。此外，TCP还规定在连接建立后传送的所有报文段都必须把ACK置为一。</li><li>PSH=1：该字段为一表示接收端应该立即将数据push给应用层，而不是等到缓冲区满后再提交。</li><li>RST=1：该字段为一表示当前TCP连接出现严重问题，可能需要重新建立TCP连接，也可以用于拒绝非法的报文段和拒绝连接请求。</li><li>SYN=1：当SYN=1，ACK=0时，表示当前报文段是一个连接请求报文。当SYN=1，ACK=1时，表示当前报文段是一个同意建立连接的应答报文。</li><li>FIN=1：该字段为一表示此报文段是一个释放连接的请求报文。</li></ul></li></ul><h2 id="状态机"><a href="#状态机" class="headerlink" title="状态机"></a>状态机</h2><p>HTTP是无连接的，所以作为下层的TCP协议也是无连接的，虽然看似TCP将两端连接了起来，但是其实只是两端共同维护了一个状态。</p><p>TCP的状态机是很复杂的，并且与建立断开连接时的握手息息相关，接下来就来详细描述下两种握手。<br>在这之前需要了解一个重要的性能指标RTT，该指标表示发送端发送数据到接收到对端数据所需的往返时间。</p><h2 id="建立连接的三次握手"><a href="#建立连接的三次握手" class="headerlink" title="建立连接的三次握手"></a>建立连接的三次握手</h2><p>在TCP协议中，主动发起请求的一端为客户端，被动连接的一端称为服务端。不管是客户端还是服务端，TCP连接建立完成后都能发送和接收数据，所以TCP也是一个全双工的协议。</p><p>起初，两端都为CLOSED状态。在通信开始前，双方都会创建TCB。服务器创建完TCB后变进入LISTEN状态，此时开始等待客户端发送数据。</p><h3 id="第一次握手（请求连接）"><a href="#第一次握手（请求连接）" class="headerlink" title="第一次握手（请求连接）"></a>第一次握手（请求连接）</h3><p>客户端向服务端发送连接请求报文段。该报文段中包含自身的数据通讯初始序号。请求发送后，客户端便进入SYN-SENT状态，<code>x</code>表示客户端的数据通信初始序号。</p><h3 id="第二次握手（同意连接）"><a href="#第二次握手（同意连接）" class="headerlink" title="第二次握手（同意连接）"></a>第二次握手（同意连接）</h3><p>服务端收到连接请求报文段后，如果同意连接，则会发送一个应答，该应答中也会包含自身的数据通讯出书序号，发送完成后便进入SYN-RECEIVED状态。</p><h3 id="第三次握手（确认应答）"><a href="#第三次握手（确认应答）" class="headerlink" title="第三次握手（确认应答）"></a>第三次握手（确认应答）</h3><p>当客户端收到连接同意的应答后，还要向服务端发送一个确认报文。客户端发完这个报文段后便进入ESTABLISHED状态，服务端收到这个应答后也进入ESTABLISHED状态，此时连接建立成功。</p><blockquote><p>第三次握手可以包含数据，通过TCP快速打开（TFO）技术。其实只要涉及到握手的协议，都可以使用类似TFO的方式，客户端和服务端存储相同cookie，下次握手时发出cookie达到减少RTT的目的。</p></blockquote><h3 id="明明两次握手就可以建立起链接，为什么还需要第三次应答"><a href="#明明两次握手就可以建立起链接，为什么还需要第三次应答" class="headerlink" title="明明两次握手就可以建立起链接，为什么还需要第三次应答"></a>明明两次握手就可以建立起链接，为什么还需要第三次应答</h3><p>这是为了防止失效的连接请求报文段被服务端接收，从而产生错误。</p><p>可以想象如下场景：客户端发送了一个连接请求A，但是因为网络原因造成了超时，这时TCP会启动超时重传的机制，再次发送一个连接请求B。此时请求顺利到达服务端，服务端应答完就建立了请求。如果连接请求A在两端关闭后终于抵达了服务端，那么这时服务端会认为客户端又需要建立TCP连接，从而应答了该请求并进入ESTABLISHED状态。此时客户端其实是CLOSED状态，那么就会导致服务端一直等待，造成资源的浪费。</p><blockquote><p>在建立连接中，任意一端掉线，TCP都会重发SYN包，一般会重试五次，在建立连接中可能会遇到SYN FLOOD攻击。遇到这种情况你可以选择调低重试次数或者干脆在不能处理的情况下拒绝请求。</p></blockquote><h2 id="断开连接的四次握手"><a href="#断开连接的四次握手" class="headerlink" title="断开连接的四次握手"></a>断开连接的四次握手</h2><p>TCP是全双工的，在断开连接时两端都需要发送FIN和ACK。</p><h3 id="第一次握手（请求释放）"><a href="#第一次握手（请求释放）" class="headerlink" title="第一次握手（请求释放）"></a>第一次握手（请求释放）</h3><p>若客户端A认为数据发送完成，则它需要向服务端B发送连接释放请求。</p><h3 id="第二次握手（同意释放）"><a href="#第二次握手（同意释放）" class="headerlink" title="第二次握手（同意释放）"></a>第二次握手（同意释放）</h3><p>B收到连接释放请求后，会告诉应用层要释放TCP连接。然后会发送ACK包，并进入CLOSE_WAIT状态，表示A到B的连接已经释放，不接收A发的数据了。但是因为TCP连接是双向的，所以B仍旧可以发送数据给A。</p><h3 id="第三次握手（继续发没发完的请求）"><a href="#第三次握手（继续发没发完的请求）" class="headerlink" title="第三次握手（继续发没发完的请求）"></a>第三次握手（继续发没发完的请求）</h3><p>B如果此时还有没发完的数据会继续发送，完毕后会向A发送连接释放请求，然后B遍进入LAST-ACK状态</p><blockquote><p>通过延迟确认的技术（通常有时间限制，否则对方会误认为需要重传），可以将第二次和第三次握手合并，延迟ACK包的发送。</p></blockquote><h3 id="第四次握手（确认应答）"><a href="#第四次握手（确认应答）" class="headerlink" title="第四次握手（确认应答）"></a>第四次握手（确认应答）</h3><p>A收到释放请求后，向B发送确认应答，此时A进入TIME-WAIT状态。该状态会持续2MSL（最大段生存期，指报文段在网络中生存的时间，超时会被抛弃）时间，若该时间段内没有B的重发请求的话，就进入CLOSED状态。当B收到确认应答后，也便进入CLOSED状态。</p><h3 id="为什么A要进入TIME-WAIT状态，等待2MSL时间后才进入CLOSED状态？"><a href="#为什么A要进入TIME-WAIT状态，等待2MSL时间后才进入CLOSED状态？" class="headerlink" title="为什么A要进入TIME-WAIT状态，等待2MSL时间后才进入CLOSED状态？"></a>为什么A要进入TIME-WAIT状态，等待2MSL时间后才进入CLOSED状态？</h3><p>为了保证B能收到A的确认应答。若A发完确认应答后直接进入CLOSED状态，如果确认应答因为网络问题一直没有到达，那么会造成B不能正常关闭。</p><h2 id="ARQ协议"><a href="#ARQ协议" class="headerlink" title="ARQ协议"></a>ARQ协议</h2><p>ARQ协议也就是超时重传机制。通过确认和超时机制保证了数据的正确发送。包含以下两部分</p><ul><li>停止等待ARQ</li><li>连续ARQ</li></ul><h3 id="停止等待ARQ"><a href="#停止等待ARQ" class="headerlink" title="停止等待ARQ"></a>停止等待ARQ</h3><p><strong><em> 正常传输过程 </em></strong><br>只要A向B发送一段报文，都要停止发送并启动一个定时器，等待对端回应，在定时器时间内接收到对端应答就取消定时器并发送下一段报文。</p><p><strong><em> 报文丢失或出错 </em></strong><br>在报文传输的过程中可能会出现丢包。这时候超时定时器设定的时间就会再次发送丢包的数据直到对端响应，所以需要每次都备份发送的数据。</p><p>即使报文正常的传输到对端，也可能出现在传输过程中报文出错的问题。这时候对端会抛弃该报文并等待A端重传。</p><blockquote><p>一般定时器设定的时间都会大于一个RTT的平均时间。</p></blockquote><p><strong><em> ACK超时或丢失 </em></strong><br>对端传输的应答也可能出现丢失或超时的情况。那么超过定时器时间A端照样会重传报文。这时候B端收到相同序号的报文会丢弃该报文并重传应答，直到A端发送下一个序号的报文。</p><p>在超时的情况下也可康出现应答很迟到达，这时A端会判断该序号是否已经接收过，如果接收过只需要丢弃应答即可。</p><blockquote><p>这个协议的缺点就是传输效率低，在良好的网络环境下每次发送报文都得等待对端的ACK。</p></blockquote><h3 id="连续ARQ"><a href="#连续ARQ" class="headerlink" title="连续ARQ"></a>连续ARQ</h3><p>在连续ARQ中，发送端拥有一个发送窗口，可以在没有收到应答的情况下持续发送窗口内的数据，这样相比停止等待ARQ协议来说减少了等待时间，提高了效率。</p><p><strong><em> 累计确认 </em></strong><br>连续ARQ中，接收端会持续不断收到报文。如果和停止等待ARQ中接收一个报文就发送一个应答一样，就太浪费资源了。通过累积确认，可以在收到多个报文后统一回复一个应答报文。报文中的ACK可以用来告诉发送端这个序号之前的数据已经全部接受到了，下次请发送这个序号+1的数据。</p><p>但是累计确认也有一个弊端。<br>在连续接收报文时，可能会遇到接收到序号5的报文后，并未接到序号6的报文，然而序号7以后的报文已经接收。遇到这种情况时，ACK只能回复6，这样会造成发送端重复发送数据，这种情况下可以通过Sack来解决，这个会在下文说到。</p><h2 id="滑动窗口"><a href="#滑动窗口" class="headerlink" title="滑动窗口"></a>滑动窗口</h2><p>上面讲到了发送窗口。在TCP中，两端都维护着窗口</p><ul><li>发送端窗口</li><li>接收端窗口</li></ul><p>发送端窗口包含已发送但未收到应答的数据和可以发送但是未发送的数据。<br>发送端窗口是由接收端窗口剩余大小决定的。接收方会把当前接收窗口的剩余大小写入应答报文，发送端收到应答后根据该值和当前网络拥塞情况设置发送端窗口大小，所以发送端窗口大小是不断变化的。</p><p>当发送端接收到应答报文后，会随之将窗口进行滑动</p><p>滑动窗口实现了流量控制。接收方通过报文告知发送方还可以发送多少数据，从而保证接收方能够来得及接收数据。</p><h3 id="Zero窗口"><a href="#Zero窗口" class="headerlink" title="Zero窗口"></a>Zero窗口</h3><p>在发送报文的过程中，可能会遇到对端出现零窗口的情况。在该情况下，发送端会停止发送数据，并启动persistent timer。该定时器会定时发送请求给对端，让对端告知窗口大小。在重试次数超过一定次数后，可能会中断TCP连接。</p><h2 id="拥塞处理"><a href="#拥塞处理" class="headerlink" title="拥塞处理"></a>拥塞处理</h2><p>拥塞处理和流量控制不同，后者是作用于接收方，保证接收方来得及接受数据。而前者是作用于网络，防止过多的数据拥塞网络，避免出现网络负载过大的情况。</p><p>拥塞处理包括了四个算法，分别为</p><ul><li>慢开始</li><li>拥塞避免</li><li>快速重传</li><li>快速恢复</li></ul><h3 id="慢开始算法"><a href="#慢开始算法" class="headerlink" title="慢开始算法"></a>慢开始算法</h3><p>顾名思义，就是在传输开始时将发送窗口慢慢指数级扩大，从而避免一开始就传输大量数据导致网络拥塞。<br>具体步骤如下</p><ol><li>连接初始设置拥塞窗口（Congestion Window）为1MSS（一个分段的最大数据量）</li><li>每过一个RTT就将窗口大小乘二</li><li>指数级增长肯定不能没有限制的，所以有一个阈值限制，当窗口大小大于阈值时就会启动拥塞避免算法。</li></ol><h3 id="拥塞避免算法"><a href="#拥塞避免算法" class="headerlink" title="拥塞避免算法"></a>拥塞避免算法</h3><p>此算法相对简单点，每过一个RTT窗口大小只加一，这样能够避免指数级增长导致网络拥塞，慢慢将大小调整到最佳值。</p><p>在传输过程中可能出现定时器超时的情况，这时候TCP会认为网络拥塞了，会马上进行以下步骤：</p><ol><li>将阈值设为当前拥塞窗口的一半</li><li>将拥塞窗口设为1MSS</li><li>启动拥塞避免算法</li></ol><h3 id="快速重传"><a href="#快速重传" class="headerlink" title="快速重传"></a>快速重传</h3><p>快速重传一般和快速恢复一起出现。一旦接收端收到的报文出现失序的情况，接收端只会回复最后一个顺序正确的报文序号（没有Sack的情况下）。如果收到三个重复的ACK，无需等待定时器超时再重发而是启动快速重传。具体算法分为两种：</p><p><strong><em> TCP Taho </em></strong></p><ul><li>将阈值设为当前拥塞窗口的一半</li><li>将拥塞窗口设为1MSS</li><li>重新开始慢开始算法</li></ul><p><strong><em> TCP Reno </em></strong></p><ul><li>拥塞窗口减半</li><li>将阈值设为当前拥塞窗口</li><li>进入快恢复阶段（重发对端需要的包，一旦收到一个新的ACK答复就退出该阶段）</li><li>使用拥塞避免算法</li></ul><h3 id="TCP-New-Reno-改进后的快速恢复"><a href="#TCP-New-Reno-改进后的快速恢复" class="headerlink" title="TCP New Reno 改进后的快速恢复"></a>TCP New Reno 改进后的快速恢复</h3><p>TCP New Reno 算法改进了之前 TCP Reno 算法的缺陷。在之前，快恢复中只要收到一个新的ACK包，就会退出快恢复。</p><p>在 TCP New Reno 中，TCP发送方先记下三个重复ACK的分段的最大序号。</p><p>假如我有一个分段数据是1~10这十个序号的报文，其中丢失了序号为3和7的报文，那么该分段的最大序号就是10。发送端只会收到ACK序号为3的应答。这时候重发序号为3的报文，接收方顺利接收并会发送ACK序号为7的应答。这时候TCP知道对端是有多个包未收到，会继续发送序号为7的报文，接收方顺利接收并会发送ACK序号为11的应答，这时发送端认为这个分段接收端已经顺利接收，接下来会退出快速恢复阶段。</p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;UDP&quot;&gt;&lt;a href=&quot;#UDP&quot; class=&quot;headerlink&quot; title=&quot;UDP&quot;&gt;&lt;/a&gt;UDP&lt;/h1&gt;&lt;h2 id=&quot;面向报文&quot;&gt;&lt;a href=&quot;#面向报文&quot; class=&quot;headerlink&quot; title=&quot;面向报文&quot;&gt;&lt;/a&gt;面向报文&lt;/h2&gt;&lt;p&gt;UDP是一个面向报文（报文可以理解为一段段的数据）的协议。意思就是UDP只是报文的搬运工，不会对报文进行任何拆分和拼接操作。&lt;/p&gt;
&lt;p&gt;具体来说&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;在发送端，应用层将数据传递给传输层的UDP协议，UDP只会给数据增加一个UDP头标识下是UDP协议，然后就传递给网络层了&lt;/li&gt;
&lt;li&gt;在接收端，网络层将数据传递给传输层，UDP只去除IP报文头就传递给应用层，不会任何拼接操作&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&quot;不可靠性&quot;&gt;&lt;a href=&quot;#不可靠性&quot; class=&quot;headerlink&quot; title=&quot;不可靠性&quot;&gt;&lt;/a&gt;不可靠性&lt;/h2&gt;&lt;ol&gt;
&lt;li&gt;UDP是无连接的，也就是说通信不需要建立和断开。&lt;/li&gt;
&lt;li&gt;UDP是不可靠的，协议收到什么数据就传递什么数据，并且也不会备份数据，对方能不能收到也不关心。&lt;/li&gt;
&lt;li&gt;UDP没有拥塞控制，一直会以恒定的速度发送数据。即使网络条件不好，也不会对发送速率进行调整。&lt;ul&gt;
&lt;li&gt;弊端：在网络条件不好的情况下会导致丢包&lt;/li&gt;
&lt;li&gt;优点：在某些实时性要求高的场景（比如电话会议），就需要使用UDP而不是TCP&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ol&gt;
    
    </summary>
    
      <category term="学习笔记" scheme="http://1eeing.github.io/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="基础知识" scheme="http://1eeing.github.io/tags/%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"/>
    
      <category term="计算机通识" scheme="http://1eeing.github.io/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E9%80%9A%E8%AF%86/"/>
    
      <category term="网络" scheme="http://1eeing.github.io/tags/%E7%BD%91%E7%BB%9C/"/>
    
      <category term="学习笔记" scheme="http://1eeing.github.io/tags/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
      <category term="TCP" scheme="http://1eeing.github.io/tags/TCP/"/>
    
      <category term="UDP" scheme="http://1eeing.github.io/tags/UDP/"/>
    
  </entry>
  
  <entry>
    <title>【React篇】分析diff算法</title>
    <link href="http://1eeing.github.io/2018/08/05/ReactDiff/"/>
    <id>http://1eeing.github.io/2018/08/05/ReactDiff/</id>
    <published>2018-08-04T18:20:18.000Z</published>
    <updated>2018-08-07T10:14:33.000Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>diff算法大家都耳熟能详，React中最值得称道的部分莫过于Virtual DOM与diff的完美结合，特别是其高效的diff算法，可以让用户无需顾忌性能问题而“任性自由”地刷新页面。因为diff会帮助我们计算出Virtual DOM中真正变化的部分，并只针对该部分进行原生DOM操作，而非重新渲染整个页面，从而保证了每次操作更新后页面的高效渲染。</p></blockquote><h1 id="传统的diff算法"><a href="#传统的diff算法" class="headerlink" title="传统的diff算法"></a>传统的diff算法</h1><p>diff算法，即微分算法。计算一颗树形结构转换成另一颗树形结构的最少操作，是一个复杂且值得研究的问题。传统diff算法通过循环递归对节点进行依次对比，效率低下，算法复杂度达到O(n^3)，其中n是树中节点的总数。这意味着如果要展示1000个节点，就要依次执行上十亿次的比较。这种指数型的性能消耗对于前端渲染场景来说太可怕了！</p><h1 id="react中的diff算法"><a href="#react中的diff算法" class="headerlink" title="react中的diff算法"></a>react中的diff算法</h1><h3 id="diff策略"><a href="#diff策略" class="headerlink" title="diff策略"></a>diff策略</h3><p>首先，我们需要知道react的diff算法有3个策略</p><ol><li>WebUI中DOM节点跨层级的移动操作特别少，可以忽略不计</li><li>拥有相同类的两个组件将会生成相似的树形结构，拥有不同类的两个组件将会生成不同的属性结构</li><li>对于同一层级的一组子节点，它们可以通过唯一id进行区分</li></ol><a id="more"></a><h3 id="tree-diff"><a href="#tree-diff" class="headerlink" title="tree diff"></a>tree diff</h3><p>基于策略一，React对树的算法进行了简洁明了的优化，即对树进行分层比较，两棵树只会对同一层级进行比较。当发现节点不存在时，测该节点及其子节点会全部被删掉，不会进行进一步的比较。</p><blockquote><p>如果出现了节点跨层级的移动，diff会有怎样的表现呢？</p></blockquote><p>假设有A、B两个父节点，a、b两个子节点，形如A-&gt;a,B-&gt;b，当a从A之下移动到A、B平级时，当A发现a不在了，则会删除a及a的子节点，当A、B这一层级发现多出了a时，则会创建一个a。</p><h4 id="这是一种影响react性能的操作，因此官方建议不要进行dom节点跨层级的操作。"><a href="#这是一种影响react性能的操作，因此官方建议不要进行dom节点跨层级的操作。" class="headerlink" title="这是一种影响react性能的操作，因此官方建议不要进行dom节点跨层级的操作。"></a>这是一种影响react性能的操作，因此官方建议不要进行dom节点跨层级的操作。</h4><h3 id="component-diff"><a href="#component-diff" class="headerlink" title="component diff"></a>component diff</h3><p>react是基于组件构建应用的，对于组件间的比较所采取的策略也是非常简洁、高效的。</p><ol><li>如果是同一类型的组件，按照原策略继续比较Virtual Dom树即可</li><li>如果不是，则将该组件判断为dirty component，从而替换整个组件下的所有子节点。</li><li>对于同一类型的组件，有可能其Virtual Dom没有任何变化，如果能够确切的知道这点，那么就可以节省大量的diff运算时间。因此react提供shouldComponentUpdate()来判断该组件是否需要进行diff算法分析。</li></ol><blockquote><p>这里存在一个问题，如果有一个组件D，下面有E、F两个子节点，当D变为G时，虽然子节点依然是E、F，但react会认为它是不同类型的组件，会直接删除D，重新创建G，尽管D和G结构相似。这时虽然diff会影响性能，但正如diff策略二所言：不同类型的组件很少存在相似dom树的情况，因此这种极端因素很难在实际开发过程中造成重大的影响。</p></blockquote><h3 id="element-diff"><a href="#element-diff" class="headerlink" title="element diff"></a>element diff</h3><p>当节点处于同一层级时，diff提供了3种节点操作。</p><ul><li>增 INSERT_MARKUP</li><li>删 REMOVE_NODE</li><li>移 MOVE_EXISTING</li></ul><p>增和删比较好理解，这里不再赘述了，这里主要讲一下“移”。<br>按照diff策略三，我们在同一层级的节点上加入了唯一id，以下简称key。</p><ul><li>当没有添加key时，移是比较蛋疼的，假设有一组旧节点A、B、C、D和一组新节点B、A、D、C，此时diff发现 B!=A，则创建并插入B至新集合，删除旧集合A，以此类推，创建并插入A、D、C，删除B、C、D。这怎么玩？</li><li>当有了key之后，那就愉快多了。依然是上述的两组新旧节点，此时diff通过key发现新旧集合中的节点都是相同的节点，因此无需进行节点删除和创建，只需要将旧集合中节点的位置进行移动即可。</li></ul><h4 id="那么具体是怎么移动的呢？"><a href="#那么具体是怎么移动的呢？" class="headerlink" title="那么具体是怎么移动的呢？"></a>那么具体是怎么移动的呢？</h4><p>依然是上述的A、B、C、D和B、A、D、C。首先对新集合中的节点进行遍历，通过key判断新旧集合中是否存在相同的节点，如果存在，则移动。但在移动之前需要将当前节点在旧集合中的位置oldIndex与lastIndex进行比较，如果lastIndex &gt; oldIndex，则进行移动。</p><p>以A为例，在新集合中，发现A的lastIndex = 1，旧集合中oldIndex = 0，此时lastIndex &gt; oldIndex，则将A进行移动，并将lastIndex更新为新集合中A的位置。A.oldIndex此时为1。进入下一个节点的判断……</p><h3 id="react中diff的不足与待优化的点？"><a href="#react中diff的不足与待优化的点？" class="headerlink" title="react中diff的不足与待优化的点？"></a>react中diff的不足与待优化的点？</h3><p>如果A、B、C、D更新为D、A、B、C，理论上只要移动D即可，然而由于D在就集合中的位置是最大的，导致实际是A、B、C移动到D之后。因此建议在开发过程中，尽量减少类似将最后一个节点移动到列表首部的操作，当节点数量过大或更新操作过于频繁时，这在一定程度上会影响react的渲染性能。</p>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;diff算法大家都耳熟能详，React中最值得称道的部分莫过于Virtual DOM与diff的完美结合，特别是其高效的diff算法，可以让用户无需顾忌性能问题而“任性自由”地刷新页面。因为diff会帮助我们计算出Virtual DOM中真正变化的部分，并只针对该部分进行原生DOM操作，而非重新渲染整个页面，从而保证了每次操作更新后页面的高效渲染。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h1 id=&quot;传统的diff算法&quot;&gt;&lt;a href=&quot;#传统的diff算法&quot; class=&quot;headerlink&quot; title=&quot;传统的diff算法&quot;&gt;&lt;/a&gt;传统的diff算法&lt;/h1&gt;&lt;p&gt;diff算法，即微分算法。计算一颗树形结构转换成另一颗树形结构的最少操作，是一个复杂且值得研究的问题。传统diff算法通过循环递归对节点进行依次对比，效率低下，算法复杂度达到O(n^3)，其中n是树中节点的总数。这意味着如果要展示1000个节点，就要依次执行上十亿次的比较。这种指数型的性能消耗对于前端渲染场景来说太可怕了！&lt;/p&gt;
&lt;h1 id=&quot;react中的diff算法&quot;&gt;&lt;a href=&quot;#react中的diff算法&quot; class=&quot;headerlink&quot; title=&quot;react中的diff算法&quot;&gt;&lt;/a&gt;react中的diff算法&lt;/h1&gt;&lt;h3 id=&quot;diff策略&quot;&gt;&lt;a href=&quot;#diff策略&quot; class=&quot;headerlink&quot; title=&quot;diff策略&quot;&gt;&lt;/a&gt;diff策略&lt;/h3&gt;&lt;p&gt;首先，我们需要知道react的diff算法有3个策略&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;WebUI中DOM节点跨层级的移动操作特别少，可以忽略不计&lt;/li&gt;
&lt;li&gt;拥有相同类的两个组件将会生成相似的树形结构，拥有不同类的两个组件将会生成不同的属性结构&lt;/li&gt;
&lt;li&gt;对于同一层级的一组子节点，它们可以通过唯一id进行区分&lt;/li&gt;
&lt;/ol&gt;
    
    </summary>
    
      <category term="学习笔记" scheme="http://1eeing.github.io/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="学习笔记" scheme="http://1eeing.github.io/tags/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
      <category term="React" scheme="http://1eeing.github.io/tags/React/"/>
    
      <category term="diff算法" scheme="http://1eeing.github.io/tags/diff%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>【浏览器篇】浏览器中的Event Loop</title>
    <link href="http://1eeing.github.io/2018/08/05/eventLoop/"/>
    <id>http://1eeing.github.io/2018/08/05/eventLoop/</id>
    <published>2018-08-04T18:17:41.000Z</published>
    <updated>2018-08-07T10:14:56.000Z</updated>
    
    <content type="html"><![CDATA[<p>在讲Event loop之前，我们先思考一个问题</p><h2 id="js为什么是单线程？"><a href="#js为什么是单线程？" class="headerlink" title="js为什么是单线程？"></a>js为什么是单线程？</h2><p>原因可能是如果js是多线程，在多个线程中处理DOM就可能会发生问题（一个线程添加新节点，另一个线程中删除节点），当然可以引入读写锁解决这个问题</p><p>好了，接下来我们开始讲Event loop</p><blockquote><p>简单的说，就是js在执行的过程中会产生执行环境，这些执行环境会被顺序的加入到执行栈中。如果遇到异步的代码，会被挂起并加入到Task（有多种Task）队列中。一旦执行栈为空，Event Loop就会从Task队列中拿出需要执行的代码并放入执行栈中执行，所以本质上来说，js中的异步行为还是同步的。</p></blockquote><a id="more"></a><p>我们看下以下代码，以下代码输出’1’, ‘3’, ‘2’<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(<span class="string">'1'</span>);</span><br><span class="line">setTimeout(<span class="function"><span class="params">()</span>=&gt;</span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'2'</span>);</span><br><span class="line">&#125;, <span class="number">0</span>);</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'3'</span>);</span><br><span class="line"><span class="comment">//'1'</span></span><br><span class="line"><span class="comment">//'3'</span></span><br><span class="line"><span class="comment">//'2'</span></span><br></pre></td></tr></table></figure></p><p>之前对setTimeout理解有偏差，虽然设置了为0，其实还是异步，是因为html5标准规定这个函数的第二个参数不得小于4ms，不足会自动增加。</p><h2 id="Task队列分为两种"><a href="#Task队列分为两种" class="headerlink" title="Task队列分为两种"></a>Task队列分为两种</h2><ul><li><p>微任务microtask，es6中称为jobs。以下这些行为属于微任务</p><ul><li>process.nextTick</li><li>promise</li><li>Object.observe</li><li>MutationObserver</li></ul></li><li><p>宏任务macrotask，es6中称为task。以下这些行为属于宏任务</p><ul><li>script</li><li>setTimeout</li><li>setInterval</li><li>setImmediate</li><li>I/O</li><li>UI rendering</li></ul></li></ul><blockquote><p>误区：很多人认为微任务快于宏任务，其实是错误的。因为宏任务汇中包括了script，浏览器会先执行一个宏任务，接下来有异步代码的话就先执行微任务。</p></blockquote><p>正确的一次Event loop顺序应该是这样的：</p><ol><li>执行同步代码（这属于宏任务）</li><li>执行栈为空，查询是否有微任务需要执行</li><li>执行所有微任务</li><li>必要的话渲染UI</li><li>开始下一轮Event loop，执行宏任务中的异步代码</li></ol><p>通过上述的Event loop顺序可知，如果宏任务中的异步代码有大量的计算并且需要操作DOM的话，为了更快的界面响应，我们可以把操作DOM放入微任务中。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;在讲Event loop之前，我们先思考一个问题&lt;/p&gt;
&lt;h2 id=&quot;js为什么是单线程？&quot;&gt;&lt;a href=&quot;#js为什么是单线程？&quot; class=&quot;headerlink&quot; title=&quot;js为什么是单线程？&quot;&gt;&lt;/a&gt;js为什么是单线程？&lt;/h2&gt;&lt;p&gt;原因可能是如果js是多线程，在多个线程中处理DOM就可能会发生问题（一个线程添加新节点，另一个线程中删除节点），当然可以引入读写锁解决这个问题&lt;/p&gt;
&lt;p&gt;好了，接下来我们开始讲Event loop&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;简单的说，就是js在执行的过程中会产生执行环境，这些执行环境会被顺序的加入到执行栈中。如果遇到异步的代码，会被挂起并加入到Task（有多种Task）队列中。一旦执行栈为空，Event Loop就会从Task队列中拿出需要执行的代码并放入执行栈中执行，所以本质上来说，js中的异步行为还是同步的。&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="学习笔记" scheme="http://1eeing.github.io/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="基础知识" scheme="http://1eeing.github.io/tags/%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"/>
    
      <category term="计算机通识" scheme="http://1eeing.github.io/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E9%80%9A%E8%AF%86/"/>
    
      <category term="学习笔记" scheme="http://1eeing.github.io/tags/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
      <category term="浏览器" scheme="http://1eeing.github.io/tags/%E6%B5%8F%E8%A7%88%E5%99%A8/"/>
    
      <category term="Event loop" scheme="http://1eeing.github.io/tags/Event-loop/"/>
    
  </entry>
  
</feed>
