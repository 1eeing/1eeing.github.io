<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>leeing的登山之旅</title>
  
  <subtitle>前往空气稀薄地带</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://1eeing.github.io/"/>
  <updated>2020-06-09T13:19:55.628Z</updated>
  <id>http://1eeing.github.io/</id>
  
  <author>
    <name>leeing</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>如何优化首次渲染时的前置请求？</title>
    <link href="http://1eeing.github.io/2020/06/09/%E5%A6%82%E4%BD%95%E4%BC%98%E5%8C%96%E9%A6%96%E6%AC%A1%E6%B8%B2%E6%9F%93%E6%97%B6%E7%9A%84%E5%89%8D%E7%BD%AE%E8%AF%B7%E6%B1%82/"/>
    <id>http://1eeing.github.io/2020/06/09/如何优化首次渲染时的前置请求/</id>
    <published>2020-06-09T12:57:10.333Z</published>
    <updated>2020-06-09T13:19:55.628Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://user-gold-cdn.xitu.io/2020/6/9/1729936b1aec7919?w=512&amp;h=512&amp;f=jpeg&amp;s=105066" alt="chahua"></p><blockquote><p>插画来自谷歌搜索</p></blockquote><h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><p>在业务中，我们经常会遇到这么一些情况，每个请求需要带一些前置信息，例如<code>token</code>、<code>用户id</code> 等等，然而，这些信息也是需要异步请求得到的。</p><h2 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h2><p>我们一般会立马想到以下两种方案：</p><ol><li>ssr服务端渲染</li><li>前端请求拦截</li></ol><p>ssr服务端渲染比较好理解，服务端去请求前置信息，然后把结果添加到返回的html或者url里，前端直接取就好了，本文不做过多介绍。主要看下第二种方案，前端如何去解决呢？</p><a id="more"></a><h2 id="一般方案"><a href="#一般方案" class="headerlink" title="一般方案"></a>一般方案</h2><p>相信聪明的读者看到这里，立马会想到：</p><blockquote><p>简单~拦截发起请求的方法，在每个请求发起前，先去请求前置信息，如果请求到了，就把这些数据缓存下来，防止下次请求时再去请求这些信息。</p></blockquote><p>我们以请求token的场景为例，写一下代码</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// fetch.js</span></span><br><span class="line"><span class="keyword">let</span> token = <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> requestToken = <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (token) &#123;</span><br><span class="line">      <span class="keyword">return</span> resolve(token);</span><br><span class="line">    &#125;</span><br><span class="line">    setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">      token = <span class="string">'this is token'</span>;</span><br><span class="line">      <span class="built_in">console</span>.log(<span class="string">'请求 token 成功一次'</span>);</span><br><span class="line">      resolve(token);</span><br><span class="line">    &#125;, <span class="number">300</span>);</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> request = <span class="keyword">async</span> (args) =&gt; &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="keyword">async</span> (resolve, reject) =&gt; &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      <span class="keyword">const</span> token = <span class="keyword">await</span> requestToken();</span><br><span class="line">      setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">        resolve(<span class="string">`<span class="subst">$&#123;args&#125;</span> 请求成功了，token是 <span class="subst">$&#123;token&#125;</span>`</span>);</span><br><span class="line">      &#125;, <span class="number">300</span>);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (error) &#123;</span><br><span class="line">      reject(<span class="string">'请求失败了'</span>)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> getUserInfo = <span class="function"><span class="params">()</span> =&gt;</span> request(<span class="string">'getUserInfo'</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> getList = <span class="function"><span class="params">()</span> =&gt;</span> request(<span class="string">'getList'</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> getDetail = <span class="function"><span class="params">()</span> =&gt;</span> request(<span class="string">'getDetail'</span>);</span><br></pre></td></tr></table></figure><p>可以看到，我们用 <code>setTimeout模拟异步请求</code>，封装了 <code>requestToken</code> 和 <code>request</code> 方法，并对外暴露3个请求函数，分别是 <code>getUserInfo</code>、 <code>getList</code> 和 <code>getDetail</code>。</p><p>接下去在首次渲染的时候去并发这三个请求函数，在这三次并发请求完成后，再执行任意一个请求函数，验证下是否只请求了一次token。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// homepage.jsx</span></span><br><span class="line"><span class="keyword">import</span> React <span class="keyword">from</span> <span class="string">'react'</span>;</span><br><span class="line"><span class="keyword">import</span> &#123; getUserInfo, getList, getDetail &#125; <span class="keyword">from</span> <span class="string">'./fetch.js'</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> Homepage = <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">  React.useEffect(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">Promise</span>.all([</span><br><span class="line">      getUserInfo(),</span><br><span class="line">      getList(),</span><br><span class="line">      getDetail(),</span><br><span class="line">    ]).then(<span class="function"><span class="params">res</span> =&gt;</span> &#123;</span><br><span class="line">      <span class="built_in">console</span>.log(<span class="string">'并发请求成功'</span>, res);</span><br><span class="line">    &#125;).catch(<span class="function"><span class="params">e</span> =&gt;</span> &#123;</span><br><span class="line">      <span class="built_in">console</span>.error(<span class="string">'并发请求失败'</span>, e);</span><br><span class="line">    &#125;)</span><br><span class="line"></span><br><span class="line">    setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">      getUserInfo().then(<span class="function"><span class="params">res</span> =&gt;</span> &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">'等到上面的并发请求完成后再请求'</span>, res);</span><br><span class="line">      &#125;).catch(<span class="function"><span class="params">e</span> =&gt;</span> &#123;</span><br><span class="line">        <span class="built_in">console</span>.error(<span class="string">'第二次请求失败'</span>, e);</span><br><span class="line">      &#125;);</span><br><span class="line">    &#125;, <span class="number">2000</span>);</span><br><span class="line">  &#125;, [])</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    &lt;div&gt;This is homepage.&lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">  )</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">export default Homepage;</span></span><br></pre></td></tr></table></figure><p>OK，接下来我们看下效果。</p><p><img src="https://user-gold-cdn.xitu.io/2020/6/9/1729937516518da1?w=2240&amp;h=102&amp;f=png&amp;s=163221" alt="p1"></p><p><img src="https://user-gold-cdn.xitu.io/2020/6/9/1729937b6e3bfedb?w=2258&amp;h=146&amp;f=png&amp;s=210978" alt="p2"></p><p><strong>问题来了，requestToken请求了多次</strong></p><p>可以看到，首次并发请求时，由于没有一个 <code>requestToken</code> 请求返回，所以 <code>requestToken</code> 发起了3次请求。后面一个 <code>getUserInfo</code> 执行时，由于token这时已经返回过结果了，所以没有再次发起请求</p><p>会导致什么问题？</p><ol><li>在一次访问中，<code>requestToken</code> 重复请求是毫无意义的，浪费流量</li><li>在 <code>http2.0</code> 以前，浏览器同时并发的请求数是有限制的，<code>requestToken</code> 占用了请求通道，势必会影响其他请求，降低用户体验</li></ol><p>作为一个对性能有追求的前端，这是不能忍的。那如何去优化呢？</p><h2 id="优化版"><a href="#优化版" class="headerlink" title="优化版"></a>优化版</h2><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>我们封装一个高阶函数 <code>fetchOnce</code>，这个高阶函数的作用是包裹真正的请求函数，当该包裹函数调用时，将真正的请求函数push到请求队列中，然后依次去执行请求函数。如果请求成功了，就存储结果并返回，如果请求失败了，就继续请求，直到请求队列为空。</p><p>除此之外，还有几个细节需要考虑。</p><h3 id="如何阻塞请求？"><a href="#如何阻塞请求？" class="headerlink" title="如何阻塞请求？"></a>如何阻塞请求？</h3><p>这个很简单，加一个锁就好了。当有请求在处理的时候，把锁锁上，后续的请求就不会继续请求了。当某个请求成功后或全部失败后，把锁重新打开。</p><h3 id="当某个请求成功时或全部失败时，如何通知所有的请求函数正确处理结果呢？"><a href="#当某个请求成功时或全部失败时，如何通知所有的请求函数正确处理结果呢？" class="headerlink" title="当某个请求成功时或全部失败时，如何通知所有的请求函数正确处理结果呢？"></a>当某个请求成功时或全部失败时，如何通知所有的请求函数正确处理结果呢？</h3><p>一样用到队列，每次调用包裹函数时，因为返回的是一个promise，所以往promise队列push当前promise的resolve和reject方法，当某个请求成功时，就执行promise队列中所有promise的resolve方法；当全部请求失败时，就执行promise队列中所有promise的reject方法。</p><p>按着这个思路，我们可以马上写出代码</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// fetchonce.js</span></span><br><span class="line"><span class="comment">// 高阶函数，参数是真实的请求函数</span></span><br><span class="line"><span class="keyword">const</span> fetchOnce = <span class="function">(<span class="params">fn</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="comment">// 请求函数队列</span></span><br><span class="line">  <span class="keyword">const</span> fnQueue = [];</span><br><span class="line">  <span class="comment">// promise队列</span></span><br><span class="line">  <span class="keyword">const</span> promiseQueue = [];</span><br><span class="line">  <span class="comment">// 错误队列，用于收集每一次的错误信息，当全部失败时都要返回</span></span><br><span class="line">  <span class="keyword">const</span> errors = [];</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 用于缓存结果</span></span><br><span class="line">  <span class="keyword">let</span> result;</span><br><span class="line">  <span class="comment">// 请求锁</span></span><br><span class="line">  <span class="keyword">let</span> lock = <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 消费promise队列</span></span><br><span class="line">  <span class="keyword">const</span> dispatch = <span class="function">(<span class="params">isSuccess, value</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">while</span>(promiseQueue.length)&#123;</span><br><span class="line">      <span class="keyword">const</span> p = promiseQueue.shift();</span><br><span class="line">      p[isSuccess ? <span class="string">'resolve'</span> : <span class="string">'reject'</span>](value);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 返回包裹函数</span></span><br><span class="line">  <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params">...args</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="keyword">async</span> (resolve, reject) =&gt; &#123;</span><br><span class="line">      <span class="comment">// 当有结果时，直接resolve结果</span></span><br><span class="line">      <span class="keyword">if</span>(result)&#123;</span><br><span class="line">        <span class="keyword">return</span> resolve(result);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">// 将真实的请求函数和当前的resolve reject塞入队列中</span></span><br><span class="line">      fnQueue.push(fn);</span><br><span class="line">      promiseQueue.push(&#123;resolve, reject&#125;);</span><br><span class="line">      <span class="comment">// 如果锁住了，就不要继续往下执行了</span></span><br><span class="line">      <span class="keyword">if</span>(lock)&#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      lock = <span class="literal">true</span>;</span><br><span class="line">      <span class="comment">// 遍历请求函数队列，依次执行</span></span><br><span class="line">      <span class="keyword">for</span>(<span class="keyword">let</span> func <span class="keyword">of</span> fnQueue)&#123;</span><br><span class="line">        <span class="keyword">try</span>&#123;</span><br><span class="line">          <span class="comment">// 如果有一个成功了，清空请求队列和错误队列，缓存结果，消费promise，放开锁</span></span><br><span class="line">          <span class="keyword">const</span> res = <span class="keyword">await</span> func.apply(<span class="keyword">this</span>, args);</span><br><span class="line">          fnQueue.length = <span class="number">0</span>;</span><br><span class="line">          errors.length = <span class="number">0</span>;</span><br><span class="line">          result = res;</span><br><span class="line">          dispatch(<span class="literal">true</span>, res);</span><br><span class="line">          lock = <span class="literal">false</span>;</span><br><span class="line">        &#125;<span class="keyword">catch</span>(e)&#123;</span><br><span class="line">          errors.push(e);</span><br><span class="line">          <span class="comment">// 如果全部失败了，消费promise队列，清空请求队列和错误队列，放开锁</span></span><br><span class="line">          <span class="keyword">if</span>(errors.length &amp;&amp; errors.length === promiseQueue.length)&#123;</span><br><span class="line">            dispatch(<span class="literal">false</span>, [...errors]);</span><br><span class="line">            fnQueue.length = <span class="number">0</span>;</span><br><span class="line">            errors.length = <span class="number">0</span>;</span><br><span class="line">            lock = <span class="literal">false</span>;</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>接着我们用这个高阶函数包裹一下 <code>requestToken</code>，并修改一下 <code>request</code> 函数来试试效果</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// fetch.js</span></span><br><span class="line"><span class="keyword">import</span> fetchOnce <span class="keyword">from</span> <span class="string">'./fetchonce.js'</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> requestTokenOnce = fetchOnce(requestToken);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> request = <span class="function">(<span class="params">args</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="keyword">async</span> (resolve, reject) =&gt; &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      <span class="keyword">const</span> token = <span class="keyword">await</span> requestTokenOnce();</span><br><span class="line">      setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">        resolve(<span class="string">`<span class="subst">$&#123;args&#125;</span> 请求成功了，token是 <span class="subst">$&#123;token&#125;</span>`</span>);</span><br><span class="line">      &#125;, <span class="number">300</span>);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (error) &#123;</span><br><span class="line">      reject(<span class="string">'请求失败了'</span>)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们看一下页面中的打印结果</p><p><img src="https://user-gold-cdn.xitu.io/2020/6/9/17299382b7ab14f6?w=2242&amp;h=154&amp;f=png&amp;s=212552" alt="p3"></p><p>结果跟预期想象的一样，<code>requestToken</code> 只真正请求了一次token，接下去我们模拟测试一下请求失败的场景。</p><p>我们修改一下 <code>requestToken</code> 函数，让他随机成功或失败</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> requestToken = <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (token) &#123;</span><br><span class="line">      <span class="keyword">return</span> resolve(token);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">const</span> random = <span class="built_in">Math</span>.random() * <span class="number">10</span>;</span><br><span class="line">    setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">      <span class="keyword">if</span> (random &gt; <span class="number">5</span>) &#123;</span><br><span class="line">        token = <span class="string">'this is token'</span>;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">'请求 token 成功一次'</span>);</span><br><span class="line">        resolve(token);</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">console</span>.error(<span class="string">'请求 token 失败一次'</span>);</span><br><span class="line">        reject(<span class="string">'token 请求失败了'</span>);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;, <span class="number">300</span>);</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们刷新多次，看下有失败的情况下，token的请求情况</p><p><strong><em>失败一次</em></strong><br><img src="https://user-gold-cdn.xitu.io/2020/6/9/172975019c182928?w=2232&amp;h=194&amp;f=jpeg&amp;s=46578" alt="https://user-gold-cdn.xitu.io/2020/6/9/172975019c182928?w=2232&amp;h=194&amp;f=jpeg&amp;s=46578"></p><p><strong><em>失败二次</em></strong><br><img src="https://user-gold-cdn.xitu.io/2020/6/9/172975019c210edb?w=2252&amp;h=238&amp;f=jpeg&amp;s=52003" alt="https://user-gold-cdn.xitu.io/2020/6/9/172975019c210edb?w=2252&amp;h=238&amp;f=jpeg&amp;s=52003"></p><p><strong><em>并发三次全失败，并发后的那次成功</em></strong><br><img src="https://user-gold-cdn.xitu.io/2020/6/9/17297501c799a224?w=1124&amp;h=282&amp;f=jpeg&amp;s=35039" alt="https://user-gold-cdn.xitu.io/2020/6/9/17297501c799a224?w=1124&amp;h=282&amp;f=jpeg&amp;s=35039"></p><p><strong><em>全部失败</em></strong><br><img src="https://user-gold-cdn.xitu.io/2020/6/9/17297501c81aad95?w=542&amp;h=276&amp;f=jpeg&amp;s=23304" alt="https://user-gold-cdn.xitu.io/2020/6/9/17297501c81aad95?w=542&amp;h=276&amp;f=jpeg&amp;s=23304"></p><p>OK，效果跟想象中的一样，用fetchOnce包裹后的一批并发请求中，有一个请求成功了，则大家都成功；全部失败了，此次请求才算失败。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>以上，我们就用队列实现了并发请求控制，从而解决了<strong>首次渲染时，前置请求会并发多次</strong>的问题，皆大欢喜~</p><p>完整的代码仓库可以查看这里 <a href="https://github.com/1eeing/fetchOnce" target="_blank" rel="noopener">fetchOnce</a>，喜欢的朋友可以留下你们的赞和star~</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;https://user-gold-cdn.xitu.io/2020/6/9/1729936b1aec7919?w=512&amp;amp;h=512&amp;amp;f=jpeg&amp;amp;s=105066&quot; alt=&quot;chahua&quot;&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;插画来自谷歌搜索&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;背景&quot;&gt;&lt;a href=&quot;#背景&quot; class=&quot;headerlink&quot; title=&quot;背景&quot;&gt;&lt;/a&gt;背景&lt;/h2&gt;&lt;p&gt;在业务中，我们经常会遇到这么一些情况，每个请求需要带一些前置信息，例如&lt;code&gt;token&lt;/code&gt;、&lt;code&gt;用户id&lt;/code&gt; 等等，然而，这些信息也是需要异步请求得到的。&lt;/p&gt;
&lt;h2 id=&quot;解决方案&quot;&gt;&lt;a href=&quot;#解决方案&quot; class=&quot;headerlink&quot; title=&quot;解决方案&quot;&gt;&lt;/a&gt;解决方案&lt;/h2&gt;&lt;p&gt;我们一般会立马想到以下两种方案：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;ssr服务端渲染&lt;/li&gt;
&lt;li&gt;前端请求拦截&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;ssr服务端渲染比较好理解，服务端去请求前置信息，然后把结果添加到返回的html或者url里，前端直接取就好了，本文不做过多介绍。主要看下第二种方案，前端如何去解决呢？&lt;/p&gt;
    
    </summary>
    
      <category term="个人原创" scheme="http://1eeing.github.io/categories/%E4%B8%AA%E4%BA%BA%E5%8E%9F%E5%88%9B/"/>
    
    
      <category term="性能优化" scheme="http://1eeing.github.io/tags/%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/"/>
    
  </entry>
  
  <entry>
    <title>编写一个javascript元循环求值器</title>
    <link href="http://1eeing.github.io/2020/04/14/%E7%BC%96%E5%86%99%E4%B8%80%E4%B8%AAjavascript%E5%85%83%E5%BE%AA%E7%8E%AF%E6%B1%82%E5%80%BC%E5%99%A8/"/>
    <id>http://1eeing.github.io/2020/04/14/编写一个javascript元循环求值器/</id>
    <published>2020-04-14T12:53:15.201Z</published>
    <updated>2020-04-14T12:54:22.804Z</updated>
    
    <content type="html"><![CDATA[<p><img src="http://dpic.tiankong.com/23/zf/QJ6129071387.jpg?x-oss-process=style/shows" alt="http://dpic.tiankong.com/23/zf/QJ6129071387.jpg?x-oss-process=style/shows"></p><blockquote><p>在上一篇文章中，我们通过AST完成了微信小程序组件的多端编译，在这篇文章中，让我们更深入一点，通过AST完成一个javascript元循环求值器</p></blockquote><a id="more"></a><h2 id="结构"><a href="#结构" class="headerlink" title="结构"></a>结构</h2><p>一个元循环求值器，完整的应该包含以下内容：</p><ul><li>tokenizer：对代码文本进行词法和语法分析，将代码分割成若干个token</li><li>parser：根据token，生成AST树</li><li>evaluate：根据AST树节点的type，执行对应的apply方法</li><li>apply：根据环境，执行实际的求值计算</li><li>scope：当前代码执行的环境</li></ul><h2 id="代码目录"><a href="#代码目录" class="headerlink" title="代码目录"></a>代码目录</h2><p>根据结构看，我将代码目录大致拆分为以下几个文件</p><ul><li>parser</li><li>eval</li><li>scope</li></ul><p>tokenizer和parser这两个过程不是本文的重点，我统一放在了parser中，交由 <code>@babel/parser</code> 来处理。</p><p>evaluate和apply这两个过程我统一放在了eval文件中处理，一会我们重点看下这部分。</p><p>scope则放入scope文件。</p><h2 id="evaluate-apply"><a href="#evaluate-apply" class="headerlink" title="evaluate-apply"></a>evaluate-apply</h2><p>这其实是一个递归计算的过程。<br>首先，<code>evaluate</code> 接收两个参数，<code>node</code> 当前遍历的AST树节点和 <code>scope</code> 当前环境。然后，evaluate去根据 <code>node</code> 的 <code>type</code> 属性，判断该节点是什么类型。判断出类型后，执行 <code>apply</code> 去求值这个节点所代表的表达式。<code>apply</code> 中会再次递归的执行 <code>evaluate</code> 去计算当前节点的子节点。最终，执行完整颗AST树。</p><p>我们来看下具体代码吧</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> evaluate = <span class="function">(<span class="params">node: t.Node, scope</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">const</span> evalFunc = evaluateMap[node.type];</span><br><span class="line">  <span class="keyword">if</span> (!evalFunc) &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="string">`<span class="subst">$&#123;node.loc&#125;</span> <span class="subst">$&#123;node.type&#125;</span> 还未实现`</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> evalFunc(node, scope);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>以上就是evaluate具体做的事。</p><p>其中，<code>evaluateMap</code> 是目前实现的内容集合，我们来看下具体的代码</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br><span class="line">289</span><br><span class="line">290</span><br><span class="line">291</span><br><span class="line">292</span><br><span class="line">293</span><br><span class="line">294</span><br><span class="line">295</span><br><span class="line">296</span><br><span class="line">297</span><br><span class="line">298</span><br><span class="line">299</span><br><span class="line">300</span><br><span class="line">301</span><br><span class="line">302</span><br><span class="line">303</span><br><span class="line">304</span><br><span class="line">305</span><br><span class="line">306</span><br><span class="line">307</span><br><span class="line">308</span><br><span class="line">309</span><br><span class="line">310</span><br><span class="line">311</span><br><span class="line">312</span><br><span class="line">313</span><br><span class="line">314</span><br><span class="line">315</span><br><span class="line">316</span><br><span class="line">317</span><br><span class="line">318</span><br><span class="line">319</span><br><span class="line">320</span><br><span class="line">321</span><br><span class="line">322</span><br><span class="line">323</span><br><span class="line">324</span><br><span class="line">325</span><br><span class="line">326</span><br><span class="line">327</span><br><span class="line">328</span><br><span class="line">329</span><br><span class="line">330</span><br><span class="line">331</span><br><span class="line">332</span><br><span class="line">333</span><br><span class="line">334</span><br><span class="line">335</span><br><span class="line">336</span><br><span class="line">337</span><br><span class="line">338</span><br><span class="line">339</span><br><span class="line">340</span><br><span class="line">341</span><br><span class="line">342</span><br><span class="line">343</span><br><span class="line">344</span><br><span class="line">345</span><br><span class="line">346</span><br><span class="line">347</span><br><span class="line">348</span><br><span class="line">349</span><br><span class="line">350</span><br><span class="line">351</span><br><span class="line">352</span><br><span class="line">353</span><br><span class="line">354</span><br><span class="line">355</span><br><span class="line">356</span><br><span class="line">357</span><br><span class="line">358</span><br><span class="line">359</span><br><span class="line">360</span><br><span class="line">361</span><br><span class="line">362</span><br><span class="line">363</span><br><span class="line">364</span><br><span class="line">365</span><br><span class="line">366</span><br><span class="line">367</span><br><span class="line">368</span><br><span class="line">369</span><br><span class="line">370</span><br><span class="line">371</span><br><span class="line">372</span><br><span class="line">373</span><br><span class="line">374</span><br><span class="line">375</span><br><span class="line">376</span><br><span class="line">377</span><br><span class="line">378</span><br><span class="line">379</span><br><span class="line">380</span><br><span class="line">381</span><br><span class="line">382</span><br><span class="line">383</span><br><span class="line">384</span><br><span class="line">385</span><br><span class="line">386</span><br><span class="line">387</span><br><span class="line">388</span><br><span class="line">389</span><br><span class="line">390</span><br><span class="line">391</span><br><span class="line">392</span><br><span class="line">393</span><br><span class="line">394</span><br><span class="line">395</span><br><span class="line">396</span><br><span class="line">397</span><br><span class="line">398</span><br><span class="line">399</span><br><span class="line">400</span><br><span class="line">401</span><br><span class="line">402</span><br><span class="line">403</span><br><span class="line">404</span><br><span class="line">405</span><br><span class="line">406</span><br><span class="line">407</span><br><span class="line">408</span><br><span class="line">409</span><br><span class="line">410</span><br><span class="line">411</span><br><span class="line">412</span><br><span class="line">413</span><br><span class="line">414</span><br><span class="line">415</span><br><span class="line">416</span><br><span class="line">417</span><br><span class="line">418</span><br><span class="line">419</span><br><span class="line">420</span><br><span class="line">421</span><br><span class="line">422</span><br><span class="line">423</span><br><span class="line">424</span><br><span class="line">425</span><br><span class="line">426</span><br><span class="line">427</span><br><span class="line">428</span><br><span class="line">429</span><br><span class="line">430</span><br><span class="line">431</span><br><span class="line">432</span><br><span class="line">433</span><br><span class="line">434</span><br><span class="line">435</span><br><span class="line">436</span><br><span class="line">437</span><br><span class="line">438</span><br><span class="line">439</span><br><span class="line">440</span><br><span class="line">441</span><br><span class="line">442</span><br><span class="line">443</span><br><span class="line">444</span><br><span class="line">445</span><br><span class="line">446</span><br><span class="line">447</span><br><span class="line">448</span><br><span class="line">449</span><br><span class="line">450</span><br><span class="line">451</span><br><span class="line">452</span><br><span class="line">453</span><br><span class="line">454</span><br><span class="line">455</span><br><span class="line">456</span><br><span class="line">457</span><br><span class="line">458</span><br><span class="line">459</span><br><span class="line">460</span><br><span class="line">461</span><br><span class="line">462</span><br><span class="line">463</span><br><span class="line">464</span><br><span class="line">465</span><br><span class="line">466</span><br><span class="line">467</span><br><span class="line">468</span><br><span class="line">469</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> evaluateMap: EvaluateMap = &#123;</span><br><span class="line">  File(node: t.File, scope) &#123;</span><br><span class="line">    evaluate(node.program, scope);</span><br><span class="line">  &#125;,</span><br><span class="line"></span><br><span class="line">  Program(node: t.Program, scope) &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">const</span> n <span class="keyword">of</span> node.body) &#123;</span><br><span class="line">      evaluate(n, scope);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line"></span><br><span class="line">  Identifier(node: t.Identifier, scope) &#123;</span><br><span class="line">    <span class="keyword">const</span> $<span class="keyword">var</span> = scope.$find(node.name);</span><br><span class="line">    <span class="keyword">if</span> (!$<span class="keyword">var</span>) &#123;</span><br><span class="line">      <span class="keyword">throw</span> <span class="string">`[Error] <span class="subst">$&#123;node.loc&#125;</span>, '<span class="subst">$&#123;node.name&#125;</span>' 未定义`</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> $<span class="keyword">var</span>.$get();</span><br><span class="line">  &#125;,</span><br><span class="line"></span><br><span class="line">  StringLiteral(node: t.StringLiteral, scope) &#123;</span><br><span class="line">    <span class="keyword">return</span> node.value;</span><br><span class="line">  &#125;,</span><br><span class="line"></span><br><span class="line">  NumericLiteral(node: t.NumericLiteral, scope) &#123;</span><br><span class="line">    <span class="keyword">return</span> node.value;</span><br><span class="line">  &#125;,</span><br><span class="line"></span><br><span class="line">  BooleanLiteral(node: t.BooleanLiteral, scope) &#123;</span><br><span class="line">    <span class="keyword">return</span> node.value;</span><br><span class="line">  &#125;,</span><br><span class="line"></span><br><span class="line">  NullLiteral(node: t.NullLiteral, scope) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">  &#125;,</span><br><span class="line"></span><br><span class="line">  BlockStatement(block: t.BlockStatement, scope) &#123;</span><br><span class="line">    <span class="keyword">const</span> blockScope = scope.shared ? scope : <span class="keyword">new</span> Scope(<span class="string">'block'</span>, scope);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">const</span> node <span class="keyword">of</span> block.body) &#123;</span><br><span class="line">      <span class="keyword">const</span> res = evaluate(node, blockScope);</span><br><span class="line">      <span class="keyword">if</span> (res === BREAK || res === CONTINUE || res === RETURN) &#123;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line"></span><br><span class="line">  DebuggerStatement(node: t.DebuggerStatement, scope) &#123;</span><br><span class="line">    <span class="keyword">debugger</span>;</span><br><span class="line">  &#125;,</span><br><span class="line"></span><br><span class="line">  ExpressionStatement(node: t.ExpressionStatement, scope) &#123;</span><br><span class="line">    evaluate(node.expression, scope);</span><br><span class="line">  &#125;,</span><br><span class="line"></span><br><span class="line">  ReturnStatement(node: t.ReturnStatement, scope) &#123;</span><br><span class="line">    RETURN.result = (node.argument ? evaluate(node.argument, scope) : <span class="keyword">void</span> <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">return</span> RETURN;</span><br><span class="line">  &#125;,</span><br><span class="line"></span><br><span class="line">  BreakStatement(node: t.BreakStatement, scope) &#123;</span><br><span class="line">    <span class="keyword">return</span> BREAK;</span><br><span class="line">  &#125;,</span><br><span class="line"></span><br><span class="line">  ContinueStatement(node: t.ContinueStatement, scope) &#123;</span><br><span class="line">    <span class="keyword">return</span> CONTINUE;</span><br><span class="line">  &#125;,</span><br><span class="line"></span><br><span class="line">  IfStatement(node: t.IfStatement, scope) &#123;</span><br><span class="line">    <span class="keyword">if</span> (evaluate(node.test, scope)) &#123;</span><br><span class="line">      <span class="keyword">return</span> evaluate(node.consequent, scope);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (node.alternate) &#123;</span><br><span class="line">      <span class="keyword">const</span> ifScope = <span class="keyword">new</span> Scope(<span class="string">'block'</span>, scope, <span class="literal">true</span>);</span><br><span class="line">      <span class="keyword">return</span> evaluate(node.alternate, ifScope)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line"></span><br><span class="line">  SwitchStatement(node: t.SwitchStatement, scope) &#123;</span><br><span class="line">    <span class="keyword">const</span> discriminant = evaluate(node.discriminant, scope);</span><br><span class="line">    <span class="keyword">const</span> switchScope = <span class="keyword">new</span> Scope(<span class="string">'switch'</span>, scope);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">const</span> ca <span class="keyword">of</span> node.cases)&#123;</span><br><span class="line">      <span class="keyword">if</span> (ca.test === <span class="literal">null</span> || evaluate(ca.test, switchScope) === discriminant) &#123;</span><br><span class="line">        <span class="keyword">const</span> res = evaluate(ca, switchScope);</span><br><span class="line">        <span class="keyword">if</span> (res === BREAK) &#123;</span><br><span class="line">          <span class="keyword">break</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (res === RETURN) &#123;</span><br><span class="line">          <span class="keyword">return</span> res;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line"></span><br><span class="line">  SwitchCase(node: t.SwitchCase, scope) &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">const</span> item <span class="keyword">of</span> node.consequent) &#123;</span><br><span class="line">      <span class="keyword">const</span> res = evaluate(item, scope);</span><br><span class="line">      <span class="keyword">if</span> (res === BREAK || res === RETURN) &#123;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line"></span><br><span class="line">  ThrowStatement(node: t.ThrowStatement, scope) &#123;</span><br><span class="line">    <span class="keyword">throw</span> evaluate(node.argument, scope);</span><br><span class="line">  &#125;,</span><br><span class="line"></span><br><span class="line">  TryStatement(node: t.TryStatement, scope) &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> evaluate(node.block, scope);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (error) &#123;</span><br><span class="line">      <span class="keyword">if</span> (node.handler) &#123;</span><br><span class="line">        <span class="keyword">const</span> catchScope = <span class="keyword">new</span> Scope(<span class="string">'block'</span>, scope, <span class="literal">true</span>);</span><br><span class="line">        catchScope.$<span class="keyword">let</span>((<span class="xml"><span class="tag">&lt;<span class="name">t.Identifier</span>&gt;</span>node.handler.param).name, error);</span></span><br><span class="line"><span class="xml">        return evaluate(node.handler, catchScope);</span></span><br><span class="line"><span class="xml">      &#125; else &#123;</span></span><br><span class="line"><span class="xml">        throw error;</span></span><br><span class="line"><span class="xml">      &#125;</span></span><br><span class="line"><span class="xml">    &#125; finally &#123;</span></span><br><span class="line"><span class="xml">      if (node.finalizer) &#123;</span></span><br><span class="line"><span class="xml">        return evaluate(node.finalizer, scope);</span></span><br><span class="line"><span class="xml">      &#125;</span></span><br><span class="line"><span class="xml">    &#125;</span></span><br><span class="line"><span class="xml">  &#125;,</span></span><br><span class="line"><span class="xml"></span></span><br><span class="line"><span class="xml">  CatchClause(node: t.CatchClause, scope) &#123;</span></span><br><span class="line"><span class="xml">    return evaluate(node.body, scope);</span></span><br><span class="line"><span class="xml">  &#125;,</span></span><br><span class="line"><span class="xml"></span></span><br><span class="line"><span class="xml">  WhileStatement(node: t.WhileStatement, scope) &#123;</span></span><br><span class="line"><span class="xml">    while (evaluate(node.test, scope)) &#123;</span></span><br><span class="line"><span class="xml">      const whileScope = new Scope('loop', scope, true);</span></span><br><span class="line"><span class="xml">      const res = evaluate(node.body, whileScope);</span></span><br><span class="line"><span class="xml">      if (res === CONTINUE) continue;</span></span><br><span class="line"><span class="xml">      if (res === BREAK) break;</span></span><br><span class="line"><span class="xml">      if (res === RETURN) return res;</span></span><br><span class="line"><span class="xml">    &#125;</span></span><br><span class="line"><span class="xml">  &#125;,</span></span><br><span class="line"><span class="xml"></span></span><br><span class="line"><span class="xml">  ForStatement(node: t.ForStatement, scope) &#123;</span></span><br><span class="line"><span class="xml">    for (</span></span><br><span class="line"><span class="xml">      const forScope = new Scope('loop', scope),</span></span><br><span class="line"><span class="xml">      initVal = evaluate(node.init, forScope);</span></span><br><span class="line"><span class="xml">      evaluate(node.test, forScope);</span></span><br><span class="line"><span class="xml">      evaluate(node.update, forScope)</span></span><br><span class="line"><span class="xml">    ) &#123;</span></span><br><span class="line"><span class="xml">      const res = evaluate(node.body, forScope);</span></span><br><span class="line"><span class="xml">      if (res === CONTINUE) continue;</span></span><br><span class="line"><span class="xml">      if (res === BREAK) break;</span></span><br><span class="line"><span class="xml">      if (res === RETURN) return res;</span></span><br><span class="line"><span class="xml">    &#125;</span></span><br><span class="line"><span class="xml">  &#125;,</span></span><br><span class="line"><span class="xml"></span></span><br><span class="line"><span class="xml">  ForInStatement(node: t.ForInStatement, scope) &#123;</span></span><br><span class="line">    const kind = (&lt;t.VariableDeclaration&gt;node.left).kind;</span><br><span class="line">    const decl = (&lt;t.VariableDeclaration&gt;node.left).declarations[0];</span><br><span class="line">    const name = (&lt;t.Identifier&gt;decl.id).name;</span><br><span class="line"></span><br><span class="line">    for (const value in evaluate(node.right, scope)) &#123;</span><br><span class="line">      const forScope = new Scope('loop', scope, true);</span><br><span class="line">      scope.$define(kind, name, value);</span><br><span class="line">      const res = evaluate(node.body, forScope);</span><br><span class="line">      if (res === CONTINUE) continue;</span><br><span class="line">      if (res === BREAK) break;</span><br><span class="line">      if (res === RETURN) return res;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line"></span><br><span class="line">  ForOfStatement(node: t.ForOfStatement, scope) &#123;</span><br><span class="line">    const kind = (&lt;t.VariableDeclaration&gt;node.left).kind;</span><br><span class="line">    const decl = (&lt;t.VariableDeclaration&gt;node.left).declarations[0];</span><br><span class="line">    const name = (&lt;t.Identifier&gt;decl.id).name;</span><br><span class="line"></span><br><span class="line">    for (const value of evaluate(node.right, scope)) &#123;</span><br><span class="line">      const forScope = new Scope('loop', scope, true);</span><br><span class="line">      scope.$define(kind, name, value);</span><br><span class="line">      const res = evaluate(node.body, forScope);</span><br><span class="line">      if (res === CONTINUE) continue;</span><br><span class="line">      if (res === BREAK) break;</span><br><span class="line">      if (res === RETURN) return res;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line"></span><br><span class="line">  FunctionDeclaration(node: t.FunctionDeclaration, scope) &#123;</span><br><span class="line">    const func = evaluateMap.FunctionExpression(node, scope);</span><br><span class="line">    scope.$var(node.id.name, func);</span><br><span class="line">  &#125;,</span><br><span class="line"></span><br><span class="line">  VariableDeclaration(node: t.VariableDeclaration, scope) &#123;</span><br><span class="line">    const &#123; kind, declarations &#125; = node;</span><br><span class="line">    for (const decl of declarations) &#123;</span><br><span class="line">      const varName = (&lt;t.Identifier&gt;decl.id).name;</span><br><span class="line">      const value = decl.init ? evaluate(decl.init, scope) : void 0;</span><br><span class="line">      if (!scope.$define(kind, varName, value)) &#123;</span><br><span class="line">        throw `[Error] $&#123;name&#125; 重复定义`</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line"></span><br><span class="line">  ThisExpression(node: t.ThisExpression, scope) &#123;</span><br><span class="line">    const _this = scope.$find('this');</span><br><span class="line">    return _this ? _this.$get() : null;</span><br><span class="line">  &#125;,</span><br><span class="line"></span><br><span class="line">  ArrayExpression(node: t.ArrayExpression, scope) &#123;</span><br><span class="line">    return node.elements.map(item =&gt; evaluate(item, scope));</span><br><span class="line">  &#125;,</span><br><span class="line"></span><br><span class="line">  ObjectExpression(node: t.ObjectExpression, scope) &#123;</span><br><span class="line">    let res = Object.create(null);</span><br><span class="line">    node.properties.forEach((prop) =&gt; &#123;</span><br><span class="line">      let key;</span><br><span class="line">      let value;</span><br><span class="line">      if(prop.type === 'ObjectProperty')&#123;</span><br><span class="line">        key = prop.key.name;</span><br><span class="line">        value = evaluate(prop.value, scope);</span><br><span class="line">        res[key] = value;</span><br><span class="line">      &#125;else if (prop.type === 'ObjectMethod')&#123;</span><br><span class="line">        const kind = prop.kind;</span><br><span class="line">        key = prop.key.name;</span><br><span class="line">        value = evaluate(prop.body, scope);</span><br><span class="line">        if(kind === 'method') &#123;</span><br><span class="line">          res[key] = value;</span><br><span class="line">        &#125;else if(kind === 'get') &#123;</span><br><span class="line">          Object.defineProperty(res, key, &#123; get: value &#125;);</span><br><span class="line">        &#125;else if(kind === 'set') &#123;</span><br><span class="line">          Object.defineProperty(res, key, &#123; set: value &#125;);</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;else if(prop.type === 'SpreadElement')&#123;</span><br><span class="line">        const arg = evaluate(prop.argument, scope);</span><br><span class="line">        res = Object.assign(res, arg);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">    return res;</span><br><span class="line">  &#125;,</span><br><span class="line"></span><br><span class="line">  FunctionExpression(node: t.FunctionExpression, scope) &#123;</span><br><span class="line">    return function (...args: any) &#123;</span><br><span class="line">      const funcScope = new Scope('function', scope, true);</span><br><span class="line">      node.params.forEach((param: t.Identifier, idx) =&gt; &#123;</span><br><span class="line">        const &#123; name: paramName &#125; = param;</span><br><span class="line">        funcScope.$let(paramName, args[idx]);</span><br><span class="line">      &#125;);</span><br><span class="line">      funcScope.$const('this', this);</span><br><span class="line">      funcScope.$const('arguments', arguments);</span><br><span class="line">      const res = evaluate(node.body, funcScope);</span><br><span class="line">      if (res === RETURN) &#123;</span><br><span class="line">        return res.result;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line"></span><br><span class="line">  ArrowFunctionExpression(node: t.ArrowFunctionExpression, scope) &#123;</span><br><span class="line">    return (...args) =&gt; &#123;</span><br><span class="line">      const funcScope = new Scope('function', scope, true);</span><br><span class="line">      node.params.forEach((param: t.Identifier, idx) =&gt; &#123;</span><br><span class="line">        const &#123; name: paramName &#125; = param;</span><br><span class="line">        funcScope.$let(paramName, args[idx]);</span><br><span class="line">      &#125;);</span><br><span class="line">      const _this = funcScope.$find('this');</span><br><span class="line">      funcScope.$const('this', _this ? _this.$get() : null);</span><br><span class="line">      funcScope.$const('arguments', args);</span><br><span class="line">      const res = evaluate(node.body, funcScope);</span><br><span class="line">      if (res === RETURN) &#123;</span><br><span class="line">        return res.result;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line"></span><br><span class="line">  UnaryExpression(node: t.UnaryExpression, scope) &#123;</span><br><span class="line">    const expressionMap = &#123;</span><br><span class="line">      '~': () =&gt; ~evaluate(node.argument, scope),</span><br><span class="line">      '+': () =&gt; +evaluate(node.argument, scope),</span><br><span class="line">      '-': () =&gt; -evaluate(node.argument, scope),</span><br><span class="line">      '!': () =&gt; !evaluate(node.argument, scope),</span><br><span class="line">      'void': () =&gt; void evaluate(node.argument, scope),</span><br><span class="line">      'typeof': () =&gt; &#123;</span><br><span class="line">        if (node.argument.type === 'Identifier') &#123;</span><br><span class="line">          const $var = scope.$find(node.argument.name);</span><br><span class="line">          const value = $var ? $var.$get() : void 0;</span><br><span class="line">          return typeof value;</span><br><span class="line">        &#125;</span><br><span class="line">        return typeof evaluate(node.argument, scope);</span><br><span class="line">      &#125;,</span><br><span class="line">      'delete': () =&gt; &#123;</span><br><span class="line">        if (node.argument.type === 'MemberExpression') &#123;</span><br><span class="line">          const &#123; object, property, computed &#125; = node.argument;</span><br><span class="line">          const obj = evaluate(object, scope);</span><br><span class="line">          let prop;</span><br><span class="line">          if (computed) &#123;</span><br><span class="line">            prop = evaluate(property, scope);</span><br><span class="line">          &#125; else &#123;</span><br><span class="line">            prop = property.name;</span><br><span class="line">          &#125;</span><br><span class="line">          return delete obj[prop];</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">          throw '[Error] 出现错误'</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;,</span><br><span class="line">    &#125;</span><br><span class="line">    return expressionMap[node.operator]();</span><br><span class="line">  &#125;,</span><br><span class="line"></span><br><span class="line">  UpdateExpression(node: t.UpdateExpression, scope) &#123;</span><br><span class="line">    const &#123; prefix, argument, operator &#125; = node;</span><br><span class="line">    let $var: IVariable;</span><br><span class="line">    if (argument.type === 'Identifier') &#123;</span><br><span class="line">      $var = scope.$find(argument.name);</span><br><span class="line">      if (!$var) throw `$&#123;argument.name&#125; 未定义`;</span><br><span class="line">    &#125; else if (argument.type === 'MemberExpression') &#123;</span><br><span class="line">      const obj = evaluate(argument.object, scope);</span><br><span class="line">      let prop;</span><br><span class="line">      if (argument.computed) &#123;</span><br><span class="line">        prop = evaluate(argument.property, scope);</span><br><span class="line">      &#125; else &#123;</span><br><span class="line">        prop = argument.property.name;</span><br><span class="line">      &#125;</span><br><span class="line">      $var = &#123;</span><br><span class="line">        $set(value: any) &#123;</span><br><span class="line">          obj[prop] = value;</span><br><span class="line">          return true;</span><br><span class="line">        &#125;,</span><br><span class="line">        $get() &#123;</span><br><span class="line">          return obj[prop];</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">      throw '[Error] 出现错误'</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    const expressionMap = &#123;</span><br><span class="line">      '++': v =&gt; &#123;</span><br><span class="line">        $var.$set(v + 1);</span><br><span class="line">        return prefix ? ++v : v++</span><br><span class="line">      &#125;,</span><br><span class="line">      '--': v =&gt; &#123;</span><br><span class="line">        $var.$set(v - 1);</span><br><span class="line">        return prefix ? --v : v--</span><br><span class="line">      &#125;,</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    return expressionMap[operator]($var.$get());</span><br><span class="line">  &#125;,</span><br><span class="line"></span><br><span class="line">  BinaryExpression(node: t.BinaryExpression, scope) &#123;</span><br><span class="line">    const &#123; left, operator, right &#125; = node;</span><br><span class="line">    const expressionMap = &#123;</span><br><span class="line">      '==': (a, b) =&gt; a == b,</span><br><span class="line">      '===': (a, b) =&gt; a === b,</span><br><span class="line">      '&gt;': (a, b) =&gt; a &gt; b,</span><br><span class="line">      '&lt;': (a, b) =&gt; a &lt; b,</span><br><span class="line">      '!=': (a, b) =&gt; a != b,</span><br><span class="line">      '!==': (a, b) =&gt; a !== b,</span><br><span class="line">      '&gt;=': (a, b) =&gt; a &gt;= b,</span><br><span class="line">      '&lt;=': (a, b) =&gt; a &lt;= b,</span><br><span class="line">      '&lt;&lt;': (a, b) =&gt; a &lt;&lt; b,</span><br><span class="line">      '&gt;&gt;': (a, b) =&gt; a &gt;&gt; b,</span><br><span class="line">      '&gt;&gt;&gt;': (a, b) =&gt; a &gt;&gt;&gt; b,</span><br><span class="line">      '+': (a, b) =&gt; a + b,</span><br><span class="line">      '-': (a, b) =&gt; a - b,</span><br><span class="line">      '*': (a, b) =&gt; a * b,</span><br><span class="line">      '/': (a, b) =&gt; a / b,</span><br><span class="line">      '&amp;': (a, b) =&gt; a &amp; b,</span><br><span class="line">      '%': (a, b) =&gt; a % b,</span><br><span class="line">      '|': (a, b) =&gt; a | b,</span><br><span class="line">      '^': (a, b) =&gt; a ^ b,</span><br><span class="line">      'in': (a, b) =&gt; a in b,</span><br><span class="line">      'instanceof': (a, b) =&gt; a instanceof b,</span><br><span class="line">    &#125;</span><br><span class="line">    return expressionMap[operator](evaluate(left, scope), evaluate(right, scope));</span><br><span class="line">  &#125;,</span><br><span class="line"></span><br><span class="line">  AssignmentExpression(node: t.AssignmentExpression, scope) &#123;</span><br><span class="line">    const &#123; left, right, operator &#125; = node;</span><br><span class="line">    let $var: IVariable;</span><br><span class="line"></span><br><span class="line">    if (left.type === 'Identifier') &#123;</span><br><span class="line">      $var = scope.$find(left.name);</span><br><span class="line">      if(!$var) throw `$&#123;left.name&#125; 未定义`;</span><br><span class="line">    &#125; else if (left.type === 'MemberExpression') &#123;</span><br><span class="line">      const obj = evaluate(left.object, scope);</span><br><span class="line">      let prop;</span><br><span class="line">      if (left.computed) &#123;</span><br><span class="line">        prop = evaluate(left.property, scope);</span><br><span class="line">      &#125; else &#123;</span><br><span class="line">        prop = left.property.name;</span><br><span class="line">      &#125;</span><br><span class="line">      $var = &#123;</span><br><span class="line">        $set(value: any) &#123;</span><br><span class="line">          obj[prop] = value;</span><br><span class="line">          return true;</span><br><span class="line">        &#125;,</span><br><span class="line">        $get() &#123;</span><br><span class="line">          return obj[prop];</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">      throw '[Error] 出现错误'</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    const expressionMap = &#123;</span><br><span class="line">      '=': v =&gt; &#123; $var.$set(v); return $var.$get() &#125;,</span><br><span class="line">      '+=': v =&gt; &#123; $var.$set($var.$get() + v); return $var.$get() &#125;,</span><br><span class="line">      '-=': v =&gt; &#123; $var.$set($var.$get() - v); return $var.$get() &#125;,</span><br><span class="line">      '*=': v =&gt; &#123; $var.$set($var.$get() * v); return $var.$get() &#125;,</span><br><span class="line">      '/=': v =&gt; &#123; $var.$set($var.$get() / v); return $var.$get() &#125;,</span><br><span class="line">      '%=': v =&gt; &#123; $var.$set($var.$get() % v); return $var.$get() &#125;,</span><br><span class="line">      '&lt;&lt;=': v =&gt; &#123; $var.$set($var.$get() &lt;&lt; v); return $var.$get() &#125;,</span><br><span class="line">      '&gt;&gt;=': v =&gt; &#123; $var.$set($var.$get() &gt;&gt; v); return $var.$get() &#125;,</span><br><span class="line">      '&gt;&gt;&gt;=': v =&gt; &#123; $var.$set($var.$get() &gt;&gt;&gt; v); return $var.$get() &#125;,</span><br><span class="line">      '|=': v =&gt; &#123; $var.$set($var.$get() | v); return $var.$get() &#125;,</span><br><span class="line">      '&amp;=': v =&gt; &#123; $var.$set($var.$get() &amp; v); return $var.$get() &#125;,</span><br><span class="line">      '^=': v =&gt; &#123; $var.$set($var.$get() ^ v); return $var.$get() &#125;,</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    return expressionMap[operator](evaluate(right, scope));</span><br><span class="line">  &#125;,</span><br><span class="line"></span><br><span class="line">  LogicalExpression(node: t.LogicalExpression, scope) &#123;</span><br><span class="line">    const &#123; left, right, operator &#125; = node;</span><br><span class="line">    const expressionMap = &#123;</span><br><span class="line">      '&amp;&amp;': () =&gt; evaluate(left, scope) &amp;&amp; evaluate(right, scope),</span><br><span class="line">      '||': () =&gt; evaluate(left, scope) || evaluate(right, scope),</span><br><span class="line">    &#125;</span><br><span class="line">    return expressionMap[operator]();</span><br><span class="line">  &#125;,</span><br><span class="line"></span><br><span class="line">  MemberExpression(node: t.MemberExpression, scope) &#123;</span><br><span class="line">    const &#123; object, property, computed &#125; = node;</span><br><span class="line">    const obj = evaluate(object, scope);</span><br><span class="line">    let prop;</span><br><span class="line">    if (computed) &#123;</span><br><span class="line">      prop = evaluate(property, scope);</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">      prop = property.name;</span><br><span class="line">    &#125;</span><br><span class="line">    return obj[prop];</span><br><span class="line">  &#125;,</span><br><span class="line"></span><br><span class="line">  ConditionalExpression(node: t.ConditionalExpression, scope) &#123;</span><br><span class="line">    const &#123; test, consequent, alternate &#125; = node;</span><br><span class="line">    return evaluate(test, scope) ? evaluate(consequent, scope) : evaluate(alternate, scope);</span><br><span class="line">  &#125;,</span><br><span class="line"></span><br><span class="line">  CallExpression(node: t.CallExpression, scope) &#123;</span><br><span class="line">    const func = evaluate(node.callee, scope);</span><br><span class="line">    const args = node.arguments.map(arg =&gt; evaluate(arg, scope));</span><br><span class="line">    let _this;</span><br><span class="line">    if (node.callee.type === 'MemberExpression') &#123;</span><br><span class="line">      _this = evaluate(node.callee.object, scope);</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">      const $var = scope.$find('this');</span><br><span class="line">      _this = $var ? $var.$get() : null;</span><br><span class="line">    &#125;</span><br><span class="line">    return func.apply(_this, args);</span><br><span class="line">  &#125;,</span><br><span class="line"></span><br><span class="line">  NewExpression(node: t.NewExpression, scope) &#123;</span><br><span class="line">    const func = evaluate(node.callee, scope);</span><br><span class="line">    const args = node.arguments.map(arg =&gt; evaluate(arg, scope));</span><br><span class="line">    return new (func.bind(func, ...args));</span><br><span class="line">  &#125;,</span><br><span class="line"></span><br><span class="line">  SequenceExpression(node: t.SequenceExpression, scope) &#123;</span><br><span class="line">    let last;</span><br><span class="line">    node.expressions.forEach(expr =&gt; &#123;</span><br><span class="line">      last = evaluate(expr, scope);</span><br><span class="line">    &#125;)</span><br><span class="line">    return last;</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>以上，<code>evaluate-apply</code> 这个过程就完了。</p><h2 id="scope"><a href="#scope" class="headerlink" title="scope"></a>scope</h2><p>我们再来看下 <code>scope</code> 该如何实现。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Scope</span> <span class="title">implements</span> <span class="title">IScope</span> </span>&#123;</span><br><span class="line">  public readonly variables: EmptyObj = <span class="built_in">Object</span>.create(<span class="literal">null</span>);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">constructor</span>(</span><br><span class="line">    private readonly scopeType: ScopeType,</span><br><span class="line">    private parent: Scope = null,</span><br><span class="line">    public readonly shared = false,</span><br><span class="line">  ) &#123; &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们构造一个类来模拟 <code>scope</code>。可以看到，<code>Scope</code> 类包含了以下4个属性：</p><ul><li>variables：当前环境下存在的变量</li><li>scopeType：当前环境的type</li><li>parent：当前环境的父环境</li><li>shared：有些时候不需要重复构造子环境，故用此标识</li></ul><p><strong>接下来我们看下该如何在环境中声明变量</strong></p><p>首先构造一个类来模拟变量</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Variable</span> <span class="title">implements</span> <span class="title">IVariable</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>(</span><br><span class="line">    private kind: Kind,</span><br><span class="line">    private value: any</span><br><span class="line">  )&#123; &#125;</span><br><span class="line"></span><br><span class="line">  $get() &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.value</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  $set(value: any) &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span>.kind === <span class="string">'const'</span>) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">this</span>.value = value;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个类中有两个属性和两个方法</p><ul><li><code>kind</code> 用于标识该变量是通过 <code>var</code>、<code>let</code> 还是 <code>const</code> 声明</li><li><code>value</code> 表示该变量的值</li><li><code>$get</code> 和 <code>$set</code> 分别用于获取和设置该变量的值</li></ul><p>有了 <code>Variable</code> 类之后，我们就可以编写 <code>Scope</code> 类中的声明变量的方法了。</p><p><code>let</code> 和 <code>const</code> 的声明方式基本一样</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">$<span class="keyword">const</span>(varName: string, <span class="attr">value</span>: any) &#123;</span><br><span class="line">  <span class="keyword">const</span> variable = <span class="keyword">this</span>.variables[varName];</span><br><span class="line">  <span class="keyword">if</span> (!variable) &#123;</span><br><span class="line">    <span class="keyword">this</span>.variables[varName] = <span class="keyword">new</span> Variable(<span class="string">'const'</span>, value);</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">$<span class="keyword">let</span>(varName: string, <span class="attr">value</span>: any) &#123;</span><br><span class="line">  <span class="keyword">const</span> variable = <span class="keyword">this</span>.variables[varName];</span><br><span class="line">  <span class="keyword">if</span> (!variable) &#123;</span><br><span class="line">    <span class="keyword">this</span>.variables[varName] = <span class="keyword">new</span> Variable(<span class="string">'let'</span>, value);</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>var</code> 的声明方式稍微有一点差异，因为js中，除了在 <code>function</code> 中，用<code>var</code> 声明的变量是会被声明到父级作用域的（js的历史遗留坑）。我们看下代码</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">$<span class="keyword">var</span>(varName: string, <span class="attr">value</span>: any) &#123;</span><br><span class="line">  <span class="keyword">let</span> scope: Scope = <span class="keyword">this</span>;</span><br><span class="line">  <span class="keyword">while</span> (!!scope.parent &amp;&amp; scope.scopeType !== <span class="string">'function'</span>) &#123;</span><br><span class="line">    scope = scope.parent;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">const</span> variable = scope.variables[varName];</span><br><span class="line">  <span class="keyword">if</span> (!variable) &#123;</span><br><span class="line">    scope.variables[varName] = <span class="keyword">new</span> Variable(<span class="string">'var'</span>, value);</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    scope.variables[varName] = variable.$set(value);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>除了声明，我们还需要一个寻找变量的方法，该方法会从当前环境开始，一直沿着作用域链，找到最外层的环境为止。因此，代码实现如下</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">$find(varName: string): <span class="literal">null</span> | IVariable &#123;</span><br><span class="line">  <span class="keyword">if</span> (<span class="built_in">Reflect</span>.has(<span class="keyword">this</span>.variables, varName)) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">Reflect</span>.get(<span class="keyword">this</span>.variables, varName);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">this</span>.parent) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.parent.$find(varName);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>以上，一个基本的javascript元循环求值器就完成了</p><h2 id="最后"><a href="#最后" class="headerlink" title="最后"></a>最后</h2><p>大家可以在 <a href="https://codesandbox.io/s/tender-kirch-ygppj?file=/src/App.js" target="_blank" rel="noopener">codesandbox</a> 在线体验一下。</p><p>完整的项目地址是：<a href="https://github.com/1eeing/Nvwa.js" target="_blank" rel="noopener">nvwajs</a>，欢迎鞭策，欢迎star。</p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul><li>《SICP》</li><li><a href="https://zhuanlan.zhihu.com/p/34191831" target="_blank" rel="noopener">微信小程序也要强行热更代码，鹅厂不服你来肛我呀</a></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;http://dpic.tiankong.com/23/zf/QJ6129071387.jpg?x-oss-process=style/shows&quot; alt=&quot;http://dpic.tiankong.com/23/zf/QJ6129071387.jpg?x-oss-process=style/shows&quot;&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;在上一篇文章中，我们通过AST完成了微信小程序组件的多端编译，在这篇文章中，让我们更深入一点，通过AST完成一个javascript元循环求值器&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="个人原创" scheme="http://1eeing.github.io/categories/%E4%B8%AA%E4%BA%BA%E5%8E%9F%E5%88%9B/"/>
    
    
      <category term="AST" scheme="http://1eeing.github.io/tags/AST/"/>
    
      <category term="编译原理" scheme="http://1eeing.github.io/tags/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86/"/>
    
  </entry>
  
  <entry>
    <title>通过一个需求揭秘多端编译</title>
    <link href="http://1eeing.github.io/2020/03/28/%E9%80%9A%E8%BF%87%E4%B8%80%E4%B8%AA%E9%9C%80%E6%B1%82%E6%8F%AD%E7%A7%98%E5%A4%9A%E7%AB%AF%E7%BC%96%E8%AF%91/"/>
    <id>http://1eeing.github.io/2020/03/28/通过一个需求揭秘多端编译/</id>
    <published>2020-03-28T09:24:19.590Z</published>
    <updated>2020-03-28T09:30:08.232Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://ss2.bdstatic.com/70cFvnSh_Q1YnxGkpoWK1HF6hhy/it/u=3710369427,300738485&amp;fm=26&amp;gp=0.jpg" alt="https://ss2.bdstatic.com/70cFvnSh_Q1YnxGkpoWK1HF6hhy/it/u=3710369427,300738485&amp;fm=26&amp;gp=0.jpg"></p><blockquote><p>过年在家办公期间，接到了一个需求，需要将目前的 <code>微信小程序自定义组件</code> 扩展到 <code>支付宝小程序</code>  平台。关于需求的背景和历史这边就暂不多说了，就从上面已说明的内容来看待这个需求吧。<br>接到需求的第一时间，笔者就思考，这不就是多端编译吗？话不多说，那就开搞吧。</p></blockquote><a id="more"></a><h2 id="背景介绍"><a href="#背景介绍" class="headerlink" title="背景介绍"></a>背景介绍</h2><p>由于笔者的项目是一个单纯的微信小程序自定义组件，打包工具是rollup，所以，笔者的技术方案是编写一个rollup插件，来支持多端编译。关于rollup和rollup插件的写法本次不作过多介绍，有兴趣的可以看它的<a href="https://rollupjs.org/guide/en/" target="_blank" rel="noopener">官方文档</a>，这边只是介绍一下核心的多端编译流程。</p><h2 id="流程介绍"><a href="#流程介绍" class="headerlink" title="流程介绍"></a>流程介绍</h2><p>微信小程序组件包含 <code>*.json</code> 、 <code>*.js</code> 、 <code>*.wxml</code> 、 <code>*.wxss</code> 这4个文件，要转换成支付宝小程序，其中json文件和wxss文件比较简单，前者原封不动，后者改一下后缀名就好了，主要要修改js和wxml两个文件。</p><p>大致流程基本就是如下</p><ol><li>差异整理</li><li>将代码转成AST树</li><li>替换树上的节点</li><li>根据新的AST树生成代码</li></ol><h3 id="acorn"><a href="#acorn" class="headerlink" title="acorn"></a>acorn</h3><p>对于js文件，要实现这些功能的话，业界已经有一些出色的工具了。笔者选择了<a href="https://github.com/babel/babel" target="_blank" rel="noopener">babel</a>，babel内置acorn作为javascript解释器，生成符合estree标准的AST树（可以在<a href="https://astexplorer.net/" target="_blank" rel="noopener">https://astexplorer.net/</a>中查看效果）。其次babel的封装很漂亮，除了搭配webpack完成日常的构建工作外，它还提供了 <code>@babel/parser</code>， <code>@babel/generator</code>， <code>@babel/traverse</code>，<code>@babel/types</code> 等优秀的工具包，每个工具包都是单一职责，职责很明确，帮助实现以上的流程（其实rollup内置了acorn实例，不过babel会更好用一些）。<br>其中 <code>@babel/parser</code> 可以将js代码解释为AST树，<code>@babel/generator</code> 将根据AST树生成js代码，<code>@babel/traverse</code> 支持高效地操作AST树的节点，<code>@babel/types</code> 则提供一些判断函数，帮助开发者快速定位节点。</p><p>看一个简单的示例<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">sayHello</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'hello'</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">sayHello();</span><br></pre></td></tr></table></figure></p><p>对于以上这段代码，通过acorn转换后，得出的AST树如下<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="string">"type"</span>: <span class="string">"Program"</span>,</span><br><span class="line">  <span class="string">"start"</span>: <span class="number">0</span>,</span><br><span class="line">  <span class="string">"end"</span>: <span class="number">58</span>,</span><br><span class="line">  <span class="string">"body"</span>: [</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="string">"type"</span>: <span class="string">"FunctionDeclaration"</span>,</span><br><span class="line">      <span class="string">"start"</span>: <span class="number">0</span>,</span><br><span class="line">      <span class="string">"end"</span>: <span class="number">45</span>,</span><br><span class="line">      <span class="string">"id"</span>: &#123;</span><br><span class="line">        <span class="string">"type"</span>: <span class="string">"Identifier"</span>,</span><br><span class="line">        <span class="string">"start"</span>: <span class="number">9</span>,</span><br><span class="line">        <span class="string">"end"</span>: <span class="number">17</span>,</span><br><span class="line">        <span class="string">"name"</span>: <span class="string">"sayHello"</span></span><br><span class="line">      &#125;,</span><br><span class="line">      <span class="string">"expression"</span>: <span class="literal">false</span>,</span><br><span class="line">      <span class="string">"generator"</span>: <span class="literal">false</span>,</span><br><span class="line">      <span class="string">"async"</span>: <span class="literal">false</span>,</span><br><span class="line">      <span class="string">"params"</span>: [],</span><br><span class="line">      <span class="string">"body"</span>: &#123;</span><br><span class="line">        <span class="string">"type"</span>: <span class="string">"BlockStatement"</span>,</span><br><span class="line">        <span class="string">"start"</span>: <span class="number">20</span>,</span><br><span class="line">        <span class="string">"end"</span>: <span class="number">45</span>,</span><br><span class="line">        <span class="string">"body"</span>: [</span><br><span class="line">          &#123;</span><br><span class="line">            <span class="string">"type"</span>: <span class="string">"ExpressionStatement"</span>,</span><br><span class="line">            <span class="string">"start"</span>: <span class="number">23</span>,</span><br><span class="line">            <span class="string">"end"</span>: <span class="number">43</span>,</span><br><span class="line">            <span class="string">"expression"</span>: &#123;</span><br><span class="line">              <span class="string">"type"</span>: <span class="string">"CallExpression"</span>,</span><br><span class="line">              <span class="string">"start"</span>: <span class="number">23</span>,</span><br><span class="line">              <span class="string">"end"</span>: <span class="number">43</span>,</span><br><span class="line">              <span class="string">"callee"</span>: &#123;</span><br><span class="line">                <span class="string">"type"</span>: <span class="string">"MemberExpression"</span>,</span><br><span class="line">                <span class="string">"start"</span>: <span class="number">23</span>,</span><br><span class="line">                <span class="string">"end"</span>: <span class="number">34</span>,</span><br><span class="line">                <span class="string">"object"</span>: &#123;</span><br><span class="line">                  <span class="string">"type"</span>: <span class="string">"Identifier"</span>,</span><br><span class="line">                  <span class="string">"start"</span>: <span class="number">23</span>,</span><br><span class="line">                  <span class="string">"end"</span>: <span class="number">30</span>,</span><br><span class="line">                  <span class="string">"name"</span>: <span class="string">"console"</span></span><br><span class="line">                &#125;,</span><br><span class="line">                <span class="string">"property"</span>: &#123;</span><br><span class="line">                  <span class="string">"type"</span>: <span class="string">"Identifier"</span>,</span><br><span class="line">                  <span class="string">"start"</span>: <span class="number">31</span>,</span><br><span class="line">                  <span class="string">"end"</span>: <span class="number">34</span>,</span><br><span class="line">                  <span class="string">"name"</span>: <span class="string">"log"</span></span><br><span class="line">                &#125;,</span><br><span class="line">                <span class="string">"computed"</span>: <span class="literal">false</span></span><br><span class="line">              &#125;,</span><br><span class="line">              <span class="string">"arguments"</span>: [</span><br><span class="line">                &#123;</span><br><span class="line">                  <span class="string">"type"</span>: <span class="string">"Literal"</span>,</span><br><span class="line">                  <span class="string">"start"</span>: <span class="number">35</span>,</span><br><span class="line">                  <span class="string">"end"</span>: <span class="number">42</span>,</span><br><span class="line">                  <span class="string">"value"</span>: <span class="string">"hello"</span>,</span><br><span class="line">                  <span class="string">"raw"</span>: <span class="string">"'hello'"</span></span><br><span class="line">                &#125;</span><br><span class="line">              ]</span><br><span class="line">            &#125;</span><br><span class="line">          &#125;</span><br><span class="line">        ]</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="string">"type"</span>: <span class="string">"ExpressionStatement"</span>,</span><br><span class="line">      <span class="string">"start"</span>: <span class="number">47</span>,</span><br><span class="line">      <span class="string">"end"</span>: <span class="number">58</span>,</span><br><span class="line">      <span class="string">"expression"</span>: &#123;</span><br><span class="line">        <span class="string">"type"</span>: <span class="string">"CallExpression"</span>,</span><br><span class="line">        <span class="string">"start"</span>: <span class="number">47</span>,</span><br><span class="line">        <span class="string">"end"</span>: <span class="number">57</span>,</span><br><span class="line">        <span class="string">"callee"</span>: &#123;</span><br><span class="line">          <span class="string">"type"</span>: <span class="string">"Identifier"</span>,</span><br><span class="line">          <span class="string">"start"</span>: <span class="number">47</span>,</span><br><span class="line">          <span class="string">"end"</span>: <span class="number">55</span>,</span><br><span class="line">          <span class="string">"name"</span>: <span class="string">"sayHello"</span></span><br><span class="line">        &#125;,</span><br><span class="line">        <span class="string">"arguments"</span>: []</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  ],</span><br><span class="line">  <span class="string">"sourceType"</span>: <span class="string">"module"</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>对于这段js代码，如果要替换它的方法名为 <code>sayHi</code>、打印出的 <code>hello</code> 替换为 <code>Hi</code>，通过babel，只需要这样做就可以了。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; parse &#125; <span class="keyword">from</span> <span class="string">"@babel/parser"</span>;</span><br><span class="line"><span class="keyword">import</span> traverse <span class="keyword">from</span> <span class="string">"@babel/traverse"</span>;</span><br><span class="line"><span class="keyword">import</span> generate <span class="keyword">from</span> <span class="string">"@babel/generator"</span>;</span><br><span class="line"><span class="keyword">import</span> * <span class="keyword">as</span> t <span class="keyword">from</span> <span class="string">"@babel/types"</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> code = <span class="string">`</span></span><br><span class="line"><span class="string">function sayHello() &#123;</span></span><br><span class="line"><span class="string">  console.log('hello')</span></span><br><span class="line"><span class="string">&#125;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">sayHello();</span></span><br><span class="line"><span class="string">`</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> transform = <span class="function"><span class="params">code</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">const</span> ast = parse(code);</span><br><span class="line">  traverse(ast, &#123;</span><br><span class="line">    enter(path) &#123;</span><br><span class="line">      <span class="keyword">if</span> (t.isIdentifier(path.node, &#123; <span class="attr">name</span>: <span class="string">"sayHello"</span> &#125;)) &#123;</span><br><span class="line">        path.node.name = <span class="string">"sayHi"</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">if</span> (t.isLiteral(path.node, &#123; <span class="attr">value</span>: <span class="string">"hello"</span> &#125;)) &#123;</span><br><span class="line">        path.node.value = <span class="string">"Hi"</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;);</span><br><span class="line">  <span class="keyword">const</span> output = generate(ast, &#123;&#125;, code);</span><br><span class="line">  <span class="keyword">return</span> output;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(transform(code).code);</span><br></pre></td></tr></table></figure><p>也可以在<a href="https://codesandbox.io/embed/hungry-bird-pgob8?fontsize=14&amp;hidenavigation=1&amp;theme=dark" target="_blank" rel="noopener">codeSandbox</a>中查看效果。</p><p>关于包的其它使用，可以查看<a href="https://github.com/lixiang/babel-handbook-cn/blob/master/plugin-handbook.md" target="_blank" rel="noopener">官方手册</a>。</p><h3 id="himalaya"><a href="#himalaya" class="headerlink" title="himalaya"></a>himalaya</h3><p>对于wxml文件，笔者选择了<a href="https://github.com/andrejewski/himalaya" target="_blank" rel="noopener">himalaya-wxml</a>，它提供了 <code>parse</code> 和 <code>stringify</code> 两个方法，前者将wxml解释成AST树，后者反之（可以在<a href="https://jew.ski/himalaya/" target="_blank" rel="noopener">https://jew.ski/himalaya/</a>中查看效果）。通过 <code>parse</code> 将wxml代码转换成AST树之后，接下去只需要手动递归遍历AST树去替换节点，再将其转换回wxml代码就可以完成工作了。</p><p>同样，看一个简单的示例<br><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">'main'</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">span</span>&gt;</span>hello world<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure></p><p>对于以上html代码，通过 <code>himalaya</code> 转换后，生成的AST树如下<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">[</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="string">"type"</span>: <span class="string">"element"</span>,</span><br><span class="line">    <span class="string">"tagName"</span>: <span class="string">"div"</span>,</span><br><span class="line">    <span class="string">"attributes"</span>: [],</span><br><span class="line">    <span class="string">"children"</span>: [</span><br><span class="line">      &#123;</span><br><span class="line">        <span class="string">"type"</span>: <span class="string">"text"</span>,</span><br><span class="line">        <span class="string">"content"</span>: <span class="string">"\n  "</span></span><br><span class="line">      &#125;,</span><br><span class="line">      &#123;</span><br><span class="line">        <span class="string">"type"</span>: <span class="string">"element"</span>,</span><br><span class="line">        <span class="string">"tagName"</span>: <span class="string">"span"</span>,</span><br><span class="line">        <span class="string">"attributes"</span>: [],</span><br><span class="line">        <span class="string">"children"</span>: [</span><br><span class="line">          &#123;</span><br><span class="line">            <span class="string">"type"</span>: <span class="string">"text"</span>,</span><br><span class="line">            <span class="string">"content"</span>: <span class="string">"hello world"</span></span><br><span class="line">          &#125;</span><br><span class="line">        ]</span><br><span class="line">      &#125;,</span><br><span class="line">      &#123;</span><br><span class="line">        <span class="string">"type"</span>: <span class="string">"text"</span>,</span><br><span class="line">        <span class="string">"content"</span>: <span class="string">"\n"</span></span><br><span class="line">      &#125;</span><br><span class="line">    ]</span><br><span class="line">  &#125;</span><br><span class="line">]</span><br></pre></td></tr></table></figure></p><p>对于这段代码html代码，如果要替换它外层 <code>div</code> 的 <code>id</code> 为 <code>container</code>，只需要这样做就可以了。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; parse, stringify &#125; <span class="keyword">from</span> <span class="string">"himalaya"</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> code = <span class="string">`</span></span><br><span class="line"><span class="string">&lt;div id='main'&gt;</span></span><br><span class="line"><span class="string">  &lt;span&gt;hello world&lt;/span&gt;</span></span><br><span class="line"><span class="string">&lt;/div&gt;</span></span><br><span class="line"><span class="string">`</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> traverse = <span class="function"><span class="params">ast</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> ast.map(<span class="function"><span class="params">item</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (item.type === <span class="string">"element"</span> &amp;&amp; item.attributes) &#123;</span><br><span class="line">      <span class="keyword">return</span> &#123;</span><br><span class="line">        ...item,</span><br><span class="line">        attributes: item.attributes.map(<span class="function"><span class="params">attr</span> =&gt;</span> &#123;</span><br><span class="line">          <span class="keyword">if</span> (attr.key !== <span class="string">"id"</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> attr;</span><br><span class="line">          &#125;</span><br><span class="line">          <span class="keyword">return</span> &#123;</span><br><span class="line">            ...attr,</span><br><span class="line">            value: <span class="string">"container"</span></span><br><span class="line">          &#125;;</span><br><span class="line">        &#125;)</span><br><span class="line">      &#125;;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> item;</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> transform = <span class="function"><span class="params">code</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">const</span> ast = parse(code);</span><br><span class="line">  <span class="keyword">const</span> json = traverse(ast);</span><br><span class="line">  <span class="keyword">return</span> stringify(json);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(transform(code));</span><br></pre></td></tr></table></figure><p>也可以在<a href="https://codesandbox.io/embed/crazy-gauss-6vx9g?fontsize=14&amp;hidenavigation=1&amp;theme=dark" target="_blank" rel="noopener">codeSandbox</a>中查看效果。</p><h2 id="核心介绍"><a href="#核心介绍" class="headerlink" title="核心介绍"></a>核心介绍</h2><p>流程和工具介绍的差不多了，接下来就开始正题吧。<br>首先是整理差异，根据笔者的调研，微信小程序组件要转换成支付宝小程序组件，大致有以下几个改动（只是符合笔者的需求，如果不完全，欢迎补充）：</p><ol><li>wxml后缀名要改成axml</li><li>wxss后缀名要改成acss</li><li>wxml中的属性wx-xxx要改成a-xxx</li><li>wxml中的事件属性bindxxx要改成onXxx</li><li>生命周期attached要替换成onInit</li><li>生命周期detached要替换成didUnmount</li><li>生命周期pageLifetimes.show要替换成didMount</li><li>生命周期pageLifetimes要删除</li></ol><p>改后缀名的工作相对简单，交给构建工具，output配置里面指定一下就好了，重点是替换属性。</p><p>转换js部分代码如下<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; parse &#125; <span class="keyword">from</span> <span class="string">'@babel/parser'</span>;</span><br><span class="line"><span class="keyword">import</span> traverse <span class="keyword">from</span> <span class="string">'@babel/traverse'</span>;</span><br><span class="line"><span class="keyword">import</span> generate <span class="keyword">from</span> <span class="string">'@babel/generator'</span>;</span><br><span class="line"><span class="keyword">import</span> * <span class="keyword">as</span> t <span class="keyword">from</span> <span class="string">'@babel/types'</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">transformJs</span>(<span class="params">code: string</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> ast = parse(code);</span><br><span class="line">  <span class="keyword">let</span> pp;</span><br><span class="line"></span><br><span class="line">  traverse(ast, &#123;</span><br><span class="line">    enter(path) &#123;</span><br><span class="line">      <span class="keyword">if</span> (t.isIdentifier(path.node, &#123;<span class="attr">name</span>: <span class="string">'attached'</span>&#125;)) &#123;</span><br><span class="line">        path.node.name = <span class="string">'onInit'</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">if</span> (t.isIdentifier(path.node, &#123;<span class="attr">name</span>: <span class="string">'detached'</span>&#125;)) &#123;</span><br><span class="line">        path.node.name = <span class="string">'didUnmount'</span>;</span><br><span class="line">        pp = path.parentPath;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">if</span>(t.isIdentifier(path.node.key, &#123;<span class="attr">name</span>: <span class="string">'show'</span>&#125;))&#123;</span><br><span class="line">        path.node.key.name = <span class="string">'didMount'</span>;</span><br><span class="line">        pp.insertAfter(path.node);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    exit(path) &#123;</span><br><span class="line">      <span class="keyword">if</span>(t.isIdentifier(path.node.key, &#123;<span class="attr">name</span>: <span class="string">'pageLifetimes'</span>&#125;))&#123;</span><br><span class="line">        path.remove();</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;);</span><br><span class="line">  <span class="keyword">const</span> output = generate(ast, &#123;&#125;, code);</span><br><span class="line">  <span class="keyword">return</span> output</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> transformJs</span><br></pre></td></tr></table></figure></p><p>转换wxml部分如下：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; parse, stringify &#125; <span class="keyword">from</span> <span class="string">'himalaya-wxml'</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> traverseKey = <span class="function">(<span class="params">key: string</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">if</span>(key.startsWith(<span class="string">'wx:'</span>))&#123;</span><br><span class="line">    <span class="keyword">const</span> postfix = key.slice(<span class="number">3</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="string">`a:<span class="subst">$&#123;postfix&#125;</span>`</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span>(key === <span class="string">'catchtouchmove'</span>)&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">'catchTouchMove'</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span>(key === <span class="string">'bindtap'</span>)&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">'onTap'</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span>(key === <span class="string">'bindload'</span>)&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">'onLoad'</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span>(key === <span class="string">'binderror'</span>)&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">'onError'</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span>(key === <span class="string">'bindchange'</span>)&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">'onChange'</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> key</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> traverseAst = <span class="function">(<span class="params">ast: any</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> ast.map(<span class="function"><span class="params">item</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">if</span>(item.type !== <span class="string">'element'</span>)&#123;</span><br><span class="line">      <span class="keyword">return</span> item;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">let</span> res = item;</span><br><span class="line">    <span class="keyword">if</span>(item.attributes)&#123;</span><br><span class="line">      res = &#123;</span><br><span class="line">        ...item,</span><br><span class="line">        attributes: item.attributes.map(<span class="function"><span class="params">attr</span> =&gt;</span> (&#123;</span><br><span class="line">          ...attr,</span><br><span class="line">          key: traverseKey(attr.key)</span><br><span class="line">        &#125;))</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(item.children)&#123;</span><br><span class="line">      res.children = traverseAst(item.children);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> transformWxml = <span class="function">(<span class="params">code: string</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">const</span> ast = parse(code);</span><br><span class="line">  <span class="keyword">const</span> json = traverseAst(ast);</span><br><span class="line">  <span class="keyword">return</span> stringify(json)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> transformWxml</span><br></pre></td></tr></table></figure></p><p>以上，就拥有了两个转换函数，再之后的工作，就是将这两个函数运行在rollup里，就完成了将微信小程序组件转换成支付宝小程序组件的功能。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>javascript作为前端最常用的语言，我们不仅要熟悉它，更要能操控它，通过javascript解释器，我们就拥有了操控它的能力。溯本求源，巩固基础，才能在寒冬之中保持内心的平静。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;https://ss2.bdstatic.com/70cFvnSh_Q1YnxGkpoWK1HF6hhy/it/u=3710369427,300738485&amp;amp;fm=26&amp;amp;gp=0.jpg&quot; alt=&quot;https://ss2.bdstatic.com/70cFvnSh_Q1YnxGkpoWK1HF6hhy/it/u=3710369427,300738485&amp;amp;fm=26&amp;amp;gp=0.jpg&quot;&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;过年在家办公期间，接到了一个需求，需要将目前的 &lt;code&gt;微信小程序自定义组件&lt;/code&gt; 扩展到 &lt;code&gt;支付宝小程序&lt;/code&gt;  平台。关于需求的背景和历史这边就暂不多说了，就从上面已说明的内容来看待这个需求吧。&lt;br&gt;接到需求的第一时间，笔者就思考，这不就是多端编译吗？话不多说，那就开搞吧。&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="个人原创" scheme="http://1eeing.github.io/categories/%E4%B8%AA%E4%BA%BA%E5%8E%9F%E5%88%9B/"/>
    
    
      <category term="多端编译" scheme="http://1eeing.github.io/tags/%E5%A4%9A%E7%AB%AF%E7%BC%96%E8%AF%91/"/>
    
      <category term="AST" scheme="http://1eeing.github.io/tags/AST/"/>
    
  </entry>
  
  <entry>
    <title>从页面输入URL到展现，到底经历了什么？</title>
    <link href="http://1eeing.github.io/2019/10/17/%E4%BB%8E%E8%BE%93%E5%85%A5URL%E5%88%B0%E5%B1%95%E7%8E%B0/"/>
    <id>http://1eeing.github.io/2019/10/17/从输入URL到展现/</id>
    <published>2019-10-16T16:30:47.796Z</published>
    <updated>2019-10-16T16:31:31.255Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>这是一道常见的面试题，这次，我们就来彻底搞懂他。</p></blockquote><p>首先，总的来说，分为以下几个过程</p><ol><li>DNS解析</li><li>TCP连接</li><li>客户端发起HTTP请求</li><li>服务端接收请求，并返回对应的HTTP报文</li><li>浏览器解析报文、渲染页面</li><li>连接结束</li></ol><a id="more"></a><h2 id="具体过程"><a href="#具体过程" class="headerlink" title="具体过程"></a>具体过程</h2><h3 id="dns解析"><a href="#dns解析" class="headerlink" title="dns解析"></a>dns解析</h3><p>DNS解析的过程就是寻找哪台机器上有你需要的资源的过程。当你输入网址的时候，其实访问的是他的唯一IP地址，但是IP地址不方便记忆，因此才有了网址。DNS解析就是将网址对应到IP地址的过程。</p><h3 id="解析过程"><a href="#解析过程" class="headerlink" title="解析过程"></a>解析过程</h3><p><img src="https://segmentfault.com/img/bVDM45?w=1928&amp;h=1248" alt="https://segmentfault.com/img/bVDM45?w=1928&amp;h=1248"></p><h3 id="DNS优化"><a href="#DNS优化" class="headerlink" title="DNS优化"></a>DNS优化</h3><ol><li>DNS缓存</li><li>DNS负载均衡（也称DNS重定向）</li></ol><h3 id="TCP连接、HTTP请求"><a href="#TCP连接、HTTP请求" class="headerlink" title="TCP连接、HTTP请求"></a>TCP连接、HTTP请求</h3><p>这里包含了TCP的握手和挥手、HTTPS以及浏览器缓存<br>有关TCP、HTTP和HTTPS的知识请看我另一篇关于这部分知识的记录：<a href="http://blog.leeing.site/2018/08/07/HTTP/" target="_blank" rel="noopener">http://blog.leeing.site/2018/08/07/HTTP/</a><br>有关浏览器缓存的知识也可以看我另一篇关于这部分知识的记录：<a href="http://blog.leeing.site/2018/08/19/%E6%B5%8F%E8%A7%88%E5%99%A8%E7%9A%84%E7%BC%93%E5%AD%98%E7%AD%96%E7%95%A5/" target="_blank" rel="noopener">http://blog.leeing.site/2018/08/19/%E6%B5%8F%E8%A7%88%E5%99%A8%E7%9A%84%E7%BC%93%E5%AD%98%E7%AD%96%E7%95%A5/</a><br>这边就不详细介绍了。</p><h3 id="浏览器解析渲染页面"><a href="#浏览器解析渲染页面" class="headerlink" title="浏览器解析渲染页面"></a>浏览器解析渲染页面</h3><p>浏览器是一个边解析边渲染的过程。首先浏览器解析HTML文件构建DOM树，然后解析CSS文件构建CSSOM树，然后将两棵树合并为一棵render树，等到render树构建完成后，浏览器开始布局渲染并将其绘制到屏幕上。<br>在这个过程中，涉及到两个概念，重绘和回流。DOM中各个元素都需要浏览器去计算其位置和大小，这个过程称为回流。当这些属性都确定下来之后，浏览器便开始绘制内容，这个过程称为重绘。页面在首次加载的时候必然会经历重绘和回流。且回流必定重绘，重绘不一定回流。<br>重绘和回流是非常消耗性能的，尤其是在移动设备上，它会破坏用户体验，有时会造成页面卡顿。所以我们应该尽可能减少重绘和回流。</p><p>JS的解析是由浏览器中的JS解析引擎完成的。JS是单线程运行，但是存在一些任务特别耗时，如IO操作。因此，需要一种机制可以先执行排在后面的任务，这就是同步任务和异步任务（宏任务和微任务）。JS的执行机制就可以看做是一个主线程加一个任务队列。同步任务就是放在主线程上执行的任务，异步任务就是放在任务队列中的任务。所有的同步任务在主线程上执行，形成一个执行栈；异步任务有了运行结果就会在任务队列中添加一个事件；脚本执行时先依次运行执行栈，然后会从任务队列中提取事件，运行任务队列中的任务。这个过程不断重复，故而又称为事件循环（event loop）。</p><p>浏览器在解析的过程中，如果遇到请求外部资源时，如图片时，请求过程是异步的，并不会影响HTML文档进行加载。但是如果遇到JS文件，HTML会挂起渲染过程，不仅要等到其下载完成还要等其解析执行完毕，才会继续HTML的渲染过程。原因是JS有可能修改DOM结构。CSS的加载不影响JS文件的加载，但是影响JS文件的执行。因此JS代码执行前，浏览器必须保证CSS文件已经下载并加载完毕。这也是为什么建议CSS文件放在HEAD里，script标签包裹的JS文件放在body底部的原因。</p>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;这是一道常见的面试题，这次，我们就来彻底搞懂他。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;首先，总的来说，分为以下几个过程&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;DNS解析&lt;/li&gt;
&lt;li&gt;TCP连接&lt;/li&gt;
&lt;li&gt;客户端发起HTTP请求&lt;/li&gt;
&lt;li&gt;服务端接收请求，并返回对应的HTTP报文&lt;/li&gt;
&lt;li&gt;浏览器解析报文、渲染页面&lt;/li&gt;
&lt;li&gt;连接结束&lt;/li&gt;
&lt;/ol&gt;
    
    </summary>
    
      <category term="学习笔记" scheme="http://1eeing.github.io/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="基础知识" scheme="http://1eeing.github.io/tags/%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"/>
    
      <category term="计算机通识" scheme="http://1eeing.github.io/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E9%80%9A%E8%AF%86/"/>
    
      <category term="学习笔记" scheme="http://1eeing.github.io/tags/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>常见的跨域技巧及其原理</title>
    <link href="http://1eeing.github.io/2019/10/17/%E5%B8%B8%E8%A7%81%E7%9A%84%E8%B7%A8%E5%9F%9F%E6%8A%80%E5%B7%A7/"/>
    <id>http://1eeing.github.io/2019/10/17/常见的跨域技巧/</id>
    <published>2019-10-16T16:29:24.509Z</published>
    <updated>2019-10-16T16:30:34.104Z</updated>
    
    <content type="html"><![CDATA[<p>在了解怎么跨域之前，我们先要理解为什么会产生跨域。</p><h2 id="跨域产生的原因"><a href="#跨域产生的原因" class="headerlink" title="跨域产生的原因"></a>跨域产生的原因</h2><p>浏览器存在同源策略，为了安全。所谓同源是指“协议+域名+端口”三者相同，缺一不可。</p><p>同源侧滤限制的内容有：</p><ol><li>Cookie、localStorage、IndexDB等存储型内容</li><li>DOM节点</li><li>ajax请求</li></ol><a id="more"></a><p>有四个标签是允许加载跨域资源的</p><ol><li><code>&lt;img&gt;</code>标签</li><li><code>&lt;script&gt;</code>标签</li><li><code>&lt;link&gt;</code>标签</li><li><code>&lt;iframe&gt;</code>标签</li></ol><h2 id="如何解决跨域"><a href="#如何解决跨域" class="headerlink" title="如何解决跨域"></a>如何解决跨域</h2><p>在了解跨域是怎么产生了以后，我们来看看如何解决这个问题。</p><h3 id="1、jsonp"><a href="#1、jsonp" class="headerlink" title="1、jsonp"></a>1、jsonp</h3><h4 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h4><p>jsonp就是利用了<code>&lt;script&gt;</code>标签可以跨域请求资源的特性，将一个callback回调函数名，以形如<code>?callback=test</code>的方式拼接在请求url的<code>search</code>参数里，再通过<code>GET</code>请求传递给服务端。服务端接收到请求并处理完成后，返回一个形如<code>test(response)</code>的<code>responseBody</code>。这样，前端拿到响应结果后，就会执行test方法并拿到里面的结果。</p><h4 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h4><p>前端代码实现可以在我的<a href="https://github.com/1eeing/my-functions/blob/master/src/http/jsonp.ts" target="_blank" rel="noopener">github</a>里找到。</p><h4 id="优缺点"><a href="#优缺点" class="headerlink" title="优缺点"></a>优缺点</h4><p>优点：兼容性好<br>缺点：仅支持<code>GET</code>方法，可能会遭受XSS攻击。</p><h3 id="2、cors"><a href="#2、cors" class="headerlink" title="2、cors"></a>2、cors</h3><p>浏览器会自动进行CORS通信，实现CORS的关键是服务端，只要服务端支持，就实现了跨域。</p><h4 id="实现流程"><a href="#实现流程" class="headerlink" title="实现流程"></a>实现流程</h4><p>服务端设置Acces-Control-Allow-Origin就可以开启CORS。该属性表示哪些域名可以访问资源，如果设置通配符，则表示所有网站都可以访问资源。</p><p>通过CORS来解决跨域的话，会在发送请求时出现两种情况，<strong>简单请求</strong>和<strong>复杂请求</strong>。</p><h4 id="简单请求"><a href="#简单请求" class="headerlink" title="简单请求"></a>简单请求</h4><p>只要同时满足以下两大条件，就属于简单请求。</p><ul><li>条件1：使用下列方法之一<ul><li>GET</li><li>HEAD</li><li>POST</li></ul></li><li>条件二：Content-Type为下面三者之一<ul><li>text/plain</li><li>multipart/form-data</li><li>application/x-www-form-urlencoded</li></ul></li></ul><h4 id="复杂请求"><a href="#复杂请求" class="headerlink" title="复杂请求"></a>复杂请求</h4><p>不符合以上条件的请求就是复杂请求。复杂请求会在正式通信之前，发送一个OPTION请求，该请求的作用是<strong>预检</strong>。通过该请求，来判断服务器是否支持跨域请求。</p><h3 id="3、postMessage"><a href="#3、postMessage" class="headerlink" title="3、postMessage"></a>3、postMessage</h3><p>关于postMessage的可以看我的另一篇文章，<a href="http://blog.leeing.site/2018/08/12/postMessage/" target="_blank" rel="noopener">《从iframe高度自适应了解postMessage》</a>，这边不再过多介绍了。</p><h3 id="4、websocket"><a href="#4、websocket" class="headerlink" title="4、websocket"></a>4、websocket</h3><p>websocket也是支持跨域的。</p><h3 id="5、服务端处理"><a href="#5、服务端处理" class="headerlink" title="5、服务端处理"></a>5、服务端处理</h3><p>同源策略是浏览器的安全策略，所以，在服务端是不存在跨域问题的。因此，我们可以通过先请求同域下的服务器，服务器帮我们去请求原本直接请求会跨域的请求，然后将结果返回给前端。</p><p>这个服务端可以有多种实现方案，<code>node</code>、<code>Nginx</code>、甚至交给你们的后端都可以。</p><h3 id="6、document-domain"><a href="#6、document-domain" class="headerlink" title="6、document.domain"></a>6、document.domain</h3><p>该方式只能用于二级域名相同的情况下，比如<code>a.test.com</code>与<code>b.test.com</code>。需要分别给两个页面添加<code>document.domain = test.com</code>，表示二级域名相同就可以实现跨域了。</p><h3 id="7、通过img标签"><a href="#7、通过img标签" class="headerlink" title="7、通过img标签"></a>7、通过img标签</h3><p>前面也提到了，<code>&lt;img&gt;</code>标签可以跨域。因此，当我们需要上报一些信息而不用关心返回结果的时候，可以使用<code>&lt;img&gt;</code>标签来跨域请求。<br>该方法类似<code>jsonp</code>，将需要访问的url和参数拼接到img标签的url中，通过GET请求该图片，就可以实现跨域请求。</p><p>具体实现也可以参考我的<a href="https://github.com/1eeing/my-functions/blob/master/src/http/imgJsonp.ts" target="_blank" rel="noopener">github</a>。</p><h4 id="优缺点-1"><a href="#优缺点-1" class="headerlink" title="优缺点"></a>优缺点</h4><p>优点：兼容性好<br>缺点：仅支持<code>GET</code>方法，但是因为不会用到返回值，所以遭受XSS攻击的可能性比jsonp低</p><h4 id="适用场景"><a href="#适用场景" class="headerlink" title="适用场景"></a>适用场景</h4><p>打点上报之类的只需要请求，不需要用到返回值的场景。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;在了解怎么跨域之前，我们先要理解为什么会产生跨域。&lt;/p&gt;
&lt;h2 id=&quot;跨域产生的原因&quot;&gt;&lt;a href=&quot;#跨域产生的原因&quot; class=&quot;headerlink&quot; title=&quot;跨域产生的原因&quot;&gt;&lt;/a&gt;跨域产生的原因&lt;/h2&gt;&lt;p&gt;浏览器存在同源策略，为了安全。所谓同源是指“协议+域名+端口”三者相同，缺一不可。&lt;/p&gt;
&lt;p&gt;同源侧滤限制的内容有：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;Cookie、localStorage、IndexDB等存储型内容&lt;/li&gt;
&lt;li&gt;DOM节点&lt;/li&gt;
&lt;li&gt;ajax请求&lt;/li&gt;
&lt;/ol&gt;
    
    </summary>
    
      <category term="学习笔记" scheme="http://1eeing.github.io/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="基础知识" scheme="http://1eeing.github.io/tags/%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"/>
    
      <category term="计算机通识" scheme="http://1eeing.github.io/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E9%80%9A%E8%AF%86/"/>
    
      <category term="学习笔记" scheme="http://1eeing.github.io/tags/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
      <category term="安全" scheme="http://1eeing.github.io/tags/%E5%AE%89%E5%85%A8/"/>
    
      <category term="跨域" scheme="http://1eeing.github.io/tags/%E8%B7%A8%E5%9F%9F/"/>
    
  </entry>
  
  <entry>
    <title>常见的网络攻击及其防范手段</title>
    <link href="http://1eeing.github.io/2019/10/17/%E5%B8%B8%E8%A7%81%E7%9A%84%E7%BD%91%E7%BB%9C%E6%94%BB%E5%87%BB%E5%8F%8A%E5%85%B6%E9%98%B2%E8%8C%83%E6%89%8B%E6%AE%B5/"/>
    <id>http://1eeing.github.io/2019/10/17/常见的网络攻击及其防范手段/</id>
    <published>2019-10-16T16:25:38.059Z</published>
    <updated>2019-10-16T16:27:42.959Z</updated>
    
    <content type="html"><![CDATA[<p>前端能遇到的网络攻击，基本只包含以下两类</p><ul><li>XSS</li><li>CSRF</li></ul><p>这篇文章就整理一下常见的网络攻击及其防范手段。</p><h2 id="XSS（跨站脚本攻击）"><a href="#XSS（跨站脚本攻击）" class="headerlink" title="XSS（跨站脚本攻击）"></a>XSS（跨站脚本攻击）</h2><p>是一种网站应用程式的安全漏洞攻击，是代码注入的一种。它允许恶意使用者将程式码注入到网页上，其他使用者在观看网页时就会受到影响。这类攻击通常包含了HTML以及使用者端脚本语言。</p><a id="more"></a><p>大概有以下三种攻击方式：</p><ul><li><p>反射型<br>XSS通过修改HTML节点或者执行JS代码来攻击网站，例如通过URL获取参数的时候，将url改成一段攻击脚本</p></li><li><p>存储型<br>例如写了一篇包含攻击代码的文章，那么浏览文章的用户都会被攻击到</p></li><li><p>DOM-based<br>以上两种都可算DOM-based类型</p></li></ul><p>如何防御？</p><ul><li>转义输入输出的内容，对于引号、尖括号、斜杠进行转义</li><li>对于显示富文本来说，可以通过白名单过滤或者黑名单过滤</li><li>CSP（内容安全策略），本质上也是建立白名单，规定了浏览器只能够执行特定来源的代码<br>HTTP Header中的Content-Security-Policy可以开启CSP，值：<ul><li>default-src ‘self’ 只允许加载本站资源</li><li>img-src https://* 只允许加载HTTPS协议图片</li><li>child-src ‘none’ 允许加载任何来源框架</li><li><a href="https://content-security-policy.com/" target="_blank" rel="noopener">更多属性</a></li></ul></li></ul><h2 id="CSRF（跨站点请求伪造）"><a href="#CSRF（跨站点请求伪造）" class="headerlink" title="CSRF（跨站点请求伪造）"></a>CSRF（跨站点请求伪造）</h2><h3 id="如何攻击？"><a href="#如何攻击？" class="headerlink" title="如何攻击？"></a>如何攻击？</h3><p>假设网站中有一个通过Get请求提交用户评论的接口，那么攻击者就可以在钓鱼网站中加入一个图片，图片的地址就是评论接口<br><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">"http://www.xxx.com/xxx?comment='attack'"</span> /&gt;</span></span><br></pre></td></tr></table></figure></p><p>Post提交的用表单<br><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">form</span> <span class="attr">action</span>=<span class="string">"http://www.xxx.com/xxx"</span> <span class="attr">id</span>=<span class="string">"CSRF"</span> <span class="attr">method</span>=<span class="string">"post"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">input</span> <span class="attr">name</span>=<span class="string">"comment"</span> <span class="attr">value</span>=<span class="string">"attack"</span> <span class="attr">type</span>=<span class="string">"hidden"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">form</span>&gt;</span></span><br></pre></td></tr></table></figure></p><h3 id="如何防御"><a href="#如何防御" class="headerlink" title="如何防御"></a>如何防御</h3><ol><li>Get请求不对数据进行修改</li><li>不让第三方网站访问到用户Cookie</li><li>阻止第三方网站请求接口</li><li>请求时附带验证信息，比如验证码或者token</li></ol><blockquote><p>补充：</p><ul><li>SameSite 该Cookie属性可以设置Cookie不随着跨域请求发送，但是兼容性不太好</li><li>验证Referer 通过验证Referer来判断该请求是否为第三方网站发起的</li><li>Token 服务器下发一个随机Token，每次请求将Token带上，服务器验证是否有效</li></ul></blockquote><h2 id="密码安全"><a href="#密码安全" class="headerlink" title="密码安全"></a>密码安全</h2><p>密码必然不能铭文存储在数据库。并且也不建议只对密码单纯通过加密算法加密，因为存在彩虹表，可以反查出加密前的密码。因此，通常需要对密码加盐，然后进行几次不同加密算法的加密（加盐就是给原密码添加字符串，增加原密码长度）</p><p>加盐不能阻止别人盗号，但是能保证即使数据库泄露，也不会暴露用户的真实密码。但是攻击者可以通过暴力破解的方式破解密码。对于这种情况，通常使用验证码增加延时或者限制尝试次数。并且一旦用户输入了错误的密码，也不能直接提示密码错误，而应该提示账号或密码错误。</p><blockquote><p>前端加密对安全防护意义不大，但是在遇到中间人攻击的情况下，可以避免名文密码被第三方获取</p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;前端能遇到的网络攻击，基本只包含以下两类&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;XSS&lt;/li&gt;
&lt;li&gt;CSRF&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;这篇文章就整理一下常见的网络攻击及其防范手段。&lt;/p&gt;
&lt;h2 id=&quot;XSS（跨站脚本攻击）&quot;&gt;&lt;a href=&quot;#XSS（跨站脚本攻击）&quot; class=&quot;headerlink&quot; title=&quot;XSS（跨站脚本攻击）&quot;&gt;&lt;/a&gt;XSS（跨站脚本攻击）&lt;/h2&gt;&lt;p&gt;是一种网站应用程式的安全漏洞攻击，是代码注入的一种。它允许恶意使用者将程式码注入到网页上，其他使用者在观看网页时就会受到影响。这类攻击通常包含了HTML以及使用者端脚本语言。&lt;/p&gt;
    
    </summary>
    
      <category term="学习笔记" scheme="http://1eeing.github.io/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="基础知识" scheme="http://1eeing.github.io/tags/%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"/>
    
      <category term="计算机通识" scheme="http://1eeing.github.io/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E9%80%9A%E8%AF%86/"/>
    
      <category term="学习笔记" scheme="http://1eeing.github.io/tags/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
      <category term="安全" scheme="http://1eeing.github.io/tags/%E5%AE%89%E5%85%A8/"/>
    
      <category term="网络攻击" scheme="http://1eeing.github.io/tags/%E7%BD%91%E7%BB%9C%E6%94%BB%E5%87%BB/"/>
    
  </entry>
  
  <entry>
    <title>javascript垃圾回收机制</title>
    <link href="http://1eeing.github.io/2019/10/17/javascript%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E6%9C%BA%E5%88%B6/"/>
    <id>http://1eeing.github.io/2019/10/17/javascript垃圾回收机制/</id>
    <published>2019-10-16T16:24:32.565Z</published>
    <updated>2019-10-16T16:29:02.800Z</updated>
    
    <content type="html"><![CDATA[<h2 id="什么需要被释放？"><a href="#什么需要被释放？" class="headerlink" title="什么需要被释放？"></a>什么需要被释放？</h2><ol><li>字符串</li><li>数组</li><li>对象</li></ol><h2 id="为什么它们需要被释放？"><a href="#为什么它们需要被释放？" class="headerlink" title="为什么它们需要被释放？"></a>为什么它们需要被释放？</h2><p>因为它们没有固定大小，只有当它们大小已知的时候，才能对它们进行动态的存储方案。<br>因此JS每次创建它们时，都必须分配内存，这就是动态分配内存。<br>只要是动态分配内存的，都需要被释放。否则，JS的解释器将会消耗完系统中所有可用的内存，造成系统崩溃</p><a id="more"></a><p>例子：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a = <span class="string">'before'</span></span><br><span class="line"><span class="keyword">var</span> b = <span class="string">'overwrite a'</span></span><br><span class="line"><span class="keyword">var</span> a = b</span><br></pre></td></tr></table></figure></p><p>以上这个例子中，before这个字段失去了引用，系统检测到这个事实之后，就会释放该字符串的存储空间以便这些空间可以被再利用。</p><h2 id="怎么垃圾回收？"><a href="#怎么垃圾回收？" class="headerlink" title="怎么垃圾回收？"></a>怎么垃圾回收？</h2><p><strong>1、 标记清除</strong>（todo 这个解释不是很清晰）<br>当变量进入执行环境时，就标记这个变量为“进入环境”。当变量离开环境时，则标记“离开环境”。理论上永远不会释放“进入环境”的变量，因为很可能会被用到。<br>垃圾收集器在运行的时候，会给存储在内存中的所有变量都加上标记。然后，它会去掉环境中的变量以及被环境中的变量引用的标记。在此之后，如果变量再被加上标记，则该变量将被视为准备删除的变量，因为环境中的变量已经无法访问到这些变量了。最后。垃圾收集器完成内存清除工作，销毁那些带标记的值，并回收它们所占用的内存空间。</p><p><strong>2、 引用计数（不太常见）</strong><br>引用计数的含义是，<strong>跟踪记录每个值被引用的次数</strong>。当声明了一个变量的并将一个引用类型赋值给该变量时，则这个值的引用次数就是1。相反，如果包含对这个值引用的变量被赋值成了另一个值，则这个值的引用次数就减1。当引用次数变为0时，则说明没有办法再访问这个值了，因而就可以将其所占的内存空间给收回来。这样，垃圾收集器下次再运行时，它就会释放那些引用次数为0的值所占的内存。</p><p>引用计数存在一个问题，如果两个对象相互引用了，则引用次数永远是1，不会被垃圾回收机制所回收。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a = &#123;&#125;;</span><br><span class="line"><span class="keyword">var</span> b = &#123;&#125;;</span><br><span class="line">a.someProperty = b;</span><br><span class="line">b.someProperty = a;</span><br></pre></td></tr></table></figure><p>大量这样的相互引用就会导致大量的内存泄漏。</p><p>这个问题不太好避免。例如，DOM和BOM是用C++的COM（Component Object Modal，组件对象）对象实现的，而COM对象的垃圾回收器就是采用的引用计数的策略。因此，即使Javascript的垃圾回收器是使用标记清除的策略来实现的，只要访问了COM对象，依然会存在循环引用的问题。看下这个例子。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> elem = <span class="built_in">document</span>.getElementById(<span class="string">'element'</span>);</span><br><span class="line"><span class="keyword">var</span> obj = &#123;&#125;;</span><br><span class="line">obj.element = elem;</span><br><span class="line">elem.obj = obj;</span><br></pre></td></tr></table></figure><p>在这个例子中，一个DOM元素与一个原生JS对象之间建立了相互引用。由于相互引用，即使将elem这个DOM元素从页面中删除，内存也永远不会被回收。</p><p>我们可以手动切断循环引用来解决这个问题</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">obj.element = <span class="literal">null</span>;</span><br><span class="line">elem.obj = <span class="literal">null</span>;</span><br></pre></td></tr></table></figure><h2 id="怎么减少垃圾内存"><a href="#怎么减少垃圾内存" class="headerlink" title="怎么减少垃圾内存"></a>怎么减少垃圾内存</h2><p><strong>1、 对象object优化</strong><br>避免使用<code>someObj = {}</code>来清空对象，因为这将会导致过多的内存创建。可以通过清空一个对象，再在此对象上添加属性的方式来达到复用对象的目的，从而节省内存。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">clearObj</span>(<span class="params">obj</span>)</span>&#123;</span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">let</span> key <span class="keyword">in</span> obj)&#123;</span><br><span class="line">    <span class="keyword">if</span>(obj.hasOwnProperty(key))&#123;</span><br><span class="line">      <span class="keyword">delete</span> obj[key];</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p><strong>2、 数组array优化</strong><br>同理，避免使用<code>someArr = []</code>来清空数组，可以使用<code>someArr.length = 0</code>来清空一个数组并复用它，来达到节省内存的目的。</p><p><strong>3、 function优化</strong><br>如果一个function总是被重复创建和使用，可以用一个变量先保存它，从而达到节省内存的目的。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">this</span>.func = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="built_in">Date</span>.now());</span><br><span class="line">&#125;</span><br><span class="line">setTimeout(<span class="keyword">this</span>.func, <span class="number">1000</span>);</span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;什么需要被释放？&quot;&gt;&lt;a href=&quot;#什么需要被释放？&quot; class=&quot;headerlink&quot; title=&quot;什么需要被释放？&quot;&gt;&lt;/a&gt;什么需要被释放？&lt;/h2&gt;&lt;ol&gt;
&lt;li&gt;字符串&lt;/li&gt;
&lt;li&gt;数组&lt;/li&gt;
&lt;li&gt;对象&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id=&quot;为什么它们需要被释放？&quot;&gt;&lt;a href=&quot;#为什么它们需要被释放？&quot; class=&quot;headerlink&quot; title=&quot;为什么它们需要被释放？&quot;&gt;&lt;/a&gt;为什么它们需要被释放？&lt;/h2&gt;&lt;p&gt;因为它们没有固定大小，只有当它们大小已知的时候，才能对它们进行动态的存储方案。&lt;br&gt;因此JS每次创建它们时，都必须分配内存，这就是动态分配内存。&lt;br&gt;只要是动态分配内存的，都需要被释放。否则，JS的解释器将会消耗完系统中所有可用的内存，造成系统崩溃&lt;/p&gt;
    
    </summary>
    
      <category term="学习笔记" scheme="http://1eeing.github.io/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="基础知识" scheme="http://1eeing.github.io/tags/%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"/>
    
      <category term="计算机通识" scheme="http://1eeing.github.io/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E9%80%9A%E8%AF%86/"/>
    
      <category term="学习笔记" scheme="http://1eeing.github.io/tags/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
      <category term="垃圾回收" scheme="http://1eeing.github.io/tags/%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/"/>
    
  </entry>
  
  <entry>
    <title>《React最佳实践系列》之css篇</title>
    <link href="http://1eeing.github.io/2019/09/20/React%08%E6%9C%80%E4%BD%B3%E5%AE%9E%E8%B7%B5%E4%B9%8Bcss/"/>
    <id>http://1eeing.github.io/2019/09/20/React最佳实践之css/</id>
    <published>2019-09-19T17:31:03.344Z</published>
    <updated>2019-09-19T17:34:44.402Z</updated>
    
    <content type="html"><![CDATA[<p><img src="http://img1.juimg.com/180124/330595-1P124141G060.jpg" alt="http://img1.juimg.com/180124/330595-1P124141G060.jpg"></p><blockquote><p>React中的css到底该怎么写？这一直是个饱受争论的话题。本文将结合React CSS的发展史，分别叙述CSS in js与CSS module两种风格中的最佳实践。</p></blockquote><a id="more"></a><h2 id="行内样式"><a href="#行内样式" class="headerlink" title="行内样式"></a>行内样式</h2><p>首先，facebook提出<code>CSS in js</code>的概念，这很奇怪。<br>我们多年来所学的知识都在宣扬关注点分离的重要性，不应该将标记和css混在一起。但是React行内样式的提出，试图改变关注点分离这一概念。使其从技术分离向组件分离转变。</p><p>通过<code>CSS in js</code>，<strong>有以下两个优点：</strong></p><ol><li>React将组件作为应用架构的基础单元，通过组合组件来创建应用。</li><li>可以很方便的和逻辑进行交互。</li></ol><p>比如这样（先忽略直接将style对象传入带来的性能问题）</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">render()&#123;</span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    &lt;div style=&#123;&#123;<span class="attr">fontWeight</span>: <span class="keyword">this</span>.props.weight ? <span class="string">'bold'</span> : <span class="string">'normal'</span>&#125;&#125;&gt;hello world&lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">  )</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br></pre></td></tr></table></figure><p><strong>行内样式也有缺点：</strong></p><ol><li>不支持伪选择器和伪元素</li><li>不支持媒体查询</li><li>不支持样式回退，因为js对象不支持两个同名属性</li><li>不支持动画</li><li>需要覆盖常规样式的时候，可能会需要<code>!important</code>来实现了</li><li>调试不方便</li><li>很关键的一点，如果是在服务端渲染的话，会使得页面体积变得很大</li></ol><p>事实证明，虽然行内样式解决了目标问题，却引发了更多的问题。</p><h2 id="CSS-Module"><a href="#CSS-Module" class="headerlink" title="CSS Module"></a>CSS Module</h2><p>如果你认为行内样式的方案不适合自己的团队，但仍然希望尽量紧密结合样式与组件，那么<code>webpack</code>的<code>css-loader</code>就帮了你大忙！<br>关于<code>webpack</code>和详细配置，本文不再赘述。我们看一下本文主要用到的<code>loader</code>和<code>plugin</code>：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> HTMLWebpackPlugin = <span class="built_in">require</span>(<span class="string">'html-webpack-plugin'</span>)</span><br><span class="line"></span><br><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  ...</span><br><span class="line">  <span class="built_in">module</span>: &#123;</span><br><span class="line">    rules: [</span><br><span class="line">      ...</span><br><span class="line">      &#123;</span><br><span class="line">        test: <span class="regexp">/\.css$/</span>,</span><br><span class="line">        use: [</span><br><span class="line">          &#123; <span class="attr">loader</span>: <span class="string">'style-loader'</span> &#125;,</span><br><span class="line">          &#123;</span><br><span class="line">            loader: <span class="string">'css-loader'</span>,</span><br><span class="line">            options: &#123;</span><br><span class="line">              modules: <span class="literal">true</span></span><br><span class="line">            &#125;</span><br><span class="line">          &#125;</span><br><span class="line">        ]</span><br><span class="line">      &#125;</span><br><span class="line">    ]</span><br><span class="line">  &#125;,</span><br><span class="line">  plugins: [</span><br><span class="line">    <span class="keyword">new</span> HTMLWebpackPlugin()</span><br><span class="line">  ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如上配置完以后，在终端启动项目后，就可以在网页中访问了。接下来我们开始编写具体代码。</p><p>首先定义一个普通的css文件</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.button</span> &#123;</span><br><span class="line">  <span class="attribute">background-color</span>: blue;</span><br><span class="line">  <span class="attribute">color</span>: <span class="number">#fff</span>;</span><br><span class="line">  <span class="attribute">padding</span>: <span class="number">10px</span> <span class="number">20px</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后在js文件中引入</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> styles <span class="keyword">from</span> <span class="string">'./index.css'</span></span><br></pre></td></tr></table></figure><p>import语句会导入一个样式对象，其所有属性就是index.css中定义的类，这时候运行一下console，开发者工具会输出一个形如这样的对象。这个key是根据文件散列值和其他一些参数生成的。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  button: <span class="string">"_2wpxM3yizfwbWee6k0U1D4"</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>接着，我们可以用这个对象去设置按钮的className属性</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> Button = <span class="function"><span class="params">()</span> =&gt;</span> (</span><br><span class="line">  &lt;button className=&#123;styles.button&#125;&gt;Click it&lt;<span class="regexp">/button&gt;</span></span><br><span class="line"><span class="regexp">)</span></span><br></pre></td></tr></table></figure><p>这样，按钮的样式就设置完成了。<br>我们打开开发者工具可以看到，button的类名就是上面的<code>_2wpxM3yizfwbWee6k0U1D4</code>。如果查看页面头部，我们还会发现相同的类名已经注入到页面中了。</p><p><code>css-loader</code>允许你在js模块中导入css文件，并且启用<code>modules</code>标记时，所有类名都只作用于导入它们的模块。最后，<code>style-loader</code>接收<code>css-loader</code>转换的结果，并将样式注入到页面头部。</p><p>这种用法非常强大，因为我们拥有了css的完整能力及表现性，又结合了局部作用域类名与显示依赖的优点。我们还可以像这样配置<code>localIdentName</code>参数，解决调试时信息不清晰的问题。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">module</span>: &#123;</span><br><span class="line">  rules: [</span><br><span class="line">    &#123;</span><br><span class="line">      test: <span class="regexp">/\.css$/</span>,</span><br><span class="line">      use: [</span><br><span class="line">        &#123; <span class="attr">loader</span>: <span class="string">'style-loader'</span> &#125;,</span><br><span class="line">        &#123;</span><br><span class="line">          loader: <span class="string">'css-loader'</span>,</span><br><span class="line">          options: &#123;</span><br><span class="line">            modules: <span class="literal">true</span>,</span><br><span class="line">            localIdentName: <span class="string">'[path][name]__[local]--[hash:base64:5]'</span></span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">      ]</span><br><span class="line">    &#125;</span><br><span class="line">  ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>生产环境不需要这样的类名，更注重性能，因此我们想要更简短的类名和散列值。<br>我们可以在生产环境下使用<code>MiniCssExtractPlugin</code>将样式提取到单独的css文件，并将其放入<code>CDN</code>，从而获得更好的性能。</p><p><strong>css-loader还支持一些关键词。</strong></p><p>第一个就是<code>global</code>关键词。给任何类添加<code>:global</code>前缀，意味着请求CSS模块不要为当前选择器加上局部作用域。</p><p>例如：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-pseudo">:global</span> <span class="selector-class">.button</span> &#123;</span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样，你可以应用不需要局部作用域的样式。比如第三方组件。</p><p>第二个就是<code>composes</code>，有了它，就可以从同个文件或外部依赖中引用类名，将其它类的所有样式应用于一个元素。</p><p>例如：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.text-red</span>&#123;</span><br><span class="line">  <span class="attribute">color</span>: red;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.button</span> &#123;</span><br><span class="line">  <span class="attribute">composes</span>: text-red;</span><br><span class="line">  <span class="attribute">background-color</span>: blue;</span><br><span class="line">  <span class="attribute">color</span>: <span class="number">#fff</span>;</span><br><span class="line">  <span class="attribute">padding</span>: <span class="number">10px</span> <span class="number">20px</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>最终，button类的所有规则以及composes声明的所有规则都能作用于元素。</p><p>这个特性非常强大，而且原理很巧妙。你可能以为它和<code>SASS</code>的<code>@extend</code>方法一样，只是将组合类复制到引用它们的位置，其实不是这样。简单来讲，所有组合类名都是逐个应用到DOM中的组件上。</p><p>以我们的示例来说，代码如下：</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;button <span class="class"><span class="keyword">class</span></span>=<span class="string">"_2wpxM3yizfwbWee6k0U1D4 Sf8w9cFdQXdRV_i9dgcOq"</span>&gt;Click it&lt;<span class="regexp">/button&gt;</span></span><br></pre></td></tr></table></figure><p>注入页面的css如下所示：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.Sf8w9cFdQXdRV_i9dgcOq</span> &#123;</span><br><span class="line">  <span class="attribute">color</span>: red;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">._2wpxM3yizfwbWee6k0U1D4</span> &#123;</span><br><span class="line">  <span class="attribute">background-color</span>: blue;</span><br><span class="line">  <span class="attribute">color</span>: <span class="number">#fff</span>;</span><br><span class="line">  <span class="attribute">padding</span>: <span class="number">10px</span> <span class="number">20px</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="原子级CSS"><a href="#原子级CSS" class="headerlink" title="原子级CSS"></a>原子级CSS</h2><p>原子级CSS又称函数式CSS，是CSS的一种使用方式，即每个类只有一条规则。</p><p>例如，可以用一个类来设置底部外边距为0：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.mb0</span> &#123;</span><br><span class="line">  <span class="attribute">margin-bottom</span>: <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后用另一个类设置font-weight为bold</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.fwb</span> &#123;</span><br><span class="line">  <span class="attribute">font-weight</span>: bold;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后将这些原子类用在元素上：</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;span <span class="class"><span class="keyword">class</span></span>=<span class="string">"mb0 fwb"</span>&gt;Hello World&lt;<span class="regexp">/span&gt;</span></span><br></pre></td></tr></table></figure><p>这种技巧存在争议，但很高效。一方面，类是在CSS文件中定义，却在视图层组合，每次修改元素的样式都要同时修改两个地方；另一方面，它可以超快地搭建页面。</p><p>其实，只要所有基本规则都定好，将这些类应用于元素或者用它们生成新的样式都非常快，这是一大优点。其次，使用原子级CSS可以控制css文件的大小，因为创建新组建时可以复用已有类的样式，不需要编写新样式，这对性能很有好处。</p><h2 id="原子级CSS-Module"><a href="#原子级CSS-Module" class="headerlink" title="原子级CSS Module"></a>原子级CSS Module</h2><p>我们可以将CSS Module与原子级CSS结合起来使用。</p><p>查看以下示例：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">.title &#123;</span><br><span class="line">  composes: mb0 fwb;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&lt;span class=&quot;title&quot;&gt;Hello World&lt;/span&gt;</span><br></pre></td></tr></table></figure><p>这种做法非常好，因为样式逻辑仍然保留在CSS中，同时CSS模块利用composes将所有单个类聚合到一个类中。</p><p>上述代码的渲染结果如下所示：</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;span <span class="class"><span class="keyword">class</span></span>=<span class="string">"title--3JCJR mb0--21SyP fwb--1JRhZ"</span>&gt;Hello World&lt;<span class="regexp">/span&gt;</span></span><br></pre></td></tr></table></figure><p>此处的<code>title</code>、<code>mb0</code>以及<code>fwb</code>都是自动加到元素上的。并且它们都只作用于局部。这样，我们就用上了CSS Module的所有优势。</p><h2 id="styled-components"><a href="#styled-components" class="headerlink" title="styled-components"></a>styled-components</h2><p>最后，让我们看一下CSS in js中的王者——styled-components。<br>这个库可以说考虑到了其他组件样式库遇到的所有问题。</p><p>在安装styled-components之后，我们可以这样使用它：</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> styled <span class="keyword">from</span> <span class="string">'styled-components'</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> Button = styled.button<span class="string">`</span></span><br><span class="line"><span class="string">  background-color: blue;</span></span><br><span class="line"><span class="string">  color: #fff;</span></span><br><span class="line"><span class="string">  padding: 10px 20px;</span></span><br><span class="line"><span class="string">`</span></span><br></pre></td></tr></table></figure><p>可以看到它使用了模板字符串，这意味着它可以用js的全部能力为元素添加样式。<br>这种看似奇怪的语法会返回普通的React组件Button，它渲染了一个按钮元素，并加上了模板中定义的样式。先创建唯一的类名，再将它加到元素上，最后向页面文档头部注入相应的样式。至此，样式生效了。</p><p>渲染的组件如下所示：</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;button <span class="class"><span class="keyword">class</span></span>=<span class="string">"kYvFOg"</span>&gt;Click it&lt;<span class="regexp">/button&gt;</span></span><br></pre></td></tr></table></figure><p>页面上添加的样式如下：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.kYvFOg</span> &#123;</span><br><span class="line">  <span class="attribute">background-color</span>: blue;</span><br><span class="line">  <span class="attribute">color</span>: <span class="number">#fff</span>;</span><br><span class="line">  <span class="attribute">padding</span>: <span class="number">10px</span> <span class="number">20px</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个库的优点如下在于支持几乎所有的css特性。比如，它支持<code>SASS</code>风格的伪类语法：</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> Button = styled.button<span class="string">`</span></span><br><span class="line"><span class="string">  background-color: blue;</span></span><br><span class="line"><span class="string">  color: #fff;</span></span><br><span class="line"><span class="string">  padding: 10px 20px;</span></span><br><span class="line"><span class="string">  &amp;:hover &#123;</span></span><br><span class="line"><span class="string">    background-color: #fff;</span></span><br><span class="line"><span class="string">    color: blue;</span></span><br><span class="line"><span class="string">  &#125;</span></span><br><span class="line"><span class="string">`</span></span><br></pre></td></tr></table></figure><p>它也支持媒体查询：</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> Button = styled.button<span class="string">`</span></span><br><span class="line"><span class="string">  background-color: blue;</span></span><br><span class="line"><span class="string">  color: #fff;</span></span><br><span class="line"><span class="string">  padding: 10px 20px;</span></span><br><span class="line"><span class="string">  &amp;:hover &#123;</span></span><br><span class="line"><span class="string">    background-color: #fff;</span></span><br><span class="line"><span class="string">    color: blue;</span></span><br><span class="line"><span class="string">  &#125;</span></span><br><span class="line"><span class="string">  @media (max-width: 480px) &#123;</span></span><br><span class="line"><span class="string">    padding: 10px 10px;</span></span><br><span class="line"><span class="string">  &#125;</span></span><br><span class="line"><span class="string">`</span></span><br></pre></td></tr></table></figure><p>它还可以很方便地覆盖样式，并设置不同属性来多次复用该组件。当你使用了形如<code>antd</code>之类的UI库，并希望自定义一些样式时，这个优点会非常明显。</p><h2 id="结尾"><a href="#结尾" class="headerlink" title="结尾"></a>结尾</h2><p><em>CSS in or not in js ? this is a question.</em></p><p>我觉得没有绝对的最佳实践，只有在工程迭代的过程中，不停的找寻最适合工程、最适合团队的方案，这才是最明智的选择。</p><h2 id="参考文献："><a href="#参考文献：" class="headerlink" title="参考文献："></a>参考文献：</h2><ul><li>《React设计模式与最佳实践》第七章</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;http://img1.juimg.com/180124/330595-1P124141G060.jpg&quot; alt=&quot;http://img1.juimg.com/180124/330595-1P124141G060.jpg&quot;&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;React中的css到底该怎么写？这一直是个饱受争论的话题。本文将结合React CSS的发展史，分别叙述CSS in js与CSS module两种风格中的最佳实践。&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="个人原创" scheme="http://1eeing.github.io/categories/%E4%B8%AA%E4%BA%BA%E5%8E%9F%E5%88%9B/"/>
    
    
      <category term="React" scheme="http://1eeing.github.io/tags/React/"/>
    
      <category term="React最佳实践系列" scheme="http://1eeing.github.io/tags/React%E6%9C%80%E4%BD%B3%E5%AE%9E%E8%B7%B5%E7%B3%BB%E5%88%97/"/>
    
  </entry>
  
  <entry>
    <title>带你走进Mobx的原理</title>
    <link href="http://1eeing.github.io/2019/03/15/Mobx%E5%8E%9F%E7%90%86/"/>
    <id>http://1eeing.github.io/2019/03/15/Mobx原理/</id>
    <published>2019-03-14T16:24:01.164Z</published>
    <updated>2019-03-14T16:27:41.632Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://img.alicdn.com/imgextra/i3/69942425/O1CN01TRJN9m1TmgxoSdgls_!!69942425.png" alt="https://img.alicdn.com/imgextra/i3/69942425/O1CN01TRJN9m1TmgxoSdgls_!!69942425.png"></p><blockquote><p>Mobx相信大家都听过，也有部分同学用过，在状态管理界，和Redux同日争辉。在本文中，将通过介绍Mobx的核心概念、设计原则及问答形式的方式，带大家走进Mobx的世界，一窥其中的原理。</p></blockquote><a id="more"></a><h1 id="核心概念"><a href="#核心概念" class="headerlink" title="核心概念"></a>核心概念</h1><h2 id="可观察状态（Observable-state）"><a href="#可观察状态（Observable-state）" class="headerlink" title="可观察状态（Observable state）"></a>可观察状态（Observable state）</h2><p>状态是驱动应用的数据。通常有像待办事项列表这样的领域特定状态，还有像当前已选元素的视图状态。记住，状态就像是有数据的excel表格。</p><h2 id="衍生（Derivations）"><a href="#衍生（Derivations）" class="headerlink" title="衍生（Derivations）"></a>衍生（Derivations）</h2><p>任何源自状态并且不会再有任何进一步的相互作用的东西就是衍生。衍生以多种形式存在</p><ul><li>用户界面</li><li>衍生数据，比如剩下的待办事项的数量</li><li>后端集成，比如把变化发送到服务器端</li></ul><p>Mobx区分了两种类型的衍生</p><ul><li>计算值（Computed values），它们是永远可以用纯函数从当前可观察状态中衍生出的值</li><li>反应（Reactions），它们是当状态改变时需要自动发生的副作用，用来连接命令式编程和响应式编程，最终都需要实现I/O操作，例如发送请求，更新页面等。</li></ul><h2 id="动作（Actions）"><a href="#动作（Actions）" class="headerlink" title="动作（Actions）"></a>动作（Actions）</h2><p>动作是任意一段可以改变状态的代码。用户事件，后端数据推送等。</p><p>Mobx中可以显示地定义动作，它可以帮你把代码组织的更清晰。严格模式下，Mobx强制要求只有Action可以修改状态。</p><h1 id="设计原则"><a href="#设计原则" class="headerlink" title="设计原则"></a>设计原则</h1><p>Mobx支持单向数据流，也就是动作改变状态，而状态的改变会更新所有受影响的图。</p><p>Action —&gt; State —&gt; Views</p><p>当状态改变时，所有衍生都会进行原子级的自动更新。因此永远不可能观察到中间值。</p><p>所有衍生默认都是同步更新的。这意味着动作可以在改变状态之后直接可以安全地检查计算值。</p><p>计算值是延迟更新的。任何不在使用状态的计算值将不会更新，直到需要它进行副作用（I/O）操作时。如果视图不再使用，那么它会自动被垃圾回收。</p><p>所有的计算值都应该是纯净的。它们不应该用来改变状态。</p><p><img src="https://img.alicdn.com/imgextra/i3/69942425/O1CN012mrjDL1TmgxpCItDo_!!69942425.png" alt="https://img.alicdn.com/imgextra/i3/69942425/O1CN012mrjDL1TmgxpCItDo_!!69942425.png"></p><h1 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h1><p>重要思想：在运行时才能实现最小、一致地订阅子集</p><p><strong>问：Mobx如何有效地将所有衍生保持在一个一致地状态？</strong><br>答：不缓存数据，在需要时重新计算。Mobx认为这是很高效地，因为Mobx不会计算所有衍生，只会计算确保参与反应的计算。这被称为响应式地。</p><p><strong>问：没有参与反应的衍生呢？</strong><br>答：如果一个衍生没有被激活，它将被按需处理。就像一个普通的getter函数一样，懒衍生如果没有用了，将被简单的垃圾回收。所有computed需要使用纯函数，因为对于纯函数而言，是懒衍生还是直接使用并不重要，在相同的状态下，总是返回相同的结果。</p><p><strong>问：当状态变化时，衍生是如何计算的？</strong><br>答：当重新计算被触发时，衍生函数将被压入到衍生堆栈中。只要计算正在运行，每个被访问的状态都会将自身注册为衍生堆栈最顶层函数的依赖项。当计算值被需要了，如果该值已经处于reactive状态，则该值可以简单最后已知的值，否则它将push自己到衍生堆栈中，切换到reactive模式并开始计算，具体计算过程如下：</p><ol><li><p>可观察值像所有观察者发送过时通知，表明它已经变得陈旧。任何受影响的衍生将以递归的<br>方式将通知传递给其观察者。因此，依赖关系树的一部分将被标记为陈旧。</p></li><li><p>在发送陈旧通知并存储新值后，一个就绪通知将被发送，用于指示该值是否确实发生了变化</p></li><li><p>一旦衍生收到步骤1中每个陈旧通知的就绪通知，它就会知道所有的被观察值都稳定了，于是将<br>开始重新计算。计算就绪和陈旧消息的数量可以确保这一点。</p></li><li><p>如果没有就绪通知指出一个值变化了，衍生将直接告诉自己的观察者它已经准备好了且没有变<br>化中的值</p></li></ol><p><strong>同步执行</strong><br>Mobx同步运行所有内容。这有2大好处：</p><ol><li>不可能观察陈旧的衍生</li><li>追踪堆栈和调试变得简单</li></ol><p>Mobx还提供事务机制。事务推迟所有就绪通知，直到事务块执行完成后，同步运行和更新所有内容。</p><p><img src="https://img.alicdn.com/imgextra/i3/69942425/O1CN01mjwTYc1TmgxqJXTJP_!!69942425.png" alt="https://img.alicdn.com/imgextra/i3/69942425/O1CN01mjwTYc1TmgxqJXTJP_!!69942425.png"></p><h1 id="对比Redux"><a href="#对比Redux" class="headerlink" title="对比Redux"></a>对比Redux</h1><ol><li>Redux将数据保存在单一store中，Mobx将数据保存在分散的多个store中</li><li>Redux需要手动处理变化后的操作，Mobx使用observable保存数据，数据变化后自动处理响应的操作</li><li>Redux使用不可变状态，不能直接去修改它，而是应该使用纯函数返回一个新的状态；Mobx中的状态是可以直接修改的</li></ol><h1 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h1><ul><li>demo示例：<a href="https://github.com/mobxjs/mobx-react-boilerplate" target="_blank" rel="noopener">https://github.com/mobxjs/mobx-react-boilerplate</a></li><li>深入理解Mobx：<a href="https://hackernoon.com/becoming-fully-reactive-an-in-depth-explanation-of-mobservable-55995262a254" target="_blank" rel="noopener">https://hackernoon.com/becoming-fully-reactive-an-in-depth-explanation-of-mobservable-55995262a254</a></li><li>Mobx官方文档：<a href="https://cn.mobx.js.org/" target="_blank" rel="noopener">https://cn.mobx.js.org/</a></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;https://img.alicdn.com/imgextra/i3/69942425/O1CN01TRJN9m1TmgxoSdgls_!!69942425.png&quot; alt=&quot;https://img.alicdn.com/imgextra/i3/69942425/O1CN01TRJN9m1TmgxoSdgls_!!69942425.png&quot;&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;Mobx相信大家都听过，也有部分同学用过，在状态管理界，和Redux同日争辉。在本文中，将通过介绍Mobx的核心概念、设计原则及问答形式的方式，带大家走进Mobx的世界，一窥其中的原理。&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="深入学习" scheme="http://1eeing.github.io/categories/%E6%B7%B1%E5%85%A5%E5%AD%A6%E4%B9%A0/"/>
    
    
      <category term="深入学习" scheme="http://1eeing.github.io/tags/%E6%B7%B1%E5%85%A5%E5%AD%A6%E4%B9%A0/"/>
    
      <category term="React" scheme="http://1eeing.github.io/tags/React/"/>
    
      <category term="Mobx" scheme="http://1eeing.github.io/tags/Mobx/"/>
    
  </entry>
  
  <entry>
    <title>【译】深入理解Mobx</title>
    <link href="http://1eeing.github.io/2019/03/08/%E3%80%90%E8%AF%91%E3%80%91%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Mobx/"/>
    <id>http://1eeing.github.io/2019/03/08/【译】深入理解Mobx/</id>
    <published>2019-03-07T17:50:56.573Z</published>
    <updated>2019-03-14T16:27:55.435Z</updated>
    
    <content type="html"><![CDATA[<p><img src="http://img0.imgtn.bdimg.com/it/u=1114646324,2521366840&amp;fm=26&amp;gp=0.jpg" alt="http://img0.imgtn.bdimg.com/it/u=1114646324,2521366840&amp;fm=26&amp;gp=0.jpg"></p><p>首先，先让我们看一下Mobx的核心概念。</p><ol><li><p><strong>可观察状态(Observable state)。</strong><br>任何可以变异且可以作为计算值源的值都是state。Mobx可以开箱即用地使绝大多数类型的值（基本类型，数组，类，对象）变成可观察的（甚至深度观察）。</p></li><li><p><strong>计算值(Computed values)。</strong><br>任何可观察的值可以使用纯函数计算得出任何值。计算值的范围可以从简单的字符串到复杂的对象甚至dom操作上。计算值会懒惰地对状态变化做出反应。</p></li><li><p><strong>反应(Reactions)。</strong><br>反应有点类似于计算值，但是它不产生新值，而是作为桥梁衔接了响应式编程和命令式编程，产生一个副作用（I/O操作），例如打印到控制台，发送网络请求，更新dom树等。</p></li><li><p><strong>操作(Actions)。</strong><br>操作是改变状态(state)的主要手段。操作不是状态改变后的反应，是改变的来源，例如用户事件或web-socket连接，用以改变可观察的状态。</p></li></ol><a id="more"></a><blockquote><p>计算值和反应在本文章的后续中都称为衍生(derivations)。到目前为止，这听起来可能有点学术性，所以，我们让它具体点。在excel电子表格中，所有具有值的数据单元格都是可观察状态的，公式和图标是可以从数据单元格和其他公式衍生的计算值。在屏幕上绘制数据单元格或公式的结果就是一个反应(reaction)，改变数据单元格或公式就是一个操作(action)</p></blockquote><p>下面这个例子结合了Mobx和React，并且包含了以上4个概念：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">  @observable firstName = <span class="string">"Michel"</span>;</span><br><span class="line">  @observable lastName = <span class="string">"Weststrate"</span>;</span><br><span class="line">  @observable nickName;</span><br><span class="line">  </span><br><span class="line">  @computed get fullName() &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.firstName + <span class="string">" "</span> + <span class="keyword">this</span>.lastName;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> michel = <span class="keyword">new</span> Person();</span><br><span class="line"></span><br><span class="line"><span class="comment">// Reaction: log the profile info whenever it changes</span></span><br><span class="line">autorun(<span class="function"><span class="params">()</span> =&gt;</span> <span class="built_in">console</span>.log(person.nickName ? person.nickName : person.fullName));</span><br><span class="line"></span><br><span class="line"><span class="comment">// Example React component that observes state</span></span><br><span class="line"><span class="keyword">const</span> profileView = observer(<span class="function"><span class="params">props</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">if</span> (props.person.nickName)</span><br><span class="line">    <span class="keyword">return</span> &lt;div&gt;&#123;props.person.nickName&#125;&lt;/div&gt;</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">    <span class="keyword">return</span> &lt;div&gt;&#123;props.person.fullName&#125;&lt;/div&gt;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// Action:</span></span><br><span class="line">setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> michel.nickName = <span class="string">"mweststrate"</span>, <span class="number">5000</span>)</span><br><span class="line"></span><br><span class="line">React.render(React.createElement(profileView, &#123; <span class="attr">person</span>: michel &#125;), <span class="built_in">document</span>.body);</span><br><span class="line"><span class="comment">// This snippet is runnable in jsfiddle: https://jsfiddle.net/mweststrate/049r6jox/</span></span><br><span class="line">view rawprofile.jsx hosted <span class="keyword">with</span> ❤ by GitHub</span><br></pre></td></tr></table></figure><p>我们可以画一张依赖图：</p><p><img src="https://cdn-images-1.medium.com/max/1600/1*YPlKuWsPrVbhxUN7YhyTpg.png" alt="https://cdn-images-1.medium.com/max/1600/1*YPlKuWsPrVbhxUN7YhyTpg.png"><br>Figure 1：profileView组件的依赖关系树。fullName处于reactive mode，主动观察firstName和lastName</p><p>这个应用中，状态由可观察状态捕获（蓝色图标）。绿色的fullName是计算值，由可观察状态firstName和lastName自动衍生得出。同样，profileView由nickName和fullName衍生得出。profileView将通过产生副作用来响应状态更改——它更新React组件树。</p><p>当使用Mobx时，依赖关系树被最低限度定义。举个例子，一旦profileView的有了nickName，且渲染不再受fullName的值的影响，也不受firstName和lastName的影响，那么他们之间所有的观察者关系将被清除，Mobx将自动的简化依赖树，如下图：</p><p><img src="https://cdn-images-1.medium.com/max/1600/1*SXiDJ_mQ0ctEj2QEurLpqA.png" alt="https://cdn-images-1.medium.com/max/1600/1*SXiDJ_mQ0ctEj2QEurLpqA.png"><br>Figure 2：当profileView具有nickName时的依赖关系树，与Figure 1相反，fullName现在处于lazy mode，且不再观察firstName和lastName</p><p>Mobx总是使用最小化计算次数去产生状态。接下来，我将介绍用于实现此目标的几种策略，但在深入了解计算值和反应如何与状态同步之前，让我们首先描述Mobx背后的原理：</p><p><strong>对状态变化做出反应总是比对状态变化做出动作要好。（Reacting to state changes is always better then acting on state changes.）</strong></p><p>应用程序响应状态更改的必要操作是通常会创建或更新一些值，大多数的操作(actions)管理着本地缓存。dom更新、批量更新值、请求后端，这些都可以被认为变相地使缓存失效。要确保这些缓存保持同步，你需要订阅(subscribe)未来的状态更改，以便再次触发你的操作。</p><p>但是观察者模式有一个基本的问题：当你的应用变大时，你可能会犯错，比如依然订阅不再使用的值或忘记订阅一些值。</p><p>像flux风格的订阅很容易出现这种超额订阅的情况。使用React时，你可以通过在渲染中打印来判断你的组件是否被超额订阅了。Mobx会将打印出的超额订阅数减少到0。这个想法很简单但违反直觉：订阅越多，重新计算越少。Mobx为你管理数千个观察者，你可以有效地权衡内存的CPU周期。</p><p>超额订阅也以非常微妙的形式存在。如果你订阅了使用的数据，但并未在所有条件下订阅，那么你依然需要超额订阅。例如，如果profileView组件订阅了fullName，并且profileView有nickName，这就将超额订阅。因此Mobx设计背后的一个重要原则是：</p><p><strong>在运行时才能实现最小、一致地订阅子集（A minimal, consistent set of subscriptions can only be achieved if subscriptions are determined at run-time）。</strong></p><p>Mobx背后的第二个重要思想是，对于任何比TodoMVC更复杂的应用程序，通常需要一个数据图而不是规范化的树，以一种最佳方式存储状态。数据图可以实现参照一致性并避免数据重复，从而保证衍生值永远不会过时。</p><p><strong>Mobx如何有效地将所有衍生保持在一个一致地状态？</strong></p><p>答案是：不缓存，只有在需要时再重新计算衍生。这不是很昂贵吗？Mobx认为不是，反而这是很高效地。原因是Mobx不会运行所有衍生，但确保参与reaction的computed values与可观察状态保持同步。这些衍生被称为响应式的。再次以excel举例：只有当那些被观察着的当前可见或被间接使用的公式发生变化时，才会去重新计算值。</p><p><strong>Lazy versus reactive evaluation</strong></p><p>那么反应没有直接或间接使用的计算呢？你依然可以随时检查计算值的值，如fullName。答案是简单的：如果一个计算不是reactive的，它将被按需处理。就像一个普通的getter函数一样。懒衍生如果没有用了，将被简单的垃圾回收。记住computed values总是需要使用纯函数，因为对于纯函数而言，它是懒衍生还是直接使用并不重要。在相同的可观察状态下，computed values总是给出相同的结果。</p><p><strong>运行计算</strong></p><p>Reaction和Computed values在Mobx中都以相同的方式运行。当重新计算被触发时，该函数将被压入到衍生堆栈中。只要计算正在运行，每个被访问的observable都会将自身注册为衍生堆栈最顶层函数的依赖项。当computed value被需要了，如果该值处于reactive状态，则该值可以简单的是最后已知的值。否则它将push自己到衍生堆栈中，切换到reactive模式并开始计算。</p><p><img src="https://cdn-images-1.medium.com/max/800/1*Pb3Wd14BlXPgqylBN_y-hQ.png" alt="https://cdn-images-1.medium.com/max/800/1*Pb3Wd14BlXPgqylBN_y-hQ.png"><br>Figure 4：profileView执行期间，一些observable state和computed values被观察着。computed values可能重新计算，这会产生依赖关系树，如Figure 1所示。</p><p>当一个计算完成后，将得到在执行期间访问的可观察列表。在profileView的例子中，这个list将只包含nickName或nickName和fullName属性。任何被移除的属性都将不再观察（此时computed values可能会从反应模式返回到惰性模式），任何被添加的可观察属性将被观察，直到下一次计算。例如，将来将更改firstName的值，fullName将会知道自己该被重新计算，从而profileView会重新计算。接下来会详细解释这一过程。</p><p><strong>传播状态变化</strong></p><p><img src="https://cdn-images-1.medium.com/max/800/1*Et95GdR7OeOofl_V0Od4iA.png" alt="https://cdn-images-1.medium.com/max/800/1*Et95GdR7OeOofl_V0Od4iA.png"></p><p>Figure 5：更改值1对依赖关系树的影响。虚线表示将被标记为旧的观察者。数字表示计算的顺序。</p><p>衍生将自动对状态变化做出反应。所有反应同步发生，更重要的是无瑕疵。修改可观察值时，将执行以下算法：</p><ol><li><p>可观察值向所有观察者发送过时通知，表明它已变得陈旧。任何受影响的computed values将以递归方式将通知传递给其观察者。因此，依赖关系树的一部分将被标记为陈旧。以Figure 5为例，当值1改变时观察者将变成陈旧的，并用橘色虚线标记。所有的衍生都可能被变化的值影响。</p></li><li><p>在发送陈旧通知并且存储新值之后，一个就绪通知将被发送。用于指示该值是否确实发生了变化。</p></li><li><p>一旦衍生收到步骤1中收到的每个陈旧通知的就绪通知，它就会知道所有的被观察值都稳定了，于是将开始重新计算。计算 就绪/陈旧 消息的数量将确保这一点。例如，计算值4将仅在计算值3变得稳定后重新计算。</p></li><li><p>如果没有就绪消息指出一个值变化了，衍生将直接告诉自己的观察者它已经准备好了且没有变化中的值，否则将重新计算并发送一个就绪消息给自己的观察者。执行顺序如Figure 5所示。注意，如果计算值4重新评估但没有产生新值，则最后一个“-”将永远不会执行。</p></li></ol><p>前两段总结了如何在运行时跟踪可观察值和衍生之间的依赖关系以及变化在衍生中是如何传播的。此时你会发现reaction基本上就是一个始终处于反应模式的computed value。<strong>重点：这个算法可以非常有效地实现而不需要闭包，只需要一堆指针数组。</strong>另外，Mobx还应用了许多其他优化，这些优化超出了本文的范围。</p><p><strong>同步执行</strong></p><p>人们常惊讶于Mobx同步运行所有内容。这有两大好处：第一点是不可能观察陈旧的衍生。因此，在更改影响它的值后，可以立即使用衍生值。第二点是这让追踪堆栈和调试变得简单，它避免了Promise/Async库所特有的无用堆栈跟踪。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">transaction(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">  michel.firstName = <span class="string">"Mich"</span>;</span><br><span class="line">  michel.lastName = <span class="string">"W."</span>;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>(事务示例，它确保没有人能追踪到像Michaaa这样的中间值)</p><p>同步执行还引入了对事务的需求。如果立即连续应用几个突变，在应用所有更改后，最好重新评估所有衍生。在transaction中包装action能实现这个目的。事务推迟所有就绪通知，直到事务块执行完成。请注意，事务仍然同步运行和更新所有内容。</p><p>这总结了Mobx最基本的实现细节。这没有涵盖所有内容，但是很高兴你可以组合你的computed value了。通过组合reactive computations，甚至可以自动的将一张数据图转换为另一张数据图并用最少的补丁数保持最新的衍生，这使得实现复杂模式变得简单。</p><p><strong>总结</strong></p><ol><li><p>复杂应用程序的状态最好用图表表示，以实现参考一致性，更接近问题核心的心理模型。</p></li><li><p>不应该使用手动定义的订阅或游标来强制更改状态，这将不可避免的导致由于订阅不足或超额订阅导致的错误。</p></li><li><p>使用运行时分析来确定最小的observer-&gt;observable的关系，这导致了一种计算模型，可以保证在没有观察过期值的情况下运行最小量的衍生。</p></li><li><p>任何不需要实现有效副作用的衍生都可以完全优化。</p></li></ol><p><strong>原文地址</strong><br><a href="https://hackernoon.com/becoming-fully-reactive-an-in-depth-explanation-of-mobservable-55995262a254" target="_blank" rel="noopener">https://hackernoon.com/becoming-fully-reactive-an-in-depth-explanation-of-mobservable-55995262a254</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;http://img0.imgtn.bdimg.com/it/u=1114646324,2521366840&amp;amp;fm=26&amp;amp;gp=0.jpg&quot; alt=&quot;http://img0.imgtn.bdimg.com/it/u=1114646324,2521366840&amp;amp;fm=26&amp;amp;gp=0.jpg&quot;&gt;&lt;/p&gt;
&lt;p&gt;首先，先让我们看一下Mobx的核心概念。&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;p&gt;&lt;strong&gt;可观察状态(Observable state)。&lt;/strong&gt;&lt;br&gt;任何可以变异且可以作为计算值源的值都是state。Mobx可以开箱即用地使绝大多数类型的值（基本类型，数组，类，对象）变成可观察的（甚至深度观察）。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;strong&gt;计算值(Computed values)。&lt;/strong&gt;&lt;br&gt;任何可观察的值可以使用纯函数计算得出任何值。计算值的范围可以从简单的字符串到复杂的对象甚至dom操作上。计算值会懒惰地对状态变化做出反应。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;strong&gt;反应(Reactions)。&lt;/strong&gt;&lt;br&gt;反应有点类似于计算值，但是它不产生新值，而是作为桥梁衔接了响应式编程和命令式编程，产生一个副作用（I/O操作），例如打印到控制台，发送网络请求，更新dom树等。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;strong&gt;操作(Actions)。&lt;/strong&gt;&lt;br&gt;操作是改变状态(state)的主要手段。操作不是状态改变后的反应，是改变的来源，例如用户事件或web-socket连接，用以改变可观察的状态。&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
    
    </summary>
    
      <category term="译文" scheme="http://1eeing.github.io/categories/%E8%AF%91%E6%96%87/"/>
    
    
      <category term="React" scheme="http://1eeing.github.io/tags/React/"/>
    
      <category term="Mobx" scheme="http://1eeing.github.io/tags/Mobx/"/>
    
      <category term="译文" scheme="http://1eeing.github.io/tags/%E8%AF%91%E6%96%87/"/>
    
  </entry>
  
  <entry>
    <title>深入了解React之Reconciliation</title>
    <link href="http://1eeing.github.io/2019/01/18/Reconciliation/"/>
    <id>http://1eeing.github.io/2019/01/18/Reconciliation/</id>
    <published>2019-01-17T16:31:40.712Z</published>
    <updated>2019-01-17T16:32:46.243Z</updated>
    
    <content type="html"><![CDATA[<h1 id="动机"><a href="#动机" class="headerlink" title="动机"></a>动机</h1><p>在使用React时，在单个时间点钟，可以将render函数视为创建React元素树。在下一个state或props更新时，render函数将返回一个不同的React元素树。然后，React需要弄清楚如何有效地更新UI以匹配最新的树。</p><p>这个算法问题有一些通用的解决方案，既生成将一棵树转换成另一棵树的最小操作次数。然而，现有技术的算法具有O(n^3)的复杂度，其中n是书中元素的数量。简单来说，对比两棵树需要的时间复杂度是O(n^2)，操作一棵树（移动、创建、删除）时需要遍历一次树，因此时间复杂度是O(n^3)。</p><p>如果在React中使用它，显示1000个元素将需要10亿次对比。这消耗太大了。<br>因此，React基于两个假设实现了一个启发式O(n)算法：</p><a id="more"></a><ol><li>不同类型的两个元素将产生不同的树</li><li>可以通过key来指定哪些子元素可以在不同渲染中保持稳定</li></ol><h1 id="diff算法"><a href="#diff算法" class="headerlink" title="diff算法"></a>diff算法</h1><p>在区分两棵树时，React首先会比较两个根元素。根据根元素的类型，行为会有所不同。</p><h2 id="不同类型的元素"><a href="#不同类型的元素" class="headerlink" title="不同类型的元素"></a>不同类型的元素</h2><p>每当根元素具有不同的类型时，React将拆除旧树并从头开始构建新树。从<code>&lt;a&gt;</code>到<code>&lt;img&gt;</code>，或从<code>&lt;Article&gt;</code>到<code>&lt;Comment&gt;</code>，都将导致完全重建。</p><p>在拆除树时，旧dom节点将被销毁。组件实例接收componentWillUnMount()。<br>构建新树时，会将新dom节点插入到dom中。组件实例接收componentWillMount()，然后接收componentDidMount()。与旧树相关联的任何状态都将丢失。</p><p>root下面的任何组件也将被卸载并且其状态被破坏。例如<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&lt;div&gt;</span><br><span class="line">  &lt;Counter /&gt;</span><br><span class="line">&lt;/div&gt;</span><br><span class="line"></span><br><span class="line">&lt;span&gt;</span><br><span class="line">  &lt;Counter /&gt;</span><br><span class="line">&lt;/span&gt;</span><br></pre></td></tr></table></figure></p><p>这会导致旧的<code>&lt;Counter&gt;</code>被破坏，并新建一个。</p><h2 id="相同类型的dom元素"><a href="#相同类型的dom元素" class="headerlink" title="相同类型的dom元素"></a>相同类型的dom元素</h2><p>当比较两个相同类型的React DOM元素时，React查看两者的属性，保持相同的底层dom节点，并仅更新更改的属性。例如：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;div className=&quot;before&quot; title=&quot;stuff&quot; /&gt;</span><br><span class="line"></span><br><span class="line">&lt;div className=&quot;after&quot; title=&quot;stuff&quot; /&gt;</span><br></pre></td></tr></table></figure></p><p>通过比较这两个元素，React知道只修改底层dom节点上的className。</p><p>更新样式时，React也知道只更新已更改的属性。例如：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;div style=&#123;&#123;color: &apos;red&apos;, fontWeight: &apos;bold&apos;&#125;&#125; /&gt;</span><br><span class="line"></span><br><span class="line">&lt;div style=&#123;&#123;color: &apos;green&apos;, fontWeight: &apos;bold&apos;&#125;&#125; /&gt;</span><br></pre></td></tr></table></figure></p><p>在这两个元素之间进行转换时，React知道只修改颜色样式，而不是fontWeight。<br>在处理dom节点之后，React对子节点进行递归。</p><h2 id="相同类型的组件元素"><a href="#相同类型的组件元素" class="headerlink" title="相同类型的组件元素"></a>相同类型的组件元素</h2><p>当组件更新时，实例保持不变，以便在渲染之间保持状态。React更新底层组件实例的props以匹配新元素，并在底层实例上调用componentWillReceiveProps()和componentWillUpdate()。</p><p>接下来，调用render()方法，diff算法开始递归计算前一个结果和新结果</p><h1 id="子节点的递归"><a href="#子节点的递归" class="headerlink" title="子节点的递归"></a>子节点的递归</h1><p>默认情况下，当对dom节点的子节点进行递归时，React会同时迭代两个子节点列表，并在出现差异时生成突变。</p><p>例如，在子节点末尾添加元素时，在两个树之间进行转换效果很好<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&lt;ul&gt;</span><br><span class="line">  &lt;li&gt;first&lt;/li&gt;</span><br><span class="line">  &lt;li&gt;second&lt;/li&gt;</span><br><span class="line">&lt;/ul&gt;</span><br><span class="line"></span><br><span class="line">&lt;ul&gt;</span><br><span class="line">  &lt;li&gt;first&lt;/li&gt;</span><br><span class="line">  &lt;li&gt;second&lt;/li&gt;</span><br><span class="line">  &lt;li&gt;third&lt;/li&gt;</span><br><span class="line">&lt;/ul&gt;</span><br></pre></td></tr></table></figure></p><p>React将对比两个<code>&lt;li&gt;first&lt;/li&gt;</code>和两个<code>&lt;li&gt;second&lt;/li&gt;</code>，然后插入<code>&lt;li&gt;third&lt;/li&gt;</code>。</p><p>如果你在开头插入一个元素，那会有糟糕的表现。例如<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&lt;ul&gt;</span><br><span class="line">  &lt;li&gt;Duke&lt;/li&gt;</span><br><span class="line">  &lt;li&gt;Villanova&lt;/li&gt;</span><br><span class="line">&lt;/ul&gt;</span><br><span class="line"></span><br><span class="line">&lt;ul&gt;</span><br><span class="line">  &lt;li&gt;Connecticut&lt;/li&gt;</span><br><span class="line">  &lt;li&gt;Duke&lt;/li&gt;</span><br><span class="line">  &lt;li&gt;Villanova&lt;/li&gt;</span><br><span class="line">&lt;/ul&gt;</span><br></pre></td></tr></table></figure></p><p>React将改变每个children，而不是意识到它可以保持<code>&lt;li&gt;Duke&lt;/li&gt;</code>和<code>&lt;li&gt;Villanova&lt;/li&gt;</code>不变。这种低效率可能是一个问题。</p><h1 id="keys"><a href="#keys" class="headerlink" title="keys"></a>keys</h1><p>为了解决这个问题，React支持一个key属性。当children有key时，React使用key来匹配旧树和新树中的children。例如，在上面的低效示例中添加一个key可以使树转换有效：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&lt;ul&gt;</span><br><span class="line">  &lt;li key=&quot;2015&quot;&gt;Duke&lt;/li&gt;</span><br><span class="line">  &lt;li key=&quot;2016&quot;&gt;Villanova&lt;/li&gt;</span><br><span class="line">&lt;/ul&gt;</span><br><span class="line"></span><br><span class="line">&lt;ul&gt;</span><br><span class="line">  &lt;li key=&quot;2014&quot;&gt;Connecticut&lt;/li&gt;</span><br><span class="line">  &lt;li key=&quot;2015&quot;&gt;Duke&lt;/li&gt;</span><br><span class="line">  &lt;li key=&quot;2016&quot;&gt;Villanova&lt;/li&gt;</span><br><span class="line">&lt;/ul&gt;</span><br></pre></td></tr></table></figure></p><p>现在React知道具有key2014的元素时新元素，并且2015和2016元素刚刚移动。</p><p>在实践中，找到key通常不难。它可能来自你的数据：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;li key=&#123;item.id&#125;&gt;&#123;item.name&#125;&lt;/li&gt;</span><br></pre></td></tr></table></figure></p><p>如果不是这种情况，你可以向模型添加新的id属性，或者对内容的某些部分进行hash编码以生存密钥。关键只需要在其兄弟姐妹中独一无二，而不是全树独一无二。</p><p>实在不行，可以将数组中的项目索引作为key。如果项目从不重新排序，这可以很好的工作，但重新排序将很慢。</p><p>当索引用作key时，重新排序也会导致组件状态出现问题。组件实例根据key进行更新和重用。如果key是索引，则移动项目会更改它。因此，诸如非受控组件的状态可能会以意想不到的方式混淆和更新。</p><h1 id="权衡"><a href="#权衡" class="headerlink" title="权衡"></a>权衡</h1><p>牢记协调算法的实现细节非常重要。React可以在每个动作上重新呈现整个应用程序，而最终结果是一样的。为了清楚可见，在这种情况下重新渲染意味着为所有组件调用渲染，但这并不意味着React将卸载并重新安装它们。它只会按照前面章节中规定的规则应用差异。</p><p>在当前的实现中，可以表明一个事实，即子树在其兄弟节点中移动，但你无法告知其移动到哪。该算法会重新渲染整个子树。</p><p>因为React依赖于启发式方法，如果不满足它们背后的假设，性能将受到影响。</p><ol><li>该算法不会尝试匹配不同组件类型的子树。如果你发现自己在具有非常相似输出的两种组件类型之间交替，则可能需要使其成为相同类型。</li><li>key应该是稳定的，可预测的和独特的。不稳定的key将导致许多组件实例和dom节点被不必要地重建，这可能导致性能下降和并丢失子组件的状态。</li></ol>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;动机&quot;&gt;&lt;a href=&quot;#动机&quot; class=&quot;headerlink&quot; title=&quot;动机&quot;&gt;&lt;/a&gt;动机&lt;/h1&gt;&lt;p&gt;在使用React时，在单个时间点钟，可以将render函数视为创建React元素树。在下一个state或props更新时，render函数将返回一个不同的React元素树。然后，React需要弄清楚如何有效地更新UI以匹配最新的树。&lt;/p&gt;
&lt;p&gt;这个算法问题有一些通用的解决方案，既生成将一棵树转换成另一棵树的最小操作次数。然而，现有技术的算法具有O(n^3)的复杂度，其中n是书中元素的数量。简单来说，对比两棵树需要的时间复杂度是O(n^2)，操作一棵树（移动、创建、删除）时需要遍历一次树，因此时间复杂度是O(n^3)。&lt;/p&gt;
&lt;p&gt;如果在React中使用它，显示1000个元素将需要10亿次对比。这消耗太大了。&lt;br&gt;因此，React基于两个假设实现了一个启发式O(n)算法：&lt;/p&gt;
    
    </summary>
    
      <category term="深入学习" scheme="http://1eeing.github.io/categories/%E6%B7%B1%E5%85%A5%E5%AD%A6%E4%B9%A0/"/>
    
    
      <category term="深入学习" scheme="http://1eeing.github.io/tags/%E6%B7%B1%E5%85%A5%E5%AD%A6%E4%B9%A0/"/>
    
      <category term="React" scheme="http://1eeing.github.io/tags/React/"/>
    
      <category term="Reconciliation" scheme="http://1eeing.github.io/tags/Reconciliation/"/>
    
  </entry>
  
  <entry>
    <title>深入了解React之Fiber</title>
    <link href="http://1eeing.github.io/2019/01/18/Fiber/"/>
    <id>http://1eeing.github.io/2019/01/18/Fiber/</id>
    <published>2019-01-17T16:29:57.000Z</published>
    <updated>2019-01-17T16:31:26.816Z</updated>
    
    <content type="html"><![CDATA[<h1 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h1><p>React 16种加入的新的react核心算法。也可理解为虚拟堆栈帧。</p><h1 id="Fiber的驱动理念"><a href="#Fiber的驱动理念" class="headerlink" title="Fiber的驱动理念"></a>Fiber的驱动理念</h1><ol><li>在UI中，不必立即应用每个更新，这样做可能会浪费，导致丢帧并降低用户体验</li><li>不同类型的更新具有不同的优先级，动画更新需要比数据存储更新更快地完成</li><li>基于推送的方法需要开发者决定如何安排工作，基于拉取的方法允许框架变得聪明并为你做出决策</li></ol><a id="more"></a><h1 id="什么是fiber（重要）"><a href="#什么是fiber（重要）" class="headerlink" title="什么是fiber（重要）"></a>什么是fiber（重要）</h1><p>使React能够实现调度（scheduling），具体如下</p><ol><li>暂停工作，稍后再回来</li><li>为不同类型的工作分配优先权</li><li>重用以前完成的工作</li><li>如果不再需要，则中止工作</li></ol><p>为了做到这一点，我们首先需要一种将工作分解为单元的方法，这种方法，就可以称之为Fiber。<br>在处理UI时，问题在于如果同时执行太多工作，则可能导致动画丢帧并且看起来不稳定。更重要的是，如果它被更新的更新取代，那么其中一些工作可能不是必要的。这是ui组件和funtion之间的差异，因为组件比一般的功能有更多特定的关注点。</p><p>有2个api实现了有助于解决这个问题的api</p><ul><li>requestIdleCallback，调度在空闲期间调用的低优先级函数</li><li>requestAnimationFrame，调度在下一个动画帧上调用的高优先级函数</li></ul><p>所以，为了使用这些API，需要一种方法将渲染工作分解为增量单元。如果仅依赖于调用堆栈，它将持续工作直到堆栈为空。</p><p>如果我们可以自定义调用堆栈的行为以优化渲染UI，随意终端调用堆栈并手动操作对战阵，那不是很好吗？这就是React Fiber的目的。</p><p>Fiber是堆栈的重新实现，专门用于React组件，可以将单根fiber视为虚拟堆栈帧。<br>重新实现堆栈的优点是，你可以将堆栈帧保留在内存中，然后想执行的时候就执行它们。这对于实现我们的调度目标至关重要。除了调度之外，手动处理堆栈帧还可以释放并发和错误边界等功能。</p><h1 id="fiber的结构"><a href="#fiber的结构" class="headerlink" title="fiber的结构"></a>fiber的结构</h1><p>fiber是一个javascript对象，里面包含有这些属性</p><h2 id="type和key"><a href="#type和key" class="headerlink" title="type和key"></a>type和key</h2><p>从ReactElements复制过来，用途也一样</p><h2 id="child和sibling"><a href="#child和sibling" class="headerlink" title="child和sibling"></a>child和sibling</h2><p>指向其他的fiber，描述fiber的递归树结构</p><h2 id="return"><a href="#return" class="headerlink" title="return"></a>return</h2><p>返回父fiber</p><h2 id="pendingProps和memoizedProps"><a href="#pendingProps和memoizedProps" class="headerlink" title="pendingProps和memoizedProps"></a>pendingProps和memoizedProps</h2><p>是一个function的参数。在执行开始前，设置pendingProps，在结束时设置memoizedProps。当传入的pendingProps和memoizedProps相等时，表示fiber先前的输出可以重复使用，从而防止不必要的工作。</p><h2 id="pendingWorkPriority"><a href="#pendingWorkPriority" class="headerlink" title="pendingWorkPriority"></a>pendingWorkPriority</h2><p>一个代表fiber工作优先级的数字</p><h2 id="alternate"><a href="#alternate" class="headerlink" title="alternate"></a>alternate</h2><p><strong><em>flush</em></strong><br>将fiber呈现在屏幕上</p><p><strong><em>work-in-process</em></strong><br>未完成的fiber。</p><p>当前fiber的备用是work-in-process<br>work-in-process的替代是当前fiber<br>使用cloneFiber函数创建fiber，而不是总是创建一个新对象，cloneFiber将尝试重用Fiber的备用，如果它存在，最小化分配（最新代码库中没有找到）</p><h2 id="output"><a href="#output" class="headerlink" title="output"></a>output</h2><p>告诉渲染器需要更改的部分</p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;介绍&quot;&gt;&lt;a href=&quot;#介绍&quot; class=&quot;headerlink&quot; title=&quot;介绍&quot;&gt;&lt;/a&gt;介绍&lt;/h1&gt;&lt;p&gt;React 16种加入的新的react核心算法。也可理解为虚拟堆栈帧。&lt;/p&gt;
&lt;h1 id=&quot;Fiber的驱动理念&quot;&gt;&lt;a href=&quot;#Fiber的驱动理念&quot; class=&quot;headerlink&quot; title=&quot;Fiber的驱动理念&quot;&gt;&lt;/a&gt;Fiber的驱动理念&lt;/h1&gt;&lt;ol&gt;
&lt;li&gt;在UI中，不必立即应用每个更新，这样做可能会浪费，导致丢帧并降低用户体验&lt;/li&gt;
&lt;li&gt;不同类型的更新具有不同的优先级，动画更新需要比数据存储更新更快地完成&lt;/li&gt;
&lt;li&gt;基于推送的方法需要开发者决定如何安排工作，基于拉取的方法允许框架变得聪明并为你做出决策&lt;/li&gt;
&lt;/ol&gt;
    
    </summary>
    
      <category term="深入学习" scheme="http://1eeing.github.io/categories/%E6%B7%B1%E5%85%A5%E5%AD%A6%E4%B9%A0/"/>
    
    
      <category term="深入学习" scheme="http://1eeing.github.io/tags/%E6%B7%B1%E5%85%A5%E5%AD%A6%E4%B9%A0/"/>
    
      <category term="React" scheme="http://1eeing.github.io/tags/React/"/>
    
      <category term="Fiber" scheme="http://1eeing.github.io/tags/Fiber/"/>
    
  </entry>
  
  <entry>
    <title>手把手教你用node撸一个图片压缩工具</title>
    <link href="http://1eeing.github.io/2018/10/27/imgMin/"/>
    <id>http://1eeing.github.io/2018/10/27/imgMin/</id>
    <published>2018-10-26T17:22:20.650Z</published>
    <updated>2018-10-26T17:34:30.703Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://tinypng.com/images/social/developer-api.jpg" alt="https://tinypng.com/images/social/developer-api.jpg"></p><blockquote><p>上篇文章中我们提到了用node撸一个简易的爬虫，本次基于上一篇文章中的项目<a href="https://github.com/1eeing/get_picture" target="_blank" rel="noopener">get_picture</a>给大家分享下我是如何用node撸一个图片压缩工具的。</p></blockquote><p><strong>历史</strong>：<br><a href="https://juejin.im/post/5bc717f4f265da0abf7d16d3" target="_blank" rel="noopener">《手把手教你用node撸一个简易的headless爬虫cli工具》</a></p><a id="more"></a><h1 id="tinypng"><a href="#tinypng" class="headerlink" title="tinypng"></a>tinypng</h1><p>依然是先介绍一下工具，本次我们主要用到了 <code>tinypng</code> 这个工具。tinypng是一个主流的图片压缩工具，他可以实现高保真的压缩我们的图片，一般我们可以进入他的官网<a href="https://tinypng.com/" target="_blank" rel="noopener">https://tinypng.com/</a>压缩图片，手动点击上传，但是每次只能压缩20张，这对于追求方便的我们来说肯定是不能满足的。我们需要一次性将所有图片都压缩！</p><p>这怎么办呢？tinypng官网十分的人性化，提供了各种服务端直接调用的接口，我们点开他的<a href="https://tinypng.com/developers/reference" target="_blank" rel="noopener">文档</a>看一看，找到node.js，通过<code>npm i --save tinify</code>安装在我们的项目中，其次可以看到他提供了各种各样的功能，包括<code>压缩图片</code>、<code>resize图片</code>、<code>上传cdn</code>等。我们主要用到了他的<code>压缩图片</code>、<code>验证key</code>、<code>查看已用数</code>。</p><h1 id="目录结构"><a href="#目录结构" class="headerlink" title="目录结构"></a>目录结构</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">|-- Documents</span><br><span class="line">    |-- .gitignore</span><br><span class="line">    |-- README.md</span><br><span class="line">    |-- package.json</span><br><span class="line">    |-- bin</span><br><span class="line">    |   |-- gp</span><br><span class="line">    |-- output</span><br><span class="line">    |   |-- .gitkeeper</span><br><span class="line">    |-- src</span><br><span class="line">        |-- app.js</span><br><span class="line">        |-- clean.js</span><br><span class="line">        |-- imgMin.js</span><br><span class="line">        |-- index.js</span><br><span class="line">        |-- config</span><br><span class="line">        |   |-- default.js</span><br><span class="line">        |-- helper</span><br><span class="line">            |-- questions.js</span><br><span class="line">            |-- regMap.js</span><br><span class="line">            |-- srcToImg.js</span><br><span class="line">            |-- tinify.js</span><br></pre></td></tr></table></figure><p>基于上一个项目，我们新增了两个文件</p><ul><li>/src/imgMin.js。即我们的主文件。</li><li>/src/helper/tinify.js。主要用于操作tinypng的相关API</li></ul><h1 id="主文件"><a href="#主文件" class="headerlink" title="主文件"></a>主文件</h1><p>在主文件中，我们主要用到了<code>node</code>的<code>fs模块</code>。<br>首先我们会判断输入的key是否有效，其次我们会判断该key剩余可用数是不是小于0，如果没问题的话，我们就开始查找检索路径下的所有文件。</p><p><strong>检索路径</strong><br>首先我们会通过<code>fs.stat</code>判断该路径是否是文件夹，如果是，则通过<code>fs.readdir</code>获取当前文件列表，遍历后然后将其传给获取图片方法。注意这边有个坑点，因为我们的操作几乎都是异步操作，所以我一开始也很理所当然的用了forEach来遍历，伪代码如下<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">files.forEach(<span class="keyword">async</span> (file) =&gt; &#123;</span><br><span class="line">  <span class="keyword">await</span> getImg(file);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></p><p>后来发现，这种写法会导致await并不能如我们预期的阻断来执行，而是变成了一个同步的过程（一开始的预期是一张图片压缩输出完才执行第二张，虽然这样会导致很慢。所以后面还是换成了同步压缩），这是因为<code>forEach</code>可以理解为传入一个function，然后在内部执行循环，在循环中执行function并传回index和item，如果传入的是async函数的话，则其实是并行执行了多个匿名async函数自调，因此await无法按照我们预期的来执行。所以该处我们采用<code>for-of</code>循环，伪代码如下<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="keyword">let</span> file <span class="keyword">of</span> files)&#123;</span><br><span class="line">  <span class="keyword">await</span> getImg(file);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p><strong>获取图片</strong><br>在获取图片中，我们依然会通过<code>fs.stat</code>来判断，如果当前文件依然是个文件夹，我们则递归调用<code>findImg</code>检索其下的文件，如果是图片，先判断当前累计图片总数有没有超过剩余数的最大值（如果使用异步压缩，则不需要进行这一步，因为每一次图片处理都是等待上一张图片处理完成后再进行处理；如果是同步压缩，则必须要这一步，否则如果压缩过程中超数量了，会导致整批压缩失败），如果没有超过，则通过调用<code>tinify.js</code>中的<code>imgMin</code>方法开始进行压缩。</p><p><strong>压缩图片</strong><br>在这一步中，我们先通过<code>fs.readFile</code>读取文件内容sourceData，再通过tinypng的API<code>tinify.fromBuffer(sourceData).toBuffer((err, resultData) =&gt; {})</code>方法获取图片压缩后的数据resuleData，最后通过<code>fs.writeFile</code>对原图片进行覆盖。需要注意一点，async/await中，只有遇到await才会等待执行，并且await后面需要跟一个promise对象，因此，我们把<code>readFile</code>、<code>tinify.fromBuffer(sourceData).toBuffer((err, resultData) =&gt; {})</code>、<code>fs.writeFile</code>用promise进行封装。<br>至此，我们的主程序就大功告成了！怎么样，是不是依然非常简单。<br>最后只要在commander中加入我们的新命令就好了。</p><p>/src/imgMin.js代码如下：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> path = <span class="built_in">require</span>(<span class="string">'path'</span>);</span><br><span class="line"><span class="keyword">const</span> fs = <span class="built_in">require</span>(<span class="string">'fs'</span>);</span><br><span class="line"><span class="keyword">const</span> chalk = <span class="built_in">require</span>(<span class="string">'chalk'</span>);</span><br><span class="line"><span class="keyword">const</span> defaultConf = <span class="built_in">require</span>(<span class="string">'./config/default'</span>);</span><br><span class="line"><span class="keyword">const</span> &#123; promisify &#125; = <span class="built_in">require</span>(<span class="string">'util'</span>);</span><br><span class="line"><span class="keyword">const</span> readdir = promisify(fs.readdir);</span><br><span class="line"><span class="keyword">const</span> stat = promisify(fs.stat);</span><br><span class="line"><span class="keyword">const</span> regMap = <span class="built_in">require</span>(<span class="string">'./helper/regMap'</span>);</span><br><span class="line"><span class="keyword">const</span> &#123; validate, leftCount, imgMin &#125; = <span class="built_in">require</span>(<span class="string">'./helper/tinify'</span>);</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ImgMin</span> </span>&#123;</span><br><span class="line">    <span class="keyword">constructor</span>(conf) &#123;</span><br><span class="line">        <span class="keyword">this</span>.conf = <span class="built_in">Object</span>.assign(&#123;&#125;, defaultConf, conf);</span><br><span class="line">        <span class="keyword">this</span>.imgs = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">async</span> isDir(filePath) &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">const</span> stats = <span class="keyword">await</span> stat(filePath);</span><br><span class="line">            <span class="keyword">if</span>(stats.isDirectory())&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (error) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">async</span> findImg(filePath) &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">const</span> isDirectory = <span class="keyword">await</span> <span class="keyword">this</span>.isDir(filePath);</span><br><span class="line">            <span class="keyword">if</span>(!isDirectory)&#123;</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">const</span> files = <span class="keyword">await</span> readdir(filePath);</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">let</span> file <span class="keyword">of</span> files)&#123;</span><br><span class="line">                <span class="comment">// 这里不能用forEach，只能用for循环</span></span><br><span class="line">                <span class="comment">// 加上await，则是一张张异步压缩图片，如果中间出错，则部分成功</span></span><br><span class="line">                <span class="comment">// 不加await，则是同步发起压缩图片请求，异步写入，如果中间出错，则全部失败</span></span><br><span class="line">                <span class="comment">// 这里为了压缩更快，采用同步写法</span></span><br><span class="line"></span><br><span class="line">                <span class="comment">// await this.getImg(file);</span></span><br><span class="line">                <span class="keyword">const</span> fullPath = path.join(filePath, file);</span><br><span class="line">                <span class="keyword">this</span>.getImg(fullPath);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (error) &#123;</span><br><span class="line">            <span class="built_in">console</span>.log(error);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">async</span> getImg(file) &#123;</span><br><span class="line">        <span class="keyword">const</span> stats = <span class="keyword">await</span> stat(file);</span><br><span class="line">        <span class="comment">// 如果是文件夹，则递归调用findImg</span></span><br><span class="line">        <span class="keyword">if</span>(stats.isDirectory())&#123;</span><br><span class="line">            <span class="keyword">this</span>.findImg();</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(stats.isFile())&#123;</span><br><span class="line">            <span class="keyword">if</span>(regMap.isTinyPic.test(file))&#123;</span><br><span class="line">                <span class="keyword">this</span>.imgs ++;</span><br><span class="line">                <span class="keyword">const</span> left = leftCount();</span><br><span class="line">                <span class="comment">// 剩余数判断，解决同步时剩余数不足导致的全部图片压缩失败问题</span></span><br><span class="line">                <span class="keyword">if</span>(<span class="keyword">this</span>.imgs &gt; left || left &lt; <span class="number">0</span>)&#123;</span><br><span class="line">                    <span class="built_in">console</span>.log(chalk.red(<span class="string">`当前key的可用剩余数不足！<span class="subst">$&#123;file&#125;</span> 压缩失败！`</span>));</span><br><span class="line">                    <span class="keyword">return</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">await</span> imgMin(file);</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="built_in">console</span>.log(chalk.red(<span class="string">`不支持的文件格式 <span class="subst">$&#123;file&#125;</span>`</span>));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">async</span> start() &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">const</span> isValidated = <span class="keyword">await</span> validate(<span class="keyword">this</span>.conf.key);</span><br><span class="line">            <span class="keyword">if</span>(!isValidated)&#123;</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">const</span> filePath = <span class="keyword">this</span>.conf.imgMinPath;</span><br><span class="line">            <span class="keyword">await</span> <span class="keyword">this</span>.findImg(filePath);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (error) &#123;</span><br><span class="line">            <span class="built_in">console</span>.log(error);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">module</span>.exports = ImgMin;</span><br></pre></td></tr></table></figure></p><p>/src/helper/tinify.js代码如下：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> fs = <span class="built_in">require</span>(<span class="string">'fs'</span>);</span><br><span class="line"><span class="keyword">const</span> tinify = <span class="built_in">require</span>(<span class="string">'tinify'</span>);</span><br><span class="line"><span class="keyword">const</span> chalk = <span class="built_in">require</span>(<span class="string">'chalk'</span>);</span><br><span class="line"><span class="keyword">const</span> &#123; promisify &#125; = <span class="built_in">require</span>(<span class="string">'util'</span>);</span><br><span class="line"><span class="keyword">const</span> readFile = promisify(fs.readFile);</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">setKey</span>(<span class="params">key</span>) </span>&#123;</span><br><span class="line">    tinify.key = key;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">validate</span>(<span class="params">key</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(chalk.green(<span class="string">'正在认证tinyPng的key...'</span>));</span><br><span class="line">    setKey(key);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="params">resolve</span> =&gt;</span> &#123;</span><br><span class="line">        tinify.validate(<span class="function">(<span class="params">err</span>) =&gt;</span> &#123;</span><br><span class="line">            <span class="keyword">if</span>(err)&#123;</span><br><span class="line">                <span class="built_in">console</span>.log(err);</span><br><span class="line">                <span class="keyword">return</span> resolve(<span class="literal">false</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="built_in">console</span>.log(chalk.green(<span class="string">'认证成功！'</span>));</span><br><span class="line">            <span class="keyword">const</span> left = leftCount();</span><br><span class="line">            <span class="keyword">if</span>(left &lt;= <span class="number">0</span>)&#123;</span><br><span class="line">                <span class="built_in">console</span>.log(chalk.red(<span class="string">'当前key的剩余可用数已用尽，请更换key重试！'</span>));</span><br><span class="line">                <span class="keyword">return</span> resolve(<span class="literal">false</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="built_in">console</span>.log(chalk.green(<span class="string">`当前key剩余可用数为 <span class="subst">$&#123;left&#125;</span>`</span>));</span><br><span class="line">            resolve(<span class="literal">true</span>);</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">compressionCount</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> tinify.compressionCount;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">leftCount</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">const</span> total = <span class="number">500</span>;</span><br><span class="line">    <span class="keyword">return</span> total - <span class="built_in">Number</span>(compressionCount());</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">writeFilePromise</span>(<span class="params">file, content, cb</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">        fs.writeFile(file, content, (err) =&gt; &#123;</span><br><span class="line">            <span class="keyword">if</span>(err)&#123;</span><br><span class="line">                <span class="keyword">return</span> reject(err);</span><br><span class="line">            &#125;</span><br><span class="line">            cb &amp;&amp; cb();</span><br><span class="line">            resolve();</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">toBufferPromise</span>(<span class="params">sourceData</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">        tinify.fromBuffer(sourceData).toBuffer(<span class="function">(<span class="params">err, resultData</span>) =&gt;</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (err) &#123;</span><br><span class="line">                <span class="keyword">return</span> reject(err);</span><br><span class="line">            &#125;</span><br><span class="line">            resolve(resultData);</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">imgMin</span>(<span class="params">img</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(chalk.blue(<span class="string">`开始压缩图片 <span class="subst">$&#123;img&#125;</span>`</span>));</span><br><span class="line">        <span class="keyword">const</span> sourceData = <span class="keyword">await</span> readFile(img);</span><br><span class="line">        <span class="keyword">const</span> resultData = <span class="keyword">await</span> toBufferPromise(sourceData);</span><br><span class="line">        <span class="keyword">await</span> writeFilePromise(img, resultData, () =&gt; <span class="built_in">console</span>.log(chalk.green(<span class="string">`图片压缩成功 <span class="subst">$&#123;img&#125;</span>`</span>)));</span><br><span class="line">    &#125; <span class="keyword">catch</span> (error) &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(error);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="built_in">module</span>.exports = &#123; validate, compressionCount, leftCount, imgMin &#125;;</span><br></pre></td></tr></table></figure></p><p><strong>命令行工具</strong><br>在index.js中，我们加入以下代码<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">program</span><br><span class="line">    .command(<span class="string">'imgMin'</span>)</span><br><span class="line">    .alias(<span class="string">'p'</span>)</span><br><span class="line">    .option(<span class="string">'-k, --key [key]'</span>, <span class="string">`Tinypng's key, Required`</span>)</span><br><span class="line">    .option(<span class="string">'-p, --path [path]'</span>, <span class="string">`Compress directory. By default, the /images in the current working directory are taken. </span></span><br><span class="line"><span class="string">    Please enter an absolute path such as /Users/admin/Documents/xx...`</span>)</span><br><span class="line">    .description(<span class="string">'Compress your images by tinypng.'</span>)</span><br><span class="line">    .action(<span class="function"><span class="params">options</span> =&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">let</span> conf = &#123;&#125;;</span><br><span class="line">        <span class="keyword">if</span>(!options.key)&#123;</span><br><span class="line">            <span class="built_in">console</span>.log(chalk.red(<span class="string">`Please enter your tinypng's key by "gp p -k [key]"`</span>));</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        options.key &amp;&amp; (conf.key = options.key);</span><br><span class="line">        options.path &amp;&amp; (conf.imgMinPath = options.path);</span><br><span class="line">        <span class="keyword">const</span> imgMin = <span class="keyword">new</span> ImgMin(conf);</span><br><span class="line">        imgMin.start();</span><br><span class="line">    &#125;);</span><br></pre></td></tr></table></figure></p><p>commander具体的用法本章就不再重复了，相信有心的同学通过上章的学习已经掌握基本用法了~</p><p>这样，我们就完成了我们的需求，再将其更新到npm中，我们就可以通过<code>gp p -k [key]</code>来压缩我们的图片。</p><h1 id="项目下载"><a href="#项目下载" class="headerlink" title="项目下载"></a>项目下载</h1><p><code>npm i get_picture -g</code></p><h1 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h1><ul><li>该项目的git链接 <a href="https://github.com/1eeing/get_picture" target="_blank" rel="noopener">https://github.com/1eeing/get_picture</a></li><li>tinypng官网<a href="https://tinypng.com/" target="_blank" rel="noopener">https://tinypng.com/</a></li><li>commander git链接 <a href="https://github.com/tj/commander.js" target="_blank" rel="noopener">https://github.com/tj/commander.js</a></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;https://tinypng.com/images/social/developer-api.jpg&quot; alt=&quot;https://tinypng.com/images/social/developer-api.jpg&quot;&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;上篇文章中我们提到了用node撸一个简易的爬虫，本次基于上一篇文章中的项目&lt;a href=&quot;https://github.com/1eeing/get_picture&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;get_picture&lt;/a&gt;给大家分享下我是如何用node撸一个图片压缩工具的。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;strong&gt;历史&lt;/strong&gt;：&lt;br&gt;&lt;a href=&quot;https://juejin.im/post/5bc717f4f265da0abf7d16d3&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;《手把手教你用node撸一个简易的headless爬虫cli工具》&lt;/a&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="个人原创" scheme="http://1eeing.github.io/categories/%E4%B8%AA%E4%BA%BA%E5%8E%9F%E5%88%9B/"/>
    
    
      <category term="node" scheme="http://1eeing.github.io/tags/node/"/>
    
      <category term="cli" scheme="http://1eeing.github.io/tags/cli/"/>
    
      <category term="commander" scheme="http://1eeing.github.io/tags/commander/"/>
    
      <category term="tinypng" scheme="http://1eeing.github.io/tags/tinypng/"/>
    
  </entry>
  
  <entry>
    <title>手把手教你用node撸一个简易的headless爬虫cli工具</title>
    <link href="http://1eeing.github.io/2018/10/17/get_picture/"/>
    <id>http://1eeing.github.io/2018/10/17/get_picture/</id>
    <published>2018-10-17T12:02:57.359Z</published>
    <updated>2018-10-18T13:54:59.804Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://img.alicdn.com/imgextra/i3/69942425/O1CN011TmgvWMBA2SfqY6_!!69942425.jpg" alt="https://img.alicdn.com/imgextra/i3/69942425/O1CN011TmgvWMBA2SfqY6_!!69942425.jpg"></p><blockquote><p>众所周知，node功能很强大，为前端提供了更多的可能。今天，就跟大家分享一下我是如何用node写一个headless爬虫的</p></blockquote><a id="more"></a><h1 id="用到的工具"><a href="#用到的工具" class="headerlink" title="用到的工具"></a>用到的工具</h1><ul><li>puppeteer</li><li>commander</li><li>inquirer</li><li>chalk</li></ul><p>下面就给大家讲一下这些工具都有什么作用</p><h2 id="puppeteer"><a href="#puppeteer" class="headerlink" title="puppeteer"></a>puppeteer</h2><p>headless爬虫主要靠它。它可以模拟用户打开网页的过程，但是并没有打开网页。写过自动化测试的同学应该对这个会比较熟悉，因为用它爬虫的过程跟自动化测试的过程几乎是一样的。</p><h2 id="commander"><a href="#commander" class="headerlink" title="commander"></a>commander</h2><p>基于node的cli命令行工具。利用它，我们可以很方便的写出各种各样的cli命令。</p><h2 id="inquirer"><a href="#inquirer" class="headerlink" title="inquirer"></a>inquirer</h2><p>交互式命令行工具。什么叫做交互式命令行呢？其实就是类似npm init的时候，问一个问题，我们答一个问题，最后根据答案生成package.json的过程。</p><h2 id="chalk"><a href="#chalk" class="headerlink" title="chalk"></a>chalk</h2><p>这个其实就是一个让我们在命令行中输出的文字更加优美的工具。</p><p>好了，介绍完了工具以后，让我们正式开始我们的项目。</p><h1 id="项目介绍"><a href="#项目介绍" class="headerlink" title="项目介绍"></a>项目介绍</h1><p>首先，要搞清楚我们想要实现的功能。我们想要实现的功能就是，在<strong>命令行</strong>中输入我们想要下载的图片，然后node去网上爬取我们想要的图片（这里就先去百度图片爬吧），直接下载到本地。以及输入一个命令，可以清空我们输出目录中的图片。</p><h1 id="文件目录"><a href="#文件目录" class="headerlink" title="文件目录"></a>文件目录</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">|-- Documents</span><br><span class="line">    |-- .gitignore</span><br><span class="line">    |-- README.md</span><br><span class="line">    |-- package.json</span><br><span class="line">    |-- bin</span><br><span class="line">    |   |-- gp</span><br><span class="line">    |-- output</span><br><span class="line">    |   |-- .gitkeeper</span><br><span class="line">    |-- src</span><br><span class="line">        |-- app.js</span><br><span class="line">        |-- clean.js</span><br><span class="line">        |-- index.js</span><br><span class="line">        |-- config</span><br><span class="line">        |   |-- default.js</span><br><span class="line">        |-- helper</span><br><span class="line">            |-- questions.js</span><br><span class="line">            |-- regMap.js</span><br><span class="line">            |-- srcToImg.js</span><br></pre></td></tr></table></figure><p>以上是项目用到的一个简单的目录结构</p><ul><li><strong>output</strong> 用以存放下载的图片</li><li><strong>bin</strong> cli工具会用到的文件</li><li><strong>src</strong> 代码主要存放于此<ul><li><strong>index.js</strong> 项目入口文件</li><li><strong>app.js</strong> 主要功能文件</li><li><strong>clean.js</strong> 用于清空图片操作的文件</li><li><strong>config</strong> 用于存放一些配置</li><li><strong>helper</strong> 用于存放一些辅助方法的文件</li></ul></li></ul><h1 id="开始项目"><a href="#开始项目" class="headerlink" title="开始项目"></a>开始项目</h1><p><strong>首先我们看一下app.js。</strong></p><p>我们用一个类包裹核心方法，是为了命令行工具可以更方便的调用我们的方法。</p><p>这个类很简单，<code>constructor</code>接收参数，<code>start</code>开启主要流程。<br><code>start</code>方法是一个async函数，因为<code>puppeteer</code>操作浏览器的过程几乎都是异步的。</p><p>接着我们用<code>puppeteer</code>生成page的实例，利用<code>goto</code>方法模拟进入百度图片页面。这时其实就是跟我们真实打开浏览器进入百度图片是一样的，只不过因为我们是headless的，所以我们无法感知打开浏览器的过程。</p><p>然后我们需要设置一下浏览器的宽度（想象一下），不能太大，也不能太小。太大会触发百度反爬虫机制，导致我们爬下来的图片是403或者别的错误。太小会导致爬到的图片非常少。</p><p>接下去我们聚焦搜索框，输入我们想要搜索的关键字（这个关键字呢就是我们在命令行输入的关键字），然后点击搜索。</p><p>等页面加载以后，我们用<code>page.$$eval</code>获取页面上所有<code>class</code>为<code>.main_img</code>的图片（具体规律需要自己去观察），再获取上面的<code>src</code>属性后，将<code>src</code>转为我们本地的图片。</p><p>到这里，app.js的任务就完成了。<br>很简单吧。</p><p>下面是代码。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> puppeteer = <span class="built_in">require</span>(<span class="string">'puppeteer'</span>);</span><br><span class="line"><span class="keyword">const</span> chalk = <span class="built_in">require</span>(<span class="string">'chalk'</span>);</span><br><span class="line"><span class="keyword">const</span> config = <span class="built_in">require</span>(<span class="string">'./config/default'</span>);</span><br><span class="line"><span class="keyword">const</span> srcToImg = <span class="built_in">require</span>(<span class="string">'./helper/srcToImg'</span>);</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">App</span> </span>&#123;</span><br><span class="line">    <span class="keyword">constructor</span>(conf) &#123;</span><br><span class="line">        <span class="comment">//有传入的参数既用传入的参数，没有既用默认的参数</span></span><br><span class="line">        <span class="keyword">this</span>.conf = <span class="built_in">Object</span>.assign(&#123;&#125;, config, conf);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">async</span> start () &#123;</span><br><span class="line">        <span class="comment">//用puppeteer生成一个browser的实例</span></span><br><span class="line">        <span class="comment">//用browser再生成一个page的实例</span></span><br><span class="line">        <span class="keyword">const</span> browser = <span class="keyword">await</span> puppeteer.launch();</span><br><span class="line">        <span class="keyword">const</span> page = <span class="keyword">await</span> browser.newPage();</span><br><span class="line">    </span><br><span class="line">        <span class="comment">//打开搜索引擎，先写死百度</span></span><br><span class="line">        <span class="keyword">await</span> page.goto(<span class="keyword">this</span>.conf.searchPath);</span><br><span class="line">        <span class="built_in">console</span>.log(chalk.green(<span class="string">`go to <span class="subst">$&#123;<span class="keyword">this</span>.conf.searchPath&#125;</span>`</span>));</span><br><span class="line">    </span><br><span class="line">        <span class="comment">//设置窗口大小，过大会引起反爬虫</span></span><br><span class="line">        <span class="keyword">await</span> page.setViewport(&#123;</span><br><span class="line">            width: <span class="number">1920</span>,</span><br><span class="line">            height: <span class="number">700</span></span><br><span class="line">        &#125;);</span><br><span class="line">    </span><br><span class="line">        <span class="comment">//搜索文字输入框聚焦</span></span><br><span class="line">        <span class="keyword">await</span> page.focus(<span class="string">'#kw'</span>);</span><br><span class="line">    </span><br><span class="line">        <span class="comment">//输入要搜索的关键字</span></span><br><span class="line">        <span class="keyword">await</span> page.keyboard.sendCharacter(<span class="keyword">this</span>.conf.keyword);</span><br><span class="line">    </span><br><span class="line">        <span class="comment">//点击搜索</span></span><br><span class="line">        <span class="keyword">await</span> page.click(<span class="string">'.s_search'</span>);</span><br><span class="line">        <span class="built_in">console</span>.log(chalk.green(<span class="string">`get start searching pictures`</span>));</span><br><span class="line">    </span><br><span class="line">        <span class="comment">//页面加载后要做的事</span></span><br><span class="line">        page.on(<span class="string">'load'</span>, <span class="keyword">async</span> () =&gt; &#123;</span><br><span class="line">            <span class="built_in">console</span>.log(chalk.green(<span class="string">`searching pictures done, start fetch...`</span>));</span><br><span class="line">            <span class="comment">//获取所有指定图片的src</span></span><br><span class="line">            <span class="keyword">const</span> srcs = <span class="keyword">await</span> page.$$<span class="built_in">eval</span>(<span class="string">'img.main_img'</span>, pictures =&gt; &#123;</span><br><span class="line">                <span class="keyword">return</span> pictures.map(<span class="function"><span class="params">img</span> =&gt;</span> img.src);</span><br><span class="line">            &#125;);</span><br><span class="line">            <span class="built_in">console</span>.log(chalk.green(<span class="string">`get <span class="subst">$&#123;srcs.length&#125;</span> pictures, start download`</span>));</span><br><span class="line">    </span><br><span class="line">            srcs.forEach(<span class="keyword">async</span> (src) =&gt; &#123;</span><br><span class="line">                <span class="keyword">await</span> page.waitFor(<span class="number">200</span>);</span><br><span class="line">                <span class="keyword">await</span> srcToImg(src, <span class="keyword">this</span>.conf.outputPath);</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="built_in">module</span>.exports = App;</span><br></pre></td></tr></table></figure></p><p><strong>接下来我们看一下，如何把图片的src属性转化为我们本地的图片呢？我们看下helper下的srcToImg.js</strong></p><p>首先，这个模块主要引入了node的<code>http</code>模块、<code>https</code>模块、<code>path</code>模块和<code>fs</code>模块及一些辅助工具，比如正则、将回调函数转化为promise的<code>promisify</code>和将输出更好看的<code>chalk</code>。</p><p>为什么我们要同时引入http和https模块呢？仔细观察百度图片搜索结果中的图片，我们可以发现，既有http的也有https的，所以我们引入两个模块，区分出具体的图片属于哪个就用哪个模块去请求图片。请求了图片以后，我们就用<code>fs</code>模块的<code>createWriteStream</code>方法，将图片存入我们的<code>output</code>目录中。</p><p>如果我们仔细观察了百度搜索结果中的图片的src，我们会发现，除了http和https开头的图片，还有base64的图片，所以我们要对base64的图片也做一下处理。</p><p>跟普通图片一样的处理，先根据<code>src</code>分割出扩展名，再计算出存储的路径和文件名，最后写入调用<code>fs</code>模块的<code>writeFile</code>方法写入文件（这里就简单的用writeFile了）。</p><p>以上，图片就存入本地了。</p><p>代码如下。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> http = <span class="built_in">require</span>(<span class="string">'http'</span>);</span><br><span class="line"><span class="keyword">const</span> https = <span class="built_in">require</span>(<span class="string">'https'</span>);</span><br><span class="line"><span class="keyword">const</span> path = <span class="built_in">require</span>(<span class="string">'path'</span>);</span><br><span class="line"><span class="keyword">const</span> fs = <span class="built_in">require</span>(<span class="string">'fs'</span>);</span><br><span class="line"><span class="keyword">const</span> &#123; promisify &#125; = <span class="built_in">require</span>(<span class="string">'util'</span>);</span><br><span class="line"><span class="keyword">const</span> chalk = <span class="built_in">require</span>(<span class="string">'chalk'</span>);</span><br><span class="line"><span class="keyword">const</span> writeFile = promisify(fs.writeFile);</span><br><span class="line"><span class="keyword">const</span> regMap = <span class="built_in">require</span>(<span class="string">'./regMap'</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> urlToImg = promisify(<span class="function">(<span class="params">url, dir</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">let</span> mod;</span><br><span class="line">    <span class="keyword">if</span>(regMap.isHttp.test(url))&#123;</span><br><span class="line">        mod = http;</span><br><span class="line">    &#125;<span class="keyword">else</span> <span class="keyword">if</span>(regMap.isHttps.test(url))&#123;</span><br><span class="line">        mod = https;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//获取图片的扩展名</span></span><br><span class="line">    <span class="keyword">const</span> ext = path.extname(url);</span><br><span class="line">    <span class="comment">//拼接图片存储的路径和扩展名</span></span><br><span class="line">    <span class="keyword">const</span> file = path.join(dir, <span class="string">`<span class="subst">$&#123;<span class="built_in">parseInt</span>(<span class="built_in">Math</span>.random() * <span class="number">1000000</span>)&#125;</span><span class="subst">$&#123;ext&#125;</span>`</span>);</span><br><span class="line"></span><br><span class="line">    mod.get(url, res =&gt; &#123;</span><br><span class="line">        <span class="comment">//采用stream的形式，比直接写入更快捷</span></span><br><span class="line">        res.pipe(fs.createWriteStream(file)).on(<span class="string">'finish'</span>, () =&gt; &#123;</span><br><span class="line">            <span class="built_in">console</span>.log(file);</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> base64ToImg = <span class="keyword">async</span> (base64Str, dir) =&gt; &#123;</span><br><span class="line">    <span class="keyword">const</span> matchs = base64Str.match(regMap.isBase64);</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">const</span> ext = matchs[<span class="number">1</span>].split(<span class="string">'/'</span>)[<span class="number">1</span>].replace(<span class="string">'jpeg'</span>, <span class="string">'jpg'</span>);</span><br><span class="line">        <span class="keyword">const</span> file = path.join(dir, <span class="string">`<span class="subst">$&#123;<span class="built_in">parseInt</span>(<span class="built_in">Math</span>.random() * <span class="number">1000000</span>)&#125;</span>.<span class="subst">$&#123;ext&#125;</span>`</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">await</span> writeFile(file, matchs[<span class="number">2</span>], <span class="string">'base64'</span>);</span><br><span class="line">        <span class="built_in">console</span>.log(file);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (error) &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(chalk.red(<span class="string">'无法识别的图片'</span>));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="built_in">module</span>.exports = <span class="function">(<span class="params">src, dir</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">if</span>(regMap.isPic.test(src))&#123;</span><br><span class="line">        urlToImg(src, dir);</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        base64ToImg(src, dir);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p><p><strong>我们再看一下如何清空output下的图片呢？</strong><br>这里我们还是用到了<code>node</code>的<code>fs</code>模块，首先利用<code>fs.readdir</code>方法读取<code>output</code>文件夹，然后遍历其下的文件，如果是图片，则调用<code>fs.unlink</code>方法删除它。也很简单，对吧。</p><p>代码如下<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> fs = <span class="built_in">require</span>(<span class="string">'fs'</span>);</span><br><span class="line"><span class="keyword">const</span> regMap = <span class="built_in">require</span>(<span class="string">'./helper/regMap'</span>);</span><br><span class="line"><span class="keyword">const</span> config = <span class="built_in">require</span>(<span class="string">'./config/default'</span>);</span><br><span class="line"><span class="keyword">const</span> cleanPath = config.outputPath;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Clean</span> </span>&#123;</span><br><span class="line">    <span class="keyword">constructor</span>() &#123;&#125;</span><br><span class="line"></span><br><span class="line">    clean() &#123;</span><br><span class="line">        fs.readdir(cleanPath, (err, files) =&gt; &#123;</span><br><span class="line">            <span class="keyword">if</span>(err)&#123;</span><br><span class="line">                <span class="keyword">throw</span> err;</span><br><span class="line">            &#125;</span><br><span class="line">            files.forEach(<span class="function"><span class="params">file</span> =&gt;</span> &#123;</span><br><span class="line">                <span class="keyword">if</span>(regMap.isPic.test(file))&#123;</span><br><span class="line">                    <span class="keyword">const</span> img = <span class="string">`<span class="subst">$&#123;cleanPath&#125;</span>/<span class="subst">$&#123;file&#125;</span>`</span>;</span><br><span class="line">                    fs.unlink(img, (e) =&gt; &#123;</span><br><span class="line">                        <span class="keyword">if</span>(e) &#123;</span><br><span class="line">                            <span class="keyword">throw</span> e;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">            <span class="built_in">console</span>.log(<span class="string">'clean finished'</span>);</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="built_in">module</span>.exports = Clean;</span><br></pre></td></tr></table></figure></p><p><strong>最后我们看一下如何写cli工具呢？</strong><br>首先我们需要在<code>bin</code>目录下新建一个脚本文件<code>gp</code>，如下<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">#! /usr/bin/env node</span><br><span class="line">module.exports = require(&apos;../src/index&apos;);</span><br></pre></td></tr></table></figure></p><p>意思是找到<code>/usr/bin/env</code>下的<code>node</code>来启动第二行的代码</p><p>其次我们需要在package.json里加入一个<code>bin</code>对象，对象下属性名是我们命令的名字，属性是<code>bin</code>下的脚本文件的路径，如下<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">"bin"</span>: &#123;</span><br><span class="line">  <span class="string">"gp"</span>: <span class="string">"bin/gp"</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>接着我们来看下<code>index.js</code><br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> program = <span class="built_in">require</span>(<span class="string">'commander'</span>);</span><br><span class="line"><span class="keyword">const</span> inquirer = <span class="built_in">require</span>(<span class="string">'inquirer'</span>);</span><br><span class="line"><span class="keyword">const</span> pkg = <span class="built_in">require</span>(<span class="string">'../package.json'</span>);</span><br><span class="line"><span class="keyword">const</span> qs = <span class="built_in">require</span>(<span class="string">'./helper/questions'</span>);</span><br><span class="line"><span class="keyword">const</span> App = <span class="built_in">require</span>(<span class="string">'./app'</span>);</span><br><span class="line"><span class="keyword">const</span> Clean = <span class="built_in">require</span>(<span class="string">'./clean'</span>);</span><br><span class="line"></span><br><span class="line">program</span><br><span class="line">    .version(pkg.version, <span class="string">'-v, --version'</span>);</span><br><span class="line"></span><br><span class="line">program</span><br><span class="line">    .command(<span class="string">'search'</span>)</span><br><span class="line">    .alias(<span class="string">'s'</span>)</span><br><span class="line">    .description(<span class="string">'get search pictures what you want.'</span>)</span><br><span class="line">    .action(<span class="keyword">async</span> () =&gt; &#123;</span><br><span class="line">        <span class="keyword">const</span> answers = <span class="keyword">await</span> inquirer.prompt(qs.startQuestions);</span><br><span class="line">        <span class="keyword">const</span> app = <span class="keyword">new</span> App(answers);</span><br><span class="line">        <span class="keyword">await</span> app.start();</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">program</span><br><span class="line">    .command(<span class="string">'clean'</span>)</span><br><span class="line">    .alias(<span class="string">'c'</span>)</span><br><span class="line">    .description(<span class="string">'clean all pictures in directory "output".'</span>)</span><br><span class="line">    .action(<span class="keyword">async</span> () =&gt; &#123;</span><br><span class="line">        <span class="keyword">const</span> answers = <span class="keyword">await</span> inquirer.prompt(qs.confirmClean);</span><br><span class="line">        <span class="keyword">const</span> clean = <span class="keyword">new</span> Clean();</span><br><span class="line">        answers.isRemove &amp;&amp; <span class="keyword">await</span> clean.clean();</span><br><span class="line">    &#125;);</span><br><span class="line">    </span><br><span class="line">program.parse(process.argv);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(process.argv.length &lt; <span class="number">3</span>)&#123;</span><br><span class="line">    program.help();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>我们引入<code>commander</code>和<code>inquirer</code>，<code>program.command</code>方法是为我们生成命令名的，<code>alias</code>是该命令的缩写，<code>description</code>是该命令的描述，<code>action</code>是该命令要做的事情。</p><p>我们首先用<code>command</code>生成了两个命令，<code>search</code>和<code>clean</code>，接着可以看到，我们在<code>action</code>中用了<code>inquirer</code>，<code>inquirer</code>的提问是一个异步的过程，所以我们也一样用了<code>async</code>和<code>await</code>，<code>inquirer</code>接收一个问题数组，里面包含问题的type、name、message和验证方法等，具体的可以参考inquirer的文档。我们这里的问题如下，这里返回了两个数组，一个是用于输入关键字的时候的，一个是用于清空图片时确认的。提问数组中会验证是否有填写关键字，如果没有，则不会继续下一步并提示你该输入关键字，否则就正式开始爬虫流程。删除确认数组就是简单的一个确认，如果确认了，则开始删除图片。最后，用<code>program.parse</code>将命令注入到<code>node</code>的<code>process.argv</code>中，根据命令行有没有输入参数提示help信息。</p><p>至此，我们的程序大功告成。接下去我们只要将我们的程序发布到npm里，就可以让其他人下载来使用了~npm的发布我们这里就不再赘述啦，不清楚的同学网上随便搜一下就ok啦。</p><p><code>src/helper/questions.js</code>如下<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> config = <span class="built_in">require</span>(<span class="string">'../config/default'</span>);</span><br><span class="line"></span><br><span class="line">exports.startQuestions = [</span><br><span class="line">    &#123;</span><br><span class="line">        type: <span class="string">'input'</span>,</span><br><span class="line">        name: <span class="string">'keyword'</span>,</span><br><span class="line">        message: <span class="string">'What pictures do yo want to get ?'</span>,</span><br><span class="line">        validate: <span class="function"><span class="keyword">function</span>(<span class="params">keyword</span>) </span>&#123;</span><br><span class="line">            <span class="keyword">const</span> done = <span class="keyword">this</span>.async();</span><br><span class="line">            <span class="keyword">if</span>(keyword === <span class="string">''</span>)&#123;</span><br><span class="line">                done(<span class="string">'Please enter the keyword to get pictures'</span>);</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            done(<span class="literal">null</span>, <span class="literal">true</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">];</span><br><span class="line"></span><br><span class="line">exports.confirmClean = [</span><br><span class="line">    &#123;</span><br><span class="line">        type: <span class="string">'confirm'</span>,</span><br><span class="line">        name: <span class="string">'isRemove'</span>,</span><br><span class="line">        message: <span class="string">`Do you want to remove all pictures in <span class="subst">$&#123;config.outputPath&#125;</span> ?`</span>,</span><br><span class="line">        <span class="keyword">default</span>: <span class="literal">true</span>,</span><br><span class="line">    &#125;</span><br><span class="line">];</span><br></pre></td></tr></table></figure></p><h1 id="项目下载"><a href="#项目下载" class="headerlink" title="项目下载"></a>项目下载</h1><p><code>npm i get_picture -g</code></p><h1 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h1><ul><li>该项目的git链接 <a href="https://github.com/1eeing/get_picture" target="_blank" rel="noopener">https://github.com/1eeing/get_picture</a></li><li>puppeteer git链接 <a href="https://github.com/GoogleChrome/puppeteer" target="_blank" rel="noopener">https://github.com/GoogleChrome/puppeteer</a></li><li>commander git链接 <a href="https://github.com/tj/commander.js" target="_blank" rel="noopener">https://github.com/tj/commander.js</a></li><li>inquirer git链接 <a href="https://github.com/SBoudrias/Inquirer.js" target="_blank" rel="noopener">https://github.com/SBoudrias/Inquirer.js</a></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;https://img.alicdn.com/imgextra/i3/69942425/O1CN011TmgvWMBA2SfqY6_!!69942425.jpg&quot; alt=&quot;https://img.alicdn.com/imgextra/i3/69942425/O1CN011TmgvWMBA2SfqY6_!!69942425.jpg&quot;&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;众所周知，node功能很强大，为前端提供了更多的可能。今天，就跟大家分享一下我是如何用node写一个headless爬虫的&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="个人原创" scheme="http://1eeing.github.io/categories/%E4%B8%AA%E4%BA%BA%E5%8E%9F%E5%88%9B/"/>
    
    
      <category term="node" scheme="http://1eeing.github.io/tags/node/"/>
    
      <category term="cli" scheme="http://1eeing.github.io/tags/cli/"/>
    
      <category term="commander" scheme="http://1eeing.github.io/tags/commander/"/>
    
      <category term="inquirer" scheme="http://1eeing.github.io/tags/inquirer/"/>
    
      <category term="puppeteer" scheme="http://1eeing.github.io/tags/puppeteer/"/>
    
      <category term="爬虫" scheme="http://1eeing.github.io/tags/%E7%88%AC%E8%99%AB/"/>
    
  </entry>
  
  <entry>
    <title>彻底搞懂Nginx</title>
    <link href="http://1eeing.github.io/2018/09/13/Nginx/"/>
    <id>http://1eeing.github.io/2018/09/13/Nginx/</id>
    <published>2018-09-12T16:05:30.481Z</published>
    <updated>2018-12-08T15:40:42.912Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>Nginx在工作中用的很多，平时开发也一直用Nginx来代理，但是一直对Nginx是一个模糊的概念。这次打算结合理论和工作中的Nginx配置彻底搞清楚Nginx。</p><h1 id="Nginx能做什么"><a href="#Nginx能做什么" class="headerlink" title="Nginx能做什么"></a>Nginx能做什么</h1><ol><li>正向代理</li><li>反向代理</li><li>负载均衡</li><li>HTTP服务器</li></ol><h1 id="正向代理"><a href="#正向代理" class="headerlink" title="正向代理"></a>正向代理</h1><p>正向代理，也就是传说中的代理，他的工作原理就像一个跳板，简单的说，我是一个用户，我访问不了某网站，但是我能访问一个代理服务器，这个代理服务器呢，他能访问那个我不能访问的网站，于是我先连上代理服务器，告诉他我需要那个无法访问网站的内容，代理服务器去取回来，然后返回给我。从网站的角度，只在代理服务器来取内容的时候有一次记录，有时候并不知道是用户的请求，也隐藏了用户的资料，这取决于代理告不告诉网站。</p><a id="more"></a><p>专业点说：<strong>正向代理是一个位于客户端和原始服务器（origin server）之间的服务器，为了从原始服务器取得内容，客户端向代理发送一个请求并制定目标（原始服务器），然后代理向原始服务器转交请求并将获得的内容返回给客户端。客户端必须要进行一些特殊的设置才能使用正向代理</strong></p><p>关键代码如下<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">resolver 114.114.114.114 8.8.8.8;</span><br><span class="line">server &#123;</span><br><span class="line">  resolver_timeout 5s;</span><br><span class="line">  listen 81;</span><br><span class="line">  </span><br><span class="line">  location / &#123;</span><br><span class="line">    proxy_pass http://$host$request_uri;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>resolver是配置正向代理的DNS服务器，listen是正向代理的端口，配置好了就可以在代理插件上通过服务器ip+端口号进行代理了。</p><h1 id="反向代理"><a href="#反向代理" class="headerlink" title="反向代理"></a>反向代理</h1><p>继续举例。<br>用户访问<a href="http://www.test.com/readme，但www.test.com上并不存在readme页面，他是偷偷从另外一台服务器上取回来，然后作为自己的内容返回用户，但用户并不知情。这里提到的www.test.com这个域名对应的服务器就设置了反向代理功能。" target="_blank" rel="noopener">http://www.test.com/readme，但www.test.com上并不存在readme页面，他是偷偷从另外一台服务器上取回来，然后作为自己的内容返回用户，但用户并不知情。这里提到的www.test.com这个域名对应的服务器就设置了反向代理功能。</a></p><p>结论就是：<strong>反向代理和正向代理正好相反，对于客户端而言他就像是原始服务器，并且客户端不需要进行任何特别的设置。客户端向反向代理的命名空间中的内容发送普通请求，接着反向代理将判断向何处（原始服务器）转交请求，并将获得的内容返回给客户端，就像这些内容原本就是他自己的一样。</strong></p><p>关键代码如下<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">server &#123;</span><br><span class="line">  listen 80;</span><br><span class="line">  server_name localhost;</span><br><span class="line">  </span><br><span class="line">  location / &#123;</span><br><span class="line">    proxy_pass http://localhost:8080;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>这样当我们访问localhost:80时，80端口会向8080端口转交请求，并将内容返回给我们客户端，就相当于访问localhost:8080了。</p><h1 id="负载均衡"><a href="#负载均衡" class="headerlink" title="负载均衡"></a>负载均衡</h1><p>负载均衡也是Nginx常用的一个功能，负载均衡的意思就是分摊到多个操作单元上进行执行，例如Web服务器，FTP服务器、企业关键应用服务器和其它关键人物服务器等，从而共同完成工作任务。简单而言，就是当有2台或以上服务器时，根据规则随机的将请求分发到制定的服务器上处理，负载均衡配置一般都需要同时配置反向代理，通过反向代理跳转到负载均衡。</p><p>Nginx自带3种负载均衡策略，还有2种常用的第三方策略。</p><h2 id="RR（默认）"><a href="#RR（默认）" class="headerlink" title="RR（默认）"></a>RR（默认）</h2><p>每个请求按时间顺序逐一分配到不同的后端服务器，如果后端服务器挂了，则自动剔除。</p><p>核心代码<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">upstream test &#123;</span><br><span class="line">  server localhost:8080;</span><br><span class="line">  server localhost:8081;</span><br><span class="line">&#125;</span><br><span class="line">server &#123;</span><br><span class="line">  listen 80;</span><br><span class="line">  server_name localhost;</span><br><span class="line">  </span><br><span class="line">  location / &#123;</span><br><span class="line">    proxy_pass http://test;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p><code>upstream</code> 部分即为负载均衡的核心代码。<br>这里配置2个端口，而8081端口是访问不到的，但是我们访问 <a href="http://localhost" target="_blank" rel="noopener">http://localhost</a> 的时候也不会有问题，会默认跳转到 <a href="http://localhost:8080" target="_blank" rel="noopener">http://localhost:8080</a> 具体是因为Nginx会自动判断服务器的状态，如果服务器挂了，则不会跳转到这台服务器。</p><h2 id="权重"><a href="#权重" class="headerlink" title="权重"></a>权重</h2><p>制定轮询几率，weight和访问比率成正比，用于后端服务器性能不均的情况。</p><p>核心代码如下<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">upstream test &#123;</span><br><span class="line">  server localhost:8080 weight=9;</span><br><span class="line">  server localhost:8081 weight=1;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>那么10次一般只有1次会访问到8081，剩下9次会访问到8080。</p><h2 id="ip-hash"><a href="#ip-hash" class="headerlink" title="ip_hash"></a>ip_hash</h2><p>上面的2种方式都有一个问题，那就是下一个请求来的时候请求可能分到另一个服务器，当我们的程序不是无状态的时候（采用了session保存数据），这时候就有一个很大的问题了，比如把登录信息保存到session种，那么跳转到另外一台服务器的时候就需要重新登录了，所以很多时候我们需要一个客户只访问一个服务器，那么就需要用iphash了，iphash的每个请求按访问ip的hash结果分配，这样每个方可固定访问一个后端服务器，可以解决session的问题。</p><p>核心代码如下<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">upstream &#123;</span><br><span class="line">  ip_hash;</span><br><span class="line">  server localhost:8080;</span><br><span class="line">  server localhost:8081;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2 id="fair（第三方）"><a href="#fair（第三方）" class="headerlink" title="fair（第三方）"></a>fair（第三方）</h2><p>按后端服务器的响应时间来分配请求，响应时间短的优先分配。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">upstream backend &#123;</span><br><span class="line">  fair;</span><br><span class="line">  server localhost:8080;</span><br><span class="line">  server localhost:8081;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2 id="url-hash（第三方）"><a href="#url-hash（第三方）" class="headerlink" title="url_hash（第三方）"></a>url_hash（第三方）</h2><p>按访问url的hash结果来分配请求，使每个url定向到同一个后端服务器，后端服务器为缓存时比较有效。在upstream中加入hash语句，server语句中不能写入weight等其他的参数，hash_method使使用的hash算法</p><p>核心代码如下<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">upstream backend &#123;</span><br><span class="line">  hash $request_uri;</span><br><span class="line">  hash_method crc32;</span><br><span class="line">  server localhost:8080;</span><br><span class="line">  server localhost:8081;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h1 id="HTTP服务器"><a href="#HTTP服务器" class="headerlink" title="HTTP服务器"></a>HTTP服务器</h1><p>Nginx本身也是一个静态资源的服务器，当只有静态资源的时候，就可以使用Nginx来做服务器，同时现在也很流行动静分离，就可以通过Nginx来实现。</p><p>首先看看Nginx做静态资源服务器<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">server &#123;</span><br><span class="line">  listen 80;</span><br><span class="line">  server_name localhost;</span><br><span class="line">  </span><br><span class="line">  location / &#123;</span><br><span class="line">    root e:\wwwroot;</span><br><span class="line">    index index.html;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>这样如果访问到 <a href="http://localhost" target="_blank" rel="noopener">http://localhost</a> 就会默认访问到E盘wwwroot目录下面的index.html，如果一个网站只是静态页面的话，那么就可以通过这种方式来实现部署。</p><h2 id="动静分离"><a href="#动静分离" class="headerlink" title="动静分离"></a>动静分离</h2><p>动静分离是让动态网站里的动态网页根据一定规则把不变的资源和经常变的资源区分开来，动静资源做好了拆分以后，我们就可以根据静态资源的特点将其做缓存操作，这就是网站静态化处理的核心思路。</p><p>核心代码如下<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">upstream test &#123;</span><br><span class="line">  server localhost:8080;</span><br><span class="line">  server localhost:8081;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">server &#123;</span><br><span class="line">  listen 80;</span><br><span class="line">  server_name localhost;</span><br><span class="line">  </span><br><span class="line">  location / &#123;</span><br><span class="line">    root e:\wwwroot;</span><br><span class="line">    index index.html;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  # 所有静态请求都由nginx处理</span><br><span class="line">  location ~ \.(gif|jpg|jpeg|png|bmp|swf|css|js)$ &#123;</span><br><span class="line">    root e:\wwwroot;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  # 所有动态请求都转发给tomcat处理</span><br><span class="line">  location ~ \.(jsp|do)$ &#123;</span><br><span class="line">    proxy_pass http://test;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>这样我们就可以把html、图片、css以及js放到wwwroot目录下，而tomcat只复杂处理jsp和请求，例如当我们后缀为gif的时候，Nginx默认会从wwwroot获取到当前请求的动态图文件返回，当然这里的静态文件跟Nginx是同意爱服务器，我们也可以在另外一台服务器，然后通过反向代理和负载均衡配置过去就好了。</p><h1 id="实际业务中用到的conf文件分析"><a href="#实际业务中用到的conf文件分析" class="headerlink" title="实际业务中用到的conf文件分析"></a>实际业务中用到的conf文件分析</h1><p>主要代码如下<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">server &#123;</span><br><span class="line">  listen 80;</span><br><span class="line">  </span><br><span class="line">  # host中绑定的www.sb.com实际是localhost</span><br><span class="line">  server_name www.sb.com;</span><br><span class="line"></span><br><span class="line">  # 静态资源从这里返回，缓存的过期时间是1天</span><br><span class="line">  location ~* ^.+\.(woff|woff2|ttf|json|log|jpg|jpeg|gif|png|ico|html|cfm|cfc|afp|asp|lasso|pl|py|txt|fla|swf|zip)$ &#123;</span><br><span class="line">    root /Users/admin/Documents/sb;</span><br><span class="line">    expires 1d;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  # jss、css和less这些静态资源依然走这个目录，过期时间2小时</span><br><span class="line">  location ~* ^.+\.(js|css|less)$ &#123;</span><br><span class="line">    root /Users/admin/Documents/sb;</span><br><span class="line">    expires 2h;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  # 监听80端口，当访问www.sb.com:80的时候</span><br><span class="line">  # 会将请求转发到 http://101.37.111.40</span><br><span class="line">  # 最后将结果返回给客户端</span><br><span class="line">  location ~ /&#123;</span><br><span class="line">    proxy_pass http://101.37.111.40;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>可以看到，项目中用到了反向代理和将Nginx作为静态资源服务器。<br>PS：如果将<a href="http://www.sb.com的host绑定到测试环境，经过验证，不会走进本地Nginx配置。关于这个可以这么理解，Nginx在本地起了一个服务器，如果请求的是本地，则会走进此服务器，如果请求的是其他域名，则不会走进本地Nginx服务器，即和本地Nginx没有关系。" target="_blank" rel="noopener">www.sb.com的host绑定到测试环境，经过验证，不会走进本地Nginx配置。关于这个可以这么理解，Nginx在本地起了一个服务器，如果请求的是本地，则会走进此服务器，如果请求的是其他域名，则不会走进本地Nginx服务器，即和本地Nginx没有关系。</a></p><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><ul><li><a href="https://www.geekjc.com/post/58e70c55e8d0c72d3c4fa340#4." target="_blank" rel="noopener">https://www.geekjc.com/post/58e70c55e8d0c72d3c4fa340#4.</a></li><li><a href="http://blog.51cto.com/freeloda/1288553" target="_blank" rel="noopener">http://blog.51cto.com/freeloda/1288553</a></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;Nginx在工作中用的很多，平时开发也一直用Nginx来代理，但是一直对Nginx是一个模糊的概念。这次打算结合理论和工作中的Nginx配置彻底搞清楚Nginx。&lt;/p&gt;
&lt;h1 id=&quot;Nginx能做什么&quot;&gt;&lt;a href=&quot;#Nginx能做什么&quot; class=&quot;headerlink&quot; title=&quot;Nginx能做什么&quot;&gt;&lt;/a&gt;Nginx能做什么&lt;/h1&gt;&lt;ol&gt;
&lt;li&gt;正向代理&lt;/li&gt;
&lt;li&gt;反向代理&lt;/li&gt;
&lt;li&gt;负载均衡&lt;/li&gt;
&lt;li&gt;HTTP服务器&lt;/li&gt;
&lt;/ol&gt;
&lt;h1 id=&quot;正向代理&quot;&gt;&lt;a href=&quot;#正向代理&quot; class=&quot;headerlink&quot; title=&quot;正向代理&quot;&gt;&lt;/a&gt;正向代理&lt;/h1&gt;&lt;p&gt;正向代理，也就是传说中的代理，他的工作原理就像一个跳板，简单的说，我是一个用户，我访问不了某网站，但是我能访问一个代理服务器，这个代理服务器呢，他能访问那个我不能访问的网站，于是我先连上代理服务器，告诉他我需要那个无法访问网站的内容，代理服务器去取回来，然后返回给我。从网站的角度，只在代理服务器来取内容的时候有一次记录，有时候并不知道是用户的请求，也隐藏了用户的资料，这取决于代理告不告诉网站。&lt;/p&gt;
    
    </summary>
    
      <category term="学习笔记" scheme="http://1eeing.github.io/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="基础知识" scheme="http://1eeing.github.io/tags/%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"/>
    
      <category term="计算机通识" scheme="http://1eeing.github.io/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E9%80%9A%E8%AF%86/"/>
    
      <category term="网络" scheme="http://1eeing.github.io/tags/%E7%BD%91%E7%BB%9C/"/>
    
      <category term="学习笔记" scheme="http://1eeing.github.io/tags/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
      <category term="服务器" scheme="http://1eeing.github.io/tags/%E6%9C%8D%E5%8A%A1%E5%99%A8/"/>
    
      <category term="Nginx" scheme="http://1eeing.github.io/tags/Nginx/"/>
    
  </entry>
  
  <entry>
    <title>【基础篇】git高级操作</title>
    <link href="http://1eeing.github.io/2018/08/27/git%E9%AB%98%E7%BA%A7%E6%93%8D%E4%BD%9C/"/>
    <id>http://1eeing.github.io/2018/08/27/git高级操作/</id>
    <published>2018-08-26T17:14:20.019Z</published>
    <updated>2018-08-26T17:16:04.813Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Rebase"><a href="#Rebase" class="headerlink" title="Rebase"></a>Rebase</h1><p>改命令可以说和merge命令得到的结果基本是一致的<br>通常merge操作将分支上的代码合并到master中，分支样子如下所示</p><p><img src="https://user-gold-cdn.xitu.io/2018/4/23/162f109db27be054?w=505&amp;h=461&amp;f=png&amp;s=22796" alt="https://user-gold-cdn.xitu.io/2018/4/23/162f109db27be054?w=505&amp;h=461&amp;f=png&amp;s=22796"></p><p>使用rebase后，会将develop上的commit按顺序移到master的第三个commit后面，分支样子如下</p><a id="more"></a><p><img src="https://user-gold-cdn.xitu.io/2018/4/23/162f11cc2cb8b332?w=505&amp;h=563&amp;f=png&amp;s=26514" alt="https://user-gold-cdn.xitu.io/2018/4/23/162f11cc2cb8b332?w=505&amp;h=563&amp;f=png&amp;s=26514"></p><p>rebase对比merge<br>优点：</p><ul><li>合并后的结果很清晰，只有一条线</li></ul><p>缺点：</p><ul><li>如果一旦出现冲突，解决冲突很麻烦，可能要解决多个冲突，但是merge出现冲突只需要解决一次</li></ul><p>使用rebase应该在需要被rebase的分支上操作，并且该分支是本地分支。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">## branch develop</span><br><span class="line">git rebase master</span><br><span class="line">git checkout master</span><br><span class="line">## 用于将 master 上的 HEAD 移动到最新的commit</span><br><span class="line">git merge develop</span><br></pre></td></tr></table></figure></p><hr><h1 id="stash"><a href="#stash" class="headerlink" title="stash"></a>stash</h1><p>stash用于临时保存工作目录的改动。开发中可能会遇到代码写一半需要切分支打包的问题，如果这时候你不想commit的话，就可以使用该命令<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git stash</span><br></pre></td></tr></table></figure></p><p>使用该命令可以暂存你的工作目录，恢复如下<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git stash pop</span><br></pre></td></tr></table></figure></p><hr><h1 id="reflog"><a href="#reflog" class="headerlink" title="reflog"></a>reflog</h1><p>reflog可以看到HEAD的移动记录，加入之前误删了一个分支，可以通过git reflog看到移动HEAD的哈希值</p><p><img src="https://user-gold-cdn.xitu.io/2018/4/23/162f14df98ce3d83?w=950&amp;h=118&amp;f=png&amp;s=77151" alt="https://user-gold-cdn.xitu.io/2018/4/23/162f14df98ce3d83?w=950&amp;h=118&amp;f=png&amp;s=77151"></p><p>从图中可以看出，HEAD的最后一次移动行为是merge后，接下来分支new就被删除了，那么我们可以通过以下命令找回new分支</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git checkout 37d9aca</span><br><span class="line">git checkout -b new</span><br></pre></td></tr></table></figure><blockquote><p>reflog 记录是时效的，只会保存一段时间内的记录。</p></blockquote><hr><h1 id="Reset"><a href="#Reset" class="headerlink" title="Reset"></a>Reset</h1><p>如果你想删除刚写的commit，就可以通过以下命令实现</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git reset --hard HEAD^</span><br></pre></td></tr></table></figure><p>但是reset的本质并不是删除了commit，而是重新设置了HEAD和它指向的branch。</p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;Rebase&quot;&gt;&lt;a href=&quot;#Rebase&quot; class=&quot;headerlink&quot; title=&quot;Rebase&quot;&gt;&lt;/a&gt;Rebase&lt;/h1&gt;&lt;p&gt;改命令可以说和merge命令得到的结果基本是一致的&lt;br&gt;通常merge操作将分支上的代码合并到master中，分支样子如下所示&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://user-gold-cdn.xitu.io/2018/4/23/162f109db27be054?w=505&amp;amp;h=461&amp;amp;f=png&amp;amp;s=22796&quot; alt=&quot;https://user-gold-cdn.xitu.io/2018/4/23/162f109db27be054?w=505&amp;amp;h=461&amp;amp;f=png&amp;amp;s=22796&quot;&gt;&lt;/p&gt;
&lt;p&gt;使用rebase后，会将develop上的commit按顺序移到master的第三个commit后面，分支样子如下&lt;/p&gt;
    
    </summary>
    
      <category term="学习笔记" scheme="http://1eeing.github.io/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="基础知识" scheme="http://1eeing.github.io/tags/%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"/>
    
      <category term="计算机通识" scheme="http://1eeing.github.io/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E9%80%9A%E8%AF%86/"/>
    
      <category term="Git高级操作" scheme="http://1eeing.github.io/tags/Git%E9%AB%98%E7%BA%A7%E6%93%8D%E4%BD%9C/"/>
    
  </entry>
  
  <entry>
    <title>【算法篇】树、动态规划及字符串相关</title>
    <link href="http://1eeing.github.io/2018/08/27/%E6%A0%91%E5%92%8C%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"/>
    <id>http://1eeing.github.io/2018/08/27/树和动态规划/</id>
    <published>2018-08-26T17:11:12.317Z</published>
    <updated>2018-09-12T16:06:07.777Z</updated>
    
    <content type="html"><![CDATA[<h1 id="树"><a href="#树" class="headerlink" title="树"></a>树</h1><h2 id="非递归实现中先序、中序、后续遍历"><a href="#非递归实现中先序、中序、后续遍历" class="headerlink" title="非递归实现中先序、中序、后续遍历"></a>非递归实现中先序、中序、后续遍历</h2><p>非递归实现使用了栈的结构，通过栈的先进后出模拟递归实现。</p><p>以下是先序遍历代码实现<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">pre</span>(<span class="params">root</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span>(root)&#123;</span><br><span class="line">    <span class="keyword">let</span> stack = [];</span><br><span class="line">    <span class="comment">// 先将根节点 push</span></span><br><span class="line">    stack.push(root);</span><br><span class="line">    <span class="comment">// 判断栈中是否为空</span></span><br><span class="line">    <span class="keyword">while</span>(stack.length &gt; <span class="number">0</span>)&#123;</span><br><span class="line">      <span class="comment">// 弹出栈顶元素</span></span><br><span class="line">      root = stack.pop();</span><br><span class="line">      <span class="built_in">console</span>.log(root);</span><br><span class="line">      <span class="comment">// 因为先序遍历是先左后右，栈是先进后出结构</span></span><br><span class="line">      <span class="comment">// 所以先push右边再push左边</span></span><br><span class="line">      <span class="keyword">if</span>(root.right)&#123;</span><br><span class="line">        stack.push(root.right);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">if</span>(root.left)&#123;</span><br><span class="line">        stack.push(root.left);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><a id="more"></a><p>以下是中序遍历代码实现<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">mid</span>(<span class="params">root</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span>(root)&#123;</span><br><span class="line">    <span class="keyword">let</span> stack = [];</span><br><span class="line">    <span class="comment">// 中序遍历是先左再根最后右</span></span><br><span class="line">    <span class="comment">// 所以首先应该先把最左边节点遍历到底依次push进栈</span></span><br><span class="line">    <span class="comment">// 当左边没有节点时，就打印栈顶元素，然后寻找右节点</span></span><br><span class="line">    <span class="comment">// 对于最左边的叶节点来说，可以把它看成是两个 null 节点的父节点</span></span><br><span class="line">    <span class="comment">// 左边打印不出东西就把父节点拿出来打印，然后再看右节点</span></span><br><span class="line">    <span class="keyword">while</span>(stack.length &gt; <span class="number">0</span> || root)&#123;</span><br><span class="line">      <span class="keyword">if</span>(root) &#123;</span><br><span class="line">        stack.push(root);</span><br><span class="line">        root = root.left;</span><br><span class="line">      &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        root = stack.pop();</span><br><span class="line">        <span class="built_in">console</span>.log(root);</span><br><span class="line">        root = root.right;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>以下是后续遍历代码实现，该代码使用了两个栈来实现遍历，相比一个栈的遍历来说要容易理解得多<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">pos</span>(<span class="params">root</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span>(root)&#123;</span><br><span class="line">    <span class="keyword">let</span> stack1 = [];</span><br><span class="line">    <span class="keyword">let</span> stack2 = [];</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 后续遍历是先左再右最后根</span></span><br><span class="line">    <span class="comment">// 所以对于一个栈来说，应该先push根节点</span></span><br><span class="line">    <span class="comment">// 然后push右节点，最后push左节点</span></span><br><span class="line">    stack1.push(root);</span><br><span class="line">    <span class="keyword">while</span>(stack1.length &gt; <span class="number">0</span>)&#123;</span><br><span class="line">      root = stack1.pop();</span><br><span class="line">      stack2.push(root);</span><br><span class="line">      <span class="keyword">if</span>(root.left)&#123;</span><br><span class="line">        stack1.push(root.left);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">if</span>(root.right)&#123;</span><br><span class="line">        stack1.push(root.right)</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span>(stack2.length &gt; <span class="number">0</span>)&#123;</span><br><span class="line">      <span class="built_in">console</span>.log(stack2.pop());</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2 id="中序遍历的前驱后续节点"><a href="#中序遍历的前驱后续节点" class="headerlink" title="中序遍历的前驱后续节点"></a>中序遍历的前驱后续节点</h2><p>实现这个算法的前提是节点有一个parent的指针指向父节点，根节点指向null</p><p><img src="https://user-gold-cdn.xitu.io/2018/4/24/162f61ad8e8588b7?w=682&amp;h=486&amp;f=png&amp;s=41027" alt="https://user-gold-cdn.xitu.io/2018/4/24/162f61ad8e8588b7?w=682&amp;h=486&amp;f=png&amp;s=41027"></p><p>如果所示，该树的中序遍历结果是4,2,5,1,6,3,7</p><h3 id="前驱节点"><a href="#前驱节点" class="headerlink" title="前驱节点"></a>前驱节点</h3><p>对于节点2来说，他的前驱节点就是4，按照中序遍历规则（左、根、右），可以得出以下结论</p><ol><li>如果选取的节点的左节点不为空，就找该左节点最右的节点。对于节点1来说，他有左节点2，那么节点2的最右节点就是5</li><li>如果左节点为空，且目标节点是父节点的右节点，那么前驱节点为父节点。对于节点5来说，没有左节点，且是节点2的右节点，所以节点2是前驱节点</li><li>如果左节点为空，且目标节点是父节点的左节点，向上寻找到第一个是父节点的右节点的节点。对于节点6来说，没有左节点，且是节点3的左节点，所以向上寻找到节点1，发现节点3是节点1的右节点，所以节点1是节点6的前驱节点</li></ol><p>代码实现<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">predecessor</span>(<span class="params">node</span>)</span>&#123;</span><br><span class="line">  <span class="keyword">if</span>(!node) rteurn;</span><br><span class="line">  <span class="comment">// 结论1</span></span><br><span class="line">  <span class="keyword">if</span>(node.left)&#123;</span><br><span class="line">    <span class="keyword">return</span> getRight(node.left);</span><br><span class="line">  &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">    <span class="keyword">let</span> parent = node.parent;</span><br><span class="line">    <span class="comment">// 结论23的判断</span></span><br><span class="line">    <span class="keyword">while</span>(parent &amp;&amp; parent.right === node)&#123;</span><br><span class="line">      node = parent;</span><br><span class="line">      parent = node.parent;</span><br><span class="line">    &#125;</span><br><span class="line">    retrn parent;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getRight</span>(<span class="params">node</span>)</span>&#123;</span><br><span class="line">  <span class="keyword">if</span>(!node) <span class="keyword">return</span>;</span><br><span class="line">  node = node.right;</span><br><span class="line">  <span class="keyword">while</span>(node) node = node.right;</span><br><span class="line">  <span class="keyword">return</span> node;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="后继节点"><a href="#后继节点" class="headerlink" title="后继节点"></a>后继节点</h3><p>对于节点2来说，他的后继节点就是5，按照中序遍历原则，可以得出以下结论</p><ol><li>如果有右节点，就找到该右节点的最左节点。对于节点1来说，他有右节点3，那么节点3的最左节点就是6</li><li>如果没有右节点，就向上遍历直到找到一个节点是父节点的左节点。对于节点5来说，没有右节点，就向上寻找到节点2，该节点是父节点1的左节点，所以节点1是后继节点</li></ol><p>代码实现：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">successor</span>(<span class="params">node</span>)</span>&#123;</span><br><span class="line">  <span class="keyword">if</span>(!node) <span class="keyword">return</span>;</span><br><span class="line">  <span class="comment">// 结论1</span></span><br><span class="line">  <span class="keyword">if</span>(node.right)&#123;</span><br><span class="line">    <span class="keyword">return</span> getLeft(node.right);</span><br><span class="line">  &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">    <span class="comment">// 结论2</span></span><br><span class="line">    <span class="keyword">let</span> parent = node.parent;</span><br><span class="line">    <span class="comment">// 判断parent为空</span></span><br><span class="line">    <span class="keyword">while</span>(parent &amp;&amp; parent.left === node)&#123;</span><br><span class="line">      node = parent;</span><br><span class="line">      parent = node.parent;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> parent;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getLeft</span>(<span class="params">node</span>)</span>&#123;</span><br><span class="line">  <span class="keyword">if</span>(!node) <span class="keyword">return</span></span><br><span class="line">  node = node.left;</span><br><span class="line">  <span class="keyword">while</span>(node) node = node.left;</span><br><span class="line">  <span class="keyword">return</span> node;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><hr><h1 id="动态规划"><a href="#动态规划" class="headerlink" title="动态规划"></a>动态规划</h1><p>动态规划背后的基本思想非常简单，就是将一个问题拆分为子问题，一般来说这些子问题都是非常相似的，那么我们可以通过只解决一次每个子问题来达到减少计算量的目的。</p><p>一旦得出每个子问题的解，就存储该结果以便下次使用。</p><h2 id="斐波那契数列"><a href="#斐波那契数列" class="headerlink" title="斐波那契数列"></a>斐波那契数列</h2><p>斐波那契数列就是从0和1开始，后面的数都是前两个数之和。<br>那么显而易见，我们可以通过递归的方式来完成求解斐波那契数列</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fib</span>(<span class="params">n</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span>(n &lt; <span class="number">2</span> &amp;&amp; n &gt;= <span class="number">0</span>) <span class="keyword">return</span> n;</span><br><span class="line">  <span class="keyword">return</span> fib(n - <span class="number">1</span>) + fib(n - <span class="number">2</span>);</span><br><span class="line">&#125;</span><br><span class="line">fib(<span class="number">10</span>);</span><br></pre></td></tr></table></figure><p>以上代码已经可以完美的解决问题，但是以上解法却存在很严重的性能问题，当n越大的时候，需要的时间是指数增长的，这时候就可以通过动态规划来解决这个问题。</p><p>动态规划的本质其实就两点</p><ol><li>自底向上分解子问题</li><li>通过变量存储已经计算过的解</li></ol><p>根据上面两点，斐波那契数列的动态规划思路也就出来了</p><ol><li>斐波那契数列从0和1开始，那么这就是这个子问题的最底层</li><li>通过数组来存储每一位所对应的斐波那契数列的值</li></ol><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fib</span>(<span class="params">n</span>)</span>&#123;</span><br><span class="line">  <span class="keyword">let</span> array = <span class="keyword">new</span> <span class="built_in">Array</span>(n + <span class="number">1</span>).fill(<span class="literal">null</span>);</span><br><span class="line">  array[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">  array[<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">let</span> i = <span class="number">2</span>; i &lt;= n; i++)&#123;</span><br><span class="line">    array[i] = array[i - <span class="number">1</span>] + array[i - <span class="number">2</span>];</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> array[n];</span><br><span class="line">&#125;</span><br><span class="line">fib(<span class="number">10</span>);</span><br></pre></td></tr></table></figure><h2 id="0-1-背包问题"><a href="#0-1-背包问题" class="headerlink" title="0 - 1 背包问题"></a>0 - 1 背包问题</h2><p>该问题可以描述为：给定一组物品，没种物品都有自己的重量和价格，在限定的总重量内，我们如何选择，才能使得物品的总价格最高。每个问题只能放入至多一次。</p><p>假设我们有以下物品</p><table><thead><tr><th>物品ID/重量</th><th style="text-align:center">价值</th></tr></thead><tbody><tr><td>1</td><td style="text-align:center">3</td></tr><tr><td>2</td><td style="text-align:center">7</td></tr><tr><td>3</td><td style="text-align:center">12</td></tr></tbody></table><p>对于一个总容量为5的背包来说，我们可以放入重量2和3的物品来达到背包被的物品总价值最高。<br>对于这个问题来说，子问题就两个，分别是放物品和不放物品，可以通过以下表格来理解子问题</p><table><thead><tr><th style="text-align:center">物品ID/剩余容量</th><th style="text-align:center">0</th><th>1</th><th>2</th><th>3</th><th>4</th><th>5</th></tr></thead><tbody><tr><td style="text-align:center">1</td><td style="text-align:center">0</td><td>3</td><td>3</td><td>3</td><td>3</td><td>3</td></tr><tr><td style="text-align:center">2</td><td style="text-align:center">0</td><td>3</td><td>7</td><td>10</td><td>10</td><td>10</td></tr><tr><td style="text-align:center">3</td><td style="text-align:center">0</td><td>3</td><td>7</td><td>12</td><td>15</td><td>19</td></tr></tbody></table><p>直接来分析能放三种物品的情况，也就是最后一行</p><ul><li>当容量少于3时，只取上一行对应的数据，因为当前容量不能容纳物品3</li><li>当容量为3时，考虑两种情况，分别为放入物品3和不放物品3<ul><li>不放物品3的情况下，总价值为10</li><li>放入物品3的情况下，总价值为12，所以应该放入物品3</li></ul></li><li>当容量为4时，考虑两种情况，分别为放入物品3和不放物品3<ul><li>不放物品3的情况下，总价值为10</li><li>放入物品3的情况下，和放入物品1的价值相加，得出总价值为15，所以应该放入物品3</li></ul></li><li>当容量为5时，考虑两种情况，分别为放入物品3和不放物品3<ul><li>不放物品3的情况下，总价值为10</li><li>放入物品3的情况下，和放入物品2的价值相加，得出总价值为19，所以应该放入物品3</li></ul></li></ul><p>代码如下<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @param &#123;*&#125; w 物品重量</span></span><br><span class="line"><span class="comment"> * @param &#123;*&#125; v 物品价值</span></span><br><span class="line"><span class="comment"> * @param &#123;*&#125; c 总容量</span></span><br><span class="line"><span class="comment"> * @returns</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">knapsack</span>(<span class="params">w,v,c</span>)</span>&#123;</span><br><span class="line">  <span class="keyword">let</span> length = w.length;</span><br><span class="line">  <span class="keyword">if</span>(length === <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// 对照表格，生成的二维数组，第一维代表物品，第二维代表背包剩余容量</span></span><br><span class="line">  <span class="comment">// 第二维中的元素代表背包物品总价值</span></span><br><span class="line">  <span class="keyword">let</span> array = <span class="keyword">new</span> <span class="built_in">Array</span>(length).fill(<span class="keyword">new</span> <span class="built_in">Array</span>(c + <span class="number">1</span>).fill(<span class="literal">null</span>));</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// 完成底部子问题的解</span></span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">let</span> i = <span class="number">0</span>; i &lt;= c; i++)&#123;</span><br><span class="line">    <span class="comment">// 对照表格第一行，array[0]代表物品1</span></span><br><span class="line">    <span class="comment">// i代表剩余总容量</span></span><br><span class="line">    <span class="comment">// 当剩余总容量大于物品1的重量时，记录下背包物品总价值，否则价值为0</span></span><br><span class="line">    array[<span class="number">0</span>][i] = i &gt;= w[<span class="number">0</span>] ? v[<span class="number">0</span>] : <span class="number">0</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// 自底向上开始解决子问题，从物品2开始</span></span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">let</span> i = <span class="number">1</span>; i &lt; length; i++)&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">let</span> j = <span class="number">0</span>; j &lt;= c; j++)&#123;</span><br><span class="line">      <span class="comment">// 这里求解子问题，分别为不放当前物品和放当前物品</span></span><br><span class="line">      <span class="comment">// 先求不放当前物品的背包总价值，这里的值也就是对应表格中上一行对应的值</span></span><br><span class="line">      array[i][j] = array[i - <span class="number">1</span>][j];</span><br><span class="line">      <span class="comment">// 判断当前剩余容量是否可以放入当前物品</span></span><br><span class="line">      <span class="keyword">if</span>(j &gt;= w[i])&#123;</span><br><span class="line">        <span class="comment">// 可以放入的话，就比大小</span></span><br><span class="line">        <span class="comment">// 放入当前物品和不放入当前物品，哪个背包总价值大</span></span><br><span class="line">        array[i][j] = <span class="built_in">Math</span>.max(array[i][j], v[i] + array[i <span class="number">-1</span>][j - w[i]])</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> array[length - <span class="number">1</span>][c];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2 id="最长递增子序列"><a href="#最长递增子序列" class="headerlink" title="最长递增子序列"></a>最长递增子序列</h2><p>这个问题的动态思路解法很简单，直接上代码<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">lis</span>(<span class="params">n</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span>(n.length === <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">let</span> array = <span class="keyword">new</span> <span class="built_in">Array</span>(n.length).fill(<span class="number">1</span>);</span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">let</span> i = <span class="number">1</span>; i &lt; n.length; i ++)&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">let</span> j = <span class="number">0</span>; j &lt; i; j++)&#123;</span><br><span class="line">      <span class="keyword">if</span>(n[i] &gt; n[j])&#123;</span><br><span class="line">        array[i] = <span class="built_in">Math</span>.max(array[i], <span class="number">1</span> + array[j]);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">let</span> res = <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; array.length; i++)&#123;</span><br><span class="line">    res = <span class="built_in">Math</span>.max(res, array[i]);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><hr><h1 id="字符串相关"><a href="#字符串相关" class="headerlink" title="字符串相关"></a>字符串相关</h1><p>在字符串相关的算法中，Trie树可以解决很多问题，同时又具备良好的空间和时间复杂度，比如以下问题</p><ul><li>词频统计</li><li>前缀匹配</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;树&quot;&gt;&lt;a href=&quot;#树&quot; class=&quot;headerlink&quot; title=&quot;树&quot;&gt;&lt;/a&gt;树&lt;/h1&gt;&lt;h2 id=&quot;非递归实现中先序、中序、后续遍历&quot;&gt;&lt;a href=&quot;#非递归实现中先序、中序、后续遍历&quot; class=&quot;headerlink&quot; title=&quot;非递归实现中先序、中序、后续遍历&quot;&gt;&lt;/a&gt;非递归实现中先序、中序、后续遍历&lt;/h2&gt;&lt;p&gt;非递归实现使用了栈的结构，通过栈的先进后出模拟递归实现。&lt;/p&gt;
&lt;p&gt;以下是先序遍历代码实现&lt;br&gt;&lt;figure class=&quot;highlight js&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;15&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;16&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;17&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;18&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;19&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;20&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;21&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;function&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;pre&lt;/span&gt;(&lt;span class=&quot;params&quot;&gt;root&lt;/span&gt;) &lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt;(root)&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;let&lt;/span&gt; stack = [];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;comment&quot;&gt;// 先将根节点 push&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    stack.push(root);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;comment&quot;&gt;// 判断栈中是否为空&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;while&lt;/span&gt;(stack.length &amp;gt; &lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;)&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;      &lt;span class=&quot;comment&quot;&gt;// 弹出栈顶元素&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;      root = stack.pop();&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;      &lt;span class=&quot;built_in&quot;&gt;console&lt;/span&gt;.log(root);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;      &lt;span class=&quot;comment&quot;&gt;// 因为先序遍历是先左后右，栈是先进后出结构&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;      &lt;span class=&quot;comment&quot;&gt;// 所以先push右边再push左边&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;      &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt;(root.right)&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        stack.push(root.right);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;      &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;      &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt;(root.left)&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        stack.push(root.left);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;      &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="学习笔记" scheme="http://1eeing.github.io/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="基础知识" scheme="http://1eeing.github.io/tags/%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"/>
    
      <category term="计算机通识" scheme="http://1eeing.github.io/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E9%80%9A%E8%AF%86/"/>
    
      <category term="学习笔记" scheme="http://1eeing.github.io/tags/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
      <category term="算法" scheme="http://1eeing.github.io/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="动态规划" scheme="http://1eeing.github.io/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"/>
    
      <category term="树" scheme="http://1eeing.github.io/tags/%E6%A0%91/"/>
    
      <category term="字符串相关" scheme="http://1eeing.github.io/tags/%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%9B%B8%E5%85%B3/"/>
    
  </entry>
  
  <entry>
    <title>【浏览器篇】浏览器的缓存策略</title>
    <link href="http://1eeing.github.io/2018/08/19/%E6%B5%8F%E8%A7%88%E5%99%A8%E7%9A%84%E7%BC%93%E5%AD%98%E7%AD%96%E7%95%A5/"/>
    <id>http://1eeing.github.io/2018/08/19/浏览器的缓存策略/</id>
    <published>2018-08-18T16:49:14.743Z</published>
    <updated>2018-08-18T16:52:45.893Z</updated>
    
    <content type="html"><![CDATA[<p>通常浏览器缓存策略分为两种</p><ul><li>强缓存<br>实现强缓存可以通过两种响应头实现，表示在缓存期间不需要请求，state code为200<ul><li>Expires：HTTP/1.0的产物，表示在XX时间后过期，受限于本地时间</li><li>Cache-Control：HTTP/1.1，优先级高于Expires，值为max-age=xx，表示xx秒后过期</li></ul></li></ul><a id="more"></a><ul><li><p>协商缓存</p><ul><li><p>Last-Modified和If-Modified-Since：Last-Modified表示本地文件最后修改日期，If-Modified-Since会将   Last-Modified的值发送给服务器，询问服务器在该日期后资源是否有更新，有更新的话就会将新的资源发送   回来。但是如果在本地打开缓存文件，就会造成Last-Modified被修改，所以在HTTP/1.1中出现了ETag。</p></li><li><p>ETag和If-None-Match：Etag类似于文件指纹，If-None-Match会将当前Etag发送给服务器，询问该资源ETag   是否有变动，有的话则将新的资源发送回来。优先级比Last-Modified高。</p></li></ul></li></ul><p>对于大部分的场景都可以使用强缓存配合协商缓存解决，但是在一些特殊的地方可能需要选择特殊的缓存策略</p><ul><li>对于某些不需要缓存的资源，可以使用Cache-Control: no-store</li><li>对于频繁变动的资源，可以使用Cache-Control配合ETag使用</li><li>对于代码文件来说，可以使用Cache-Control: max-age=3153600，并配合缓存策略使用，然后对文件进行指纹吹，一旦文件名变动就会下载新的文件</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;通常浏览器缓存策略分为两种&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;强缓存&lt;br&gt;实现强缓存可以通过两种响应头实现，表示在缓存期间不需要请求，state code为200&lt;ul&gt;
&lt;li&gt;Expires：HTTP/1.0的产物，表示在XX时间后过期，受限于本地时间&lt;/li&gt;
&lt;li&gt;Cache-Control：HTTP/1.1，优先级高于Expires，值为max-age=xx，表示xx秒后过期&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
      <category term="学习笔记" scheme="http://1eeing.github.io/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="基础知识" scheme="http://1eeing.github.io/tags/%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"/>
    
      <category term="计算机通识" scheme="http://1eeing.github.io/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E9%80%9A%E8%AF%86/"/>
    
      <category term="学习笔记" scheme="http://1eeing.github.io/tags/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
      <category term="浏览器" scheme="http://1eeing.github.io/tags/%E6%B5%8F%E8%A7%88%E5%99%A8/"/>
    
      <category term="缓存策略" scheme="http://1eeing.github.io/tags/%E7%BC%93%E5%AD%98%E7%AD%96%E7%95%A5/"/>
    
  </entry>
  
  <entry>
    <title>【算法篇】排序与链表</title>
    <link href="http://1eeing.github.io/2018/08/18/%E6%8E%92%E5%BA%8F%E5%92%8C%E9%93%BE%E8%A1%A8/"/>
    <id>http://1eeing.github.io/2018/08/18/排序和链表/</id>
    <published>2018-08-18T14:06:03.879Z</published>
    <updated>2018-08-18T14:11:14.603Z</updated>
    
    <content type="html"><![CDATA[<h1 id="排序"><a href="#排序" class="headerlink" title="排序"></a>排序</h1><p>排序算法是计算机中比较常用的算法，这边整理了如下几种排序算法：</p><ul><li>冒泡排序</li><li>插入排序</li><li>选择排序</li><li>归并排序</li><li>快排</li><li>堆排序</li></ul><p>以下两个函数是排序中会用到的通用函数</p><a id="more"></a><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">checkArray</span>(<span class="params">array</span>)</span>&#123;</span><br><span class="line">  <span class="keyword">if</span>(!array || array.length &lt;= <span class="number">2</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">  <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">swap</span>(<span class="params">array, left, right</span>)</span>&#123;</span><br><span class="line">  <span class="keyword">let</span> rightValue = array[right];</span><br><span class="line">  array[right] = array[left];</span><br><span class="line">  array[left] = rightValue;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="冒泡排序"><a href="#冒泡排序" class="headerlink" title="冒泡排序"></a>冒泡排序</h2><p>冒泡排序的原理如下，从第一个元素开始，把当前元素和下一个索引元素进行比较。如果当前元素大，那么就交换位置，重复操作直到比较到最后一个元素，那么此时最后一个元素就是该数组中最大的数。下一轮重复以上操作，但是此时最后一个元素已经是最大数了，所以不需要再比较最后一个元素，只需要比较到 <code>length - 1</code> 的位置。</p><p><img src="https://user-gold-cdn.xitu.io/2018/4/12/162b895b452b306c?w=670&amp;h=508&amp;f=gif&amp;s=282307" alt="https://user-gold-cdn.xitu.io/2018/4/12/162b895b452b306c?w=670&amp;h=508&amp;f=gif&amp;s=282307"></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">bubble</span>(<span class="params">arr</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> <span class="keyword">continue</span> = checkArray(arr);</span><br><span class="line">  <span class="keyword">if</span>(!<span class="keyword">continue</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">let</span> i = arr.length - <span class="number">1</span>; i &gt; <span class="number">0</span>; i--)&#123;</span><br><span class="line">    <span class="comment">// 从0到length - 1遍历</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">let</span> j = <span class="number">0</span>; j &lt; i; j++)&#123;</span><br><span class="line">      <span class="keyword">if</span>(arr[j] &gt; arr[j + <span class="number">1</span>])&#123;</span><br><span class="line">        swap(arr, j, j+<span class="number">1</span>);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>该算法的操作次数是一个等差数列 <code>n + (n - 1) + (n - 2) + …… + 1</code> ，去掉常数项以后得出时间复杂度是O(n * n)</p><h2 id="插入排序"><a href="#插入排序" class="headerlink" title="插入排序"></a>插入排序</h2><p>插入排序的原理如下。第一个元素默认是已排序元素，取出下一个元素和当前元素比较，如果当前元素大就交换位置。那么此时第一个元素就是当前的最小数，所以下次取出操作从第三个元素开始，向前对比，重复之前的操作。</p><p><img src="https://user-gold-cdn.xitu.io/2018/4/12/162b895c7e59dcd1?w=670&amp;h=508&amp;f=gif&amp;s=609549" alt="https://user-gold-cdn.xitu.io/2018/4/12/162b895c7e59dcd1?w=670&amp;h=508&amp;f=gif&amp;s=609549"></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">insertion</span>(<span class="params">arr</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> <span class="keyword">continue</span> = checkArray(arr);</span><br><span class="line">  <span class="keyword">if</span>(!<span class="keyword">continue</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">let</span> i = <span class="number">1</span>; i &lt; arr.length; i++)&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">let</span> j = i - <span class="number">1</span>; j &gt;=<span class="number">0</span> &amp;&amp; arr[j] &gt; arr[j + <span class="number">1</span>]; j--)&#123;</span><br><span class="line">      swap(arr, j, j + <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> arr;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>该算法的操作次数是一个等差数列 <code>n + (n - 1) + (n - 2) + …… + 1</code> ，去掉常数项以后得出时间复杂度是O(n * n)</p><h2 id="选择排序"><a href="#选择排序" class="headerlink" title="选择排序"></a>选择排序</h2><p>选择排序的原理如下。遍历数组，设置最小值的索引为0，如果取出的值比当前最小值小，就替换最小值索引，遍历完成后，将第一个元素和最小值索引上的值交换。如上操作后，第一个元素就是数组中的最小值，下次遍历就可以从索引1开始重复上述操作。</p><p><img src="https://user-gold-cdn.xitu.io/2018/4/13/162bc8ea14567e2e?w=670&amp;h=508&amp;f=gif&amp;s=965636" alt="https://user-gold-cdn.xitu.io/2018/4/13/162bc8ea14567e2e?w=670&amp;h=508&amp;f=gif&amp;s=965636"></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">selection</span>(<span class="params">arr</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> <span class="keyword">continue</span> = checkArray(arr);</span><br><span class="line">  <span class="keyword">if</span>(!<span class="keyword">continue</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; arr.length; i++)&#123;</span><br><span class="line">    <span class="keyword">let</span> minIndex = i;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">let</span> j = i + <span class="number">1</span>; j &lt; arr.length; j++)&#123;</span><br><span class="line">      minIndex = arr[j] &lt; arr[minIndex] ? j : minIndex;</span><br><span class="line">    &#125;</span><br><span class="line">    swap(arr, i, minIndex);</span><br><span class="line">  &#125;</span><br><span class="line">  retrn arr;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>时间复杂度O(n * n)。</p><h2 id="归并排序"><a href="#归并排序" class="headerlink" title="归并排序"></a>归并排序</h2><p>递归的将数组两两分开直到最多包含两个元素，然后将数组排序合并，最终合并为排序好的数组。假设我有一组数组[3,1,2,8,9,7,6]，中间数索引是3，先排序数组[3,1,2,8]。在这个左边数组上，继续拆分直到变成数组包含两个元素（如果数组长度是奇数的话，会有一个拆分数组只包含一个元素）。然后排序数组[3,1]和[2,8]，然后再排序数组 [1,3,2,8]，这样左边数组就排序完成，然后按照以上思路排序右边数组，最后将数组[1,2,3,8]和[6,7,9]排序。</p><p><img src="https://user-gold-cdn.xitu.io/2018/4/13/162be13c7e30bd86?w=896&amp;h=1008&amp;f=gif&amp;s=937952" alt="https://user-gold-cdn.xitu.io/2018/4/13/162be13c7e30bd86?w=896&amp;h=1008&amp;f=gif&amp;s=937952"></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">sort</span>(<span class="params">arr</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> <span class="keyword">continue</span> = checkArray(arr);</span><br><span class="line">  <span class="keyword">if</span>(!<span class="keyword">continue</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  mergeSort(arr, <span class="number">0</span>, arr.length - <span class="number">1</span>);</span><br><span class="line">  <span class="keyword">return</span> arr;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">mergeSort</span>(<span class="params">arr, left, right</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 左右索引相同说明已经只有一个数</span></span><br><span class="line">  <span class="keyword">if</span>(left === right) <span class="keyword">return</span>;</span><br><span class="line">  <span class="comment">// 等同于 left + (right - left) / 2</span></span><br><span class="line">  <span class="comment">// 相比 (left + right) / 2 更加安全，不会溢出</span></span><br><span class="line">  <span class="comment">// 使用位运算，因为快</span></span><br><span class="line">  <span class="keyword">let</span> mid = <span class="built_in">parseInt</span>(left + (right - left) &gt;&gt; <span class="number">1</span>);</span><br><span class="line">  mergeSort(arr, left, mid);</span><br><span class="line">  mergeSort(arr, mid + <span class="number">1</span>, right);</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">let</span> help = [];</span><br><span class="line">  <span class="keyword">let</span> i = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">let</span> p1 = left;</span><br><span class="line">  <span class="keyword">let</span> p2 = mid + <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">while</span>(p1 &lt;= mid &amp;&amp; p2 &lt;= right)&#123;</span><br><span class="line">    help[i++] = arr[p1] &lt; arr[p2] ? arr[p1++] : arr[p2++];</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">while</span>(p1 &lt;= mid)&#123;</span><br><span class="line">    help[i++] = arr[p1++];</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">while</span>(p2 &lt;= right) &#123;</span><br><span class="line">    help[i++] = arr[p2++];</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; help.length; i++)&#123;</span><br><span class="line">    arr[left + i] = help[i];</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> arr;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>时间复杂度O(N * logN)。</p><h2 id="快排"><a href="#快排" class="headerlink" title="快排"></a>快排</h2><p>随机选取一个数组中的值作为基准值，从左至右取值与基准值对比大小。比基准值小的放数组左边，大的放右边，对比完成后将基准值和第一个比基准值大的值交换位置。然后将数组以基准值的位置分为两部分，继续递归以上操作。</p><p><img src="https://user-gold-cdn.xitu.io/2018/4/16/162cd23e69ca9ea3?w=824&amp;h=506&amp;f=gif&amp;s=867744" alt="https://user-gold-cdn.xitu.io/2018/4/16/162cd23e69ca9ea3?w=824&amp;h=506&amp;f=gif&amp;s=867744"></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">sort</span>(<span class="params">arr</span>)</span>&#123;</span><br><span class="line">  <span class="keyword">let</span> <span class="keyword">continue</span> = checkArray(arr);</span><br><span class="line">  <span class="keyword">if</span>(!<span class="keyword">continue</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  quickSort(arr, <span class="number">0</span>, arr.length - <span class="number">1</span>);</span><br><span class="line">  <span class="keyword">return</span> arr;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">quickSort</span>(<span class="params">arr, left, right</span>)</span>&#123;</span><br><span class="line">  <span class="keyword">if</span>(left &lt; right)&#123;</span><br><span class="line">    swap(arr, , right);</span><br><span class="line">    <span class="keyword">let</span> indexs = part(arr, <span class="built_in">parseInt</span>(<span class="built_in">Math</span>.random() * (right - left + <span class="number">1</span>)) + left, right);</span><br><span class="line">    quickSort(arr, left, indexs[<span class="number">0</span>]);</span><br><span class="line">    quickSort(arr, indexs[<span class="number">1</span>] + <span class="number">1</span>, right);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">part</span>(<span class="params">arr, left, right</span>)</span>&#123;</span><br><span class="line">  <span class="keyword">let</span> less = left - <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">let</span> more = right;</span><br><span class="line">  <span class="keyword">while</span>(left &lt; more) &#123;</span><br><span class="line">    <span class="keyword">if</span>(arr[left] &lt; arr[right])&#123;</span><br><span class="line">      ++less;</span><br><span class="line">      ++left;</span><br><span class="line">    &#125;<span class="keyword">else</span> <span class="keyword">if</span>(arr[left] &gt; arr[right])&#123;</span><br><span class="line">      swap(arr, --more, left);</span><br><span class="line">    &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">      left ++;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  swap(arr, right, more);</span><br><span class="line">  <span class="keyword">return</span> [less, more];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>该算法的复杂度和归并排序是相同的，但是额外空间复杂度比归并排序少，只需O(logN)，并且相比归并排序来说，所需的常数时间也更少。</p><h2 id="堆排序"><a href="#堆排序" class="headerlink" title="堆排序"></a>堆排序</h2><p>堆排序利用了二叉堆的特性来做，二叉堆通常用数组表示，并且二叉堆是一颗完全二叉树（所有叶子节点都是从左往右顺序排序，并且其他层的节点都是满的）。二叉堆又分为大根堆与小根堆。</p><blockquote><ul><li>大根堆是某个节点的所有子节点的值都比他小</li><li>小根堆是某个节点的所有子节点的值都比他大</li></ul></blockquote><p>堆排序的原理就是组成一个大根堆或者小根堆。以小根堆为例，某个节点的左边子节点索引是 i <em> 2 + 1，右边是i </em> 2 + 2 ，父节点是 (i - 1) / 2。</p><ol><li>首先遍历数组，判断该节点的父节点是否比他小，如果小就交换位置并继续判断，直到他的父节点比他大。</li><li>重新以上操作1，直到数组首位是最大值</li><li>将首位和末尾交换位置并将数组长度减一，表示数组末尾已是最大值，不需要再比较大小。</li><li>对比左右节点哪个大，然后记住大的节点的索引并且和父节点对比大小，如果子节点大就交换位置</li><li>重复 3-4 直到整个数组都是大根堆</li></ol><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">heap</span>(<span class="params">arr</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> <span class="keyword">continue</span> = checkArray(arr);</span><br><span class="line">  <span class="keyword">if</span>(!<span class="keyword">continue</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 将最大值交换到首位</span></span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; arr.length; i++)&#123;</span><br><span class="line">    heapInsert(arr, i);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">let</span> size = arr.length;</span><br><span class="line">  <span class="comment">// 交换首位和末尾</span></span><br><span class="line">  swap(arr, <span class="number">0</span>, --size);</span><br><span class="line">  <span class="keyword">while</span>(size &gt; <span class="number">0</span>)&#123;</span><br><span class="line">    heapify(arr, <span class="number">0</span>, size);</span><br><span class="line">    swap(arr, <span class="number">0</span>, --size);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> arr;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">heapInsert</span>(<span class="params">arr, index</span>)</span>&#123;</span><br><span class="line">  <span class="comment">// 如果当前节点比父节点大，就交换</span></span><br><span class="line">  <span class="keyword">while</span>(arr[index] &gt; arr[<span class="built_in">parseInt</span>((index - <span class="number">1</span>) / <span class="number">2</span>)])&#123;</span><br><span class="line">    swap(arr, index, <span class="built_in">parseInt</span>((index - <span class="number">1</span>) / <span class="number">2</span>));</span><br><span class="line">    <span class="comment">// 将索引变成父节点</span></span><br><span class="line">    index = <span class="built_in">parseInt</span>((index - <span class="number">1</span>) / <span class="number">2</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">heapify</span>(<span class="params">arr, index, size</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> left = index * <span class="number">2</span> + <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">while</span>(left &lt; size) &#123;</span><br><span class="line">    <span class="comment">// 判断左右节点大小</span></span><br><span class="line">    <span class="keyword">let</span> largest = left + <span class="number">1</span> &lt; size &amp;&amp; arr[left] &lt; arr[left + <span class="number">1</span>] ? left + <span class="number">1</span> : left;</span><br><span class="line">    <span class="comment">// 判断子节点和父节点大小</span></span><br><span class="line">    largest = arr[index] &gt; arr[largest] ? largest : index;</span><br><span class="line">    <span class="keyword">if</span>(largest === index) <span class="keyword">break</span>;</span><br><span class="line">    swap(arr, index, largest);</span><br><span class="line">    index = largest;</span><br><span class="line">    left = index * <span class="number">2</span> + <span class="number">1</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>以上实现了小根堆，如果需要实现大根堆，只需要把节点对比反一下就好。<br>该算法复杂度是O(logN)。</p><h2 id="系统自带排序实现"><a href="#系统自带排序实现" class="headerlink" title="系统自带排序实现"></a>系统自带排序实现</h2><p>每个语言的排序内部实现都是不同的。<br>对于js来说，数组长度大于10会采用快排，否则使用插入排序。选择插入排序是因为虽然时间复杂度很差，但是在数据量很小的情况下和O(n * logN) 相差无几，然后插入排序需要的时间常数很小，所以相对别的排序来说更快。</p><p>对于java来说，还会考虑内部的元素的类型。对于存储对象的数组来说，会采用稳定性好的算法。稳定性的意思就是对于相同值来说，相对顺序不能改变。</p><hr><h1 id="链表"><a href="#链表" class="headerlink" title="链表"></a>链表</h1><h2 id="反转单向链表"><a href="#反转单向链表" class="headerlink" title="反转单向链表"></a>反转单向链表</h2><p>思路很简单，使用三个变量分别表示当前节点和当前节点的前后节点。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">reverseList</span>(<span class="params">head</span>)</span>&#123;</span><br><span class="line">  <span class="comment">// 判断下变量边界问题</span></span><br><span class="line">  <span class="keyword">if</span>(!head || !head.next) <span class="keyword">return</span> head;</span><br><span class="line">  <span class="comment">// 初始设置为空，因为第一个节点反转后就是尾部，尾部节点指向 null</span></span><br><span class="line">  <span class="keyword">let</span> pre = <span class="literal">null</span>;</span><br><span class="line">  <span class="keyword">let</span> current = head;</span><br><span class="line">  <span class="keyword">let</span> next;</span><br><span class="line">  <span class="comment">// 判断当前节点是否为空</span></span><br><span class="line">  <span class="comment">// 不为空就先获取当前节点的下一节点</span></span><br><span class="line">  <span class="comment">// 然后把当前节点的next设为上一个节点</span></span><br><span class="line">  <span class="comment">// 然后把current设为下一个节点，pre设为当前节点</span></span><br><span class="line">  <span class="keyword">while</span>(current) &#123;</span><br><span class="line">    next = current.next;</span><br><span class="line">    current.next = pre;</span><br><span class="line">    pre = current;</span><br><span class="line">    current = next;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> pre;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;排序&quot;&gt;&lt;a href=&quot;#排序&quot; class=&quot;headerlink&quot; title=&quot;排序&quot;&gt;&lt;/a&gt;排序&lt;/h1&gt;&lt;p&gt;排序算法是计算机中比较常用的算法，这边整理了如下几种排序算法：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;冒泡排序&lt;/li&gt;
&lt;li&gt;插入排序&lt;/li&gt;
&lt;li&gt;选择排序&lt;/li&gt;
&lt;li&gt;归并排序&lt;/li&gt;
&lt;li&gt;快排&lt;/li&gt;
&lt;li&gt;堆排序&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;以下两个函数是排序中会用到的通用函数&lt;/p&gt;
    
    </summary>
    
      <category term="学习笔记" scheme="http://1eeing.github.io/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="基础知识" scheme="http://1eeing.github.io/tags/%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"/>
    
      <category term="计算机通识" scheme="http://1eeing.github.io/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E9%80%9A%E8%AF%86/"/>
    
      <category term="学习笔记" scheme="http://1eeing.github.io/tags/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
      <category term="算法" scheme="http://1eeing.github.io/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="排序" scheme="http://1eeing.github.io/tags/%E6%8E%92%E5%BA%8F/"/>
    
      <category term="链表" scheme="http://1eeing.github.io/tags/%E9%93%BE%E8%A1%A8/"/>
    
  </entry>
  
  <entry>
    <title>【算法篇】时间复杂度与位运算</title>
    <link href="http://1eeing.github.io/2018/08/18/%E6%97%B6%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6%E4%B8%8E%E4%BD%8D%E8%BF%90%E7%AE%97/"/>
    <id>http://1eeing.github.io/2018/08/18/时间复杂度与位运算/</id>
    <published>2018-08-18T14:03:51.907Z</published>
    <updated>2018-08-18T14:05:28.071Z</updated>
    
    <content type="html"><![CDATA[<h1 id="时间复杂度"><a href="#时间复杂度" class="headerlink" title="时间复杂度"></a>时间复杂度</h1><p>通常使用最差的时间复杂度来衡量一个算法的好坏。</p><p>常数时间O(1)代表这个操作和数据量没关系，是一个固定时间的操作，比如说四则运算。</p><p>对于一个算法来说，可能会计算出如下操作次数 <code>aN + 1</code>，<code>N</code> 代表数据量。那么该算法的时间复杂度就是O(N)。因为我们在计算时间复杂度的时候，数据量通常是非常大的，这时候低阶项和常数项可以忽略不计。</p><a id="more"></a><p>当然可能会出现两个算法都是O(N)的时间复杂度，那么对比两个算法的好坏就要通过对比低阶项和常数项了。</p><hr><h1 id="位运算"><a href="#位运算" class="headerlink" title="位运算"></a>位运算</h1><p>位运算在算法中很有用，速度可以比四则运算快很多。</p><p>在学习位运算之前应该知道十进制如何转二进制，二进制如何转十进制。这里说明下简单的计算方式：</p><ul><li>十进制 <code>33</code> 可以看成是 <code>32 + 1</code> ，并且 <code>33</code> 应该是六位二进制的，因为 <code>33</code> 近似 <code>32</code>，而 <code>32</code> 是2的五次方，所以是六位，那么十进制 <code>33</code> 就是 <code>100001</code> ，只要是2的此房，那么就是1，否则都为0</li><li>二进制 <code>100001</code> 同理，首位是2^5，末位是2^0，相加得出 <code>33</code></li></ul><h2 id="左移-lt-lt"><a href="#左移-lt-lt" class="headerlink" title="左移 &lt;&lt;"></a>左移 &lt;&lt;</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">10</span> &lt;&lt; <span class="number">1</span> <span class="comment">// -&gt; 20</span></span><br></pre></td></tr></table></figure><p>左移就是将二进制全部往左移动，10在二进制中表示为1010，左移一位后变为10100，转变为10进制也就是20，所以基本可以把左移堪称是 <code>a * (2 ^ b)</code></p><h2 id="右移-gt-gt"><a href="#右移-gt-gt" class="headerlink" title="右移 &gt;&gt;"></a>右移 &gt;&gt;</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">10</span> &gt;&gt; <span class="number">1</span> <span class="comment">// -&gt; 5</span></span><br></pre></td></tr></table></figure><p>右移就是将二进制全部往右移动并去除多余的右边，所以右移等于 <code>a / (2 ^ b)</code></p><blockquote><p>右移很好用，比如可以用在二分算法取中间值</p></blockquote><h2 id="按位操作"><a href="#按位操作" class="headerlink" title="按位操作"></a>按位操作</h2><h3 id="按位与-amp"><a href="#按位与-amp" class="headerlink" title="按位与 &amp;"></a>按位与 &amp;</h3><p>每一位都为1，结果才为1<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">8</span> &amp; <span class="number">7</span></span><br><span class="line"><span class="comment">// 1000 &amp; 0111 -&gt; 0000 -&gt; 0</span></span><br></pre></td></tr></table></figure></p><h3 id="按位或"><a href="#按位或" class="headerlink" title="按位或 |"></a>按位或 |</h3><p>其中一位为1，结果就是1<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">8</span> | <span class="number">7</span></span><br><span class="line"><span class="comment">// 1000 | 0111 -&gt; 1111 -&gt; 15</span></span><br></pre></td></tr></table></figure></p><h3 id="按位异或"><a href="#按位异或" class="headerlink" title="按位异或 ^"></a>按位异或 ^</h3><p>每一位都不同，结果才为1<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">8</span> ^ <span class="number">7</span></span><br><span class="line"><span class="comment">// 1000 ^ 0111 -&gt; 1111 -&gt; 15</span></span><br><span class="line"></span><br><span class="line"><span class="number">8</span> ^ <span class="number">8</span></span><br><span class="line"><span class="comment">// 1000 ^ 1000 -&gt; 0000 -&gt; 0</span></span><br></pre></td></tr></table></figure></p><p>从以上代码中可以发现按位异或就是不进位加法</p><h3 id="两个数不使用四则运算得出和"><a href="#两个数不使用四则运算得出和" class="headerlink" title="两个数不使用四则运算得出和"></a>两个数不使用四则运算得出和</h3><p>这道题中可以按位异或，因为按位异或就是不进位加法， <code>8 ^ 8 = 0</code>，如果进位了，就是16了，所以我们只需要将两个数进行异或操作，然后进位。那么也就是说两个二进制都是1的位置，左边应该有一个进位1，所以可以得出以下公式 <code>a + b = (a ^ b) + ((a &amp; b) &lt;&lt; 1)</code> ，然后通过迭代的方式模拟加法。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">sum</span>(<span class="params">a, b</span>)</span>&#123;</span><br><span class="line">  <span class="keyword">if</span>(a == <span class="number">0</span>) <span class="keyword">return</span> b</span><br><span class="line">  <span class="keyword">if</span>(b == <span class="number">0</span>) <span class="keyword">return</span> a</span><br><span class="line">  <span class="keyword">let</span> newA = a ^ b;</span><br><span class="line">  <span class="keyword">let</span> newB = (a &amp; b) &lt;&lt; <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">return</span> sum(newA, newB);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;时间复杂度&quot;&gt;&lt;a href=&quot;#时间复杂度&quot; class=&quot;headerlink&quot; title=&quot;时间复杂度&quot;&gt;&lt;/a&gt;时间复杂度&lt;/h1&gt;&lt;p&gt;通常使用最差的时间复杂度来衡量一个算法的好坏。&lt;/p&gt;
&lt;p&gt;常数时间O(1)代表这个操作和数据量没关系，是一个固定时间的操作，比如说四则运算。&lt;/p&gt;
&lt;p&gt;对于一个算法来说，可能会计算出如下操作次数 &lt;code&gt;aN + 1&lt;/code&gt;，&lt;code&gt;N&lt;/code&gt; 代表数据量。那么该算法的时间复杂度就是O(N)。因为我们在计算时间复杂度的时候，数据量通常是非常大的，这时候低阶项和常数项可以忽略不计。&lt;/p&gt;
    
    </summary>
    
      <category term="学习笔记" scheme="http://1eeing.github.io/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="基础知识" scheme="http://1eeing.github.io/tags/%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"/>
    
      <category term="计算机通识" scheme="http://1eeing.github.io/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E9%80%9A%E8%AF%86/"/>
    
      <category term="学习笔记" scheme="http://1eeing.github.io/tags/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
      <category term="算法" scheme="http://1eeing.github.io/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="时间复杂度" scheme="http://1eeing.github.io/tags/%E6%97%B6%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6/"/>
    
      <category term="位运算" scheme="http://1eeing.github.io/tags/%E4%BD%8D%E8%BF%90%E7%AE%97/"/>
    
  </entry>
  
</feed>
