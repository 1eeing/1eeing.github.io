<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>leeing的登山之旅</title>
  
  <subtitle>前往空气稀薄地带</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://1eeing.github.io/"/>
  <updated>2019-03-14T16:27:41.632Z</updated>
  <id>http://1eeing.github.io/</id>
  
  <author>
    <name>leeing</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>带你走进Mobx的原理</title>
    <link href="http://1eeing.github.io/2019/03/15/Mobx%E5%8E%9F%E7%90%86/"/>
    <id>http://1eeing.github.io/2019/03/15/Mobx原理/</id>
    <published>2019-03-14T16:24:01.164Z</published>
    <updated>2019-03-14T16:27:41.632Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://img.alicdn.com/imgextra/i3/69942425/O1CN01TRJN9m1TmgxoSdgls_!!69942425.png" alt="https://img.alicdn.com/imgextra/i3/69942425/O1CN01TRJN9m1TmgxoSdgls_!!69942425.png"></p><blockquote><p>Mobx相信大家都听过，也有部分同学用过，在状态管理界，和Redux同日争辉。在本文中，将通过介绍Mobx的核心概念、设计原则及问答形式的方式，带大家走进Mobx的世界，一窥其中的原理。</p></blockquote><a id="more"></a><h1 id="核心概念"><a href="#核心概念" class="headerlink" title="核心概念"></a>核心概念</h1><h2 id="可观察状态（Observable-state）"><a href="#可观察状态（Observable-state）" class="headerlink" title="可观察状态（Observable state）"></a>可观察状态（Observable state）</h2><p>状态是驱动应用的数据。通常有像待办事项列表这样的领域特定状态，还有像当前已选元素的视图状态。记住，状态就像是有数据的excel表格。</p><h2 id="衍生（Derivations）"><a href="#衍生（Derivations）" class="headerlink" title="衍生（Derivations）"></a>衍生（Derivations）</h2><p>任何源自状态并且不会再有任何进一步的相互作用的东西就是衍生。衍生以多种形式存在</p><ul><li>用户界面</li><li>衍生数据，比如剩下的待办事项的数量</li><li>后端集成，比如把变化发送到服务器端</li></ul><p>Mobx区分了两种类型的衍生</p><ul><li>计算值（Computed values），它们是永远可以用纯函数从当前可观察状态中衍生出的值</li><li>反应（Reactions），它们是当状态改变时需要自动发生的副作用，用来连接命令式编程和响应式编程，最终都需要实现I/O操作，例如发送请求，更新页面等。</li></ul><h2 id="动作（Actions）"><a href="#动作（Actions）" class="headerlink" title="动作（Actions）"></a>动作（Actions）</h2><p>动作是任意一段可以改变状态的代码。用户事件，后端数据推送等。</p><p>Mobx中可以显示地定义动作，它可以帮你把代码组织的更清晰。严格模式下，Mobx强制要求只有Action可以修改状态。</p><h1 id="设计原则"><a href="#设计原则" class="headerlink" title="设计原则"></a>设计原则</h1><p>Mobx支持单向数据流，也就是动作改变状态，而状态的改变会更新所有受影响的图。</p><p>Action —&gt; State —&gt; Views</p><p>当状态改变时，所有衍生都会进行原子级的自动更新。因此永远不可能观察到中间值。</p><p>所有衍生默认都是同步更新的。这意味着动作可以在改变状态之后直接可以安全地检查计算值。</p><p>计算值是延迟更新的。任何不在使用状态的计算值将不会更新，直到需要它进行副作用（I/O）操作时。如果视图不再使用，那么它会自动被垃圾回收。</p><p>所有的计算值都应该是纯净的。它们不应该用来改变状态。</p><p><img src="https://img.alicdn.com/imgextra/i3/69942425/O1CN012mrjDL1TmgxpCItDo_!!69942425.png" alt="https://img.alicdn.com/imgextra/i3/69942425/O1CN012mrjDL1TmgxpCItDo_!!69942425.png"></p><h1 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h1><p>重要思想：在运行时才能实现最小、一致地订阅子集</p><p><strong>问：Mobx如何有效地将所有衍生保持在一个一致地状态？</strong><br>答：不缓存数据，在需要时重新计算。Mobx认为这是很高效地，因为Mobx不会计算所有衍生，只会计算确保参与反应的计算。这被称为响应式地。</p><p><strong>问：没有参与反应的衍生呢？</strong><br>答：如果一个衍生没有被激活，它将被按需处理。就像一个普通的getter函数一样，懒衍生如果没有用了，将被简单的垃圾回收。所有computed需要使用纯函数，因为对于纯函数而言，是懒衍生还是直接使用并不重要，在相同的状态下，总是返回相同的结果。</p><p><strong>问：当状态变化时，衍生是如何计算的？</strong><br>答：当重新计算被触发时，衍生函数将被压入到衍生堆栈中。只要计算正在运行，每个被访问的状态都会将自身注册为衍生堆栈最顶层函数的依赖项。当计算值被需要了，如果该值已经处于reactive状态，则该值可以简单最后已知的值，否则它将push自己到衍生堆栈中，切换到reactive模式并开始计算，具体计算过程如下：</p><ol><li><p>可观察值像所有观察者发送过时通知，表明它已经变得陈旧。任何受影响的衍生将以递归的<br>方式将通知传递给其观察者。因此，依赖关系树的一部分将被标记为陈旧。</p></li><li><p>在发送陈旧通知并存储新值后，一个就绪通知将被发送，用于指示该值是否确实发生了变化</p></li><li><p>一旦衍生收到步骤1中每个陈旧通知的就绪通知，它就会知道所有的被观察值都稳定了，于是将<br>开始重新计算。计算就绪和陈旧消息的数量可以确保这一点。</p></li><li><p>如果没有就绪通知指出一个值变化了，衍生将直接告诉自己的观察者它已经准备好了且没有变<br>化中的值</p></li></ol><p><strong>同步执行</strong><br>Mobx同步运行所有内容。这有2大好处：</p><ol><li>不可能观察陈旧的衍生</li><li>追踪堆栈和调试变得简单</li></ol><p>Mobx还提供事务机制。事务推迟所有就绪通知，直到事务块执行完成后，同步运行和更新所有内容。</p><p><img src="https://img.alicdn.com/imgextra/i3/69942425/O1CN01mjwTYc1TmgxqJXTJP_!!69942425.png" alt="https://img.alicdn.com/imgextra/i3/69942425/O1CN01mjwTYc1TmgxqJXTJP_!!69942425.png"></p><h1 id="对比Redux"><a href="#对比Redux" class="headerlink" title="对比Redux"></a>对比Redux</h1><ol><li>Redux将数据保存在单一store中，Mobx将数据保存在分散的多个store中</li><li>Redux需要手动处理变化后的操作，Mobx使用observable保存数据，数据变化后自动处理响应的操作</li><li>Redux使用不可变状态，不能直接去修改它，而是应该使用纯函数返回一个新的状态；Mobx中的状态是可以直接修改的</li></ol><h1 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h1><ul><li>demo示例：<a href="https://github.com/mobxjs/mobx-react-boilerplate" target="_blank" rel="noopener">https://github.com/mobxjs/mobx-react-boilerplate</a></li><li>深入理解Mobx：<a href="https://hackernoon.com/becoming-fully-reactive-an-in-depth-explanation-of-mobservable-55995262a254" target="_blank" rel="noopener">https://hackernoon.com/becoming-fully-reactive-an-in-depth-explanation-of-mobservable-55995262a254</a></li><li>Mobx官方文档：<a href="https://cn.mobx.js.org/" target="_blank" rel="noopener">https://cn.mobx.js.org/</a></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;https://img.alicdn.com/imgextra/i3/69942425/O1CN01TRJN9m1TmgxoSdgls_!!69942425.png&quot; alt=&quot;https://img.alicdn.com/imgextra/i3/69942425/O1CN01TRJN9m1TmgxoSdgls_!!69942425.png&quot;&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;Mobx相信大家都听过，也有部分同学用过，在状态管理界，和Redux同日争辉。在本文中，将通过介绍Mobx的核心概念、设计原则及问答形式的方式，带大家走进Mobx的世界，一窥其中的原理。&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="深入学习" scheme="http://1eeing.github.io/categories/%E6%B7%B1%E5%85%A5%E5%AD%A6%E4%B9%A0/"/>
    
    
      <category term="深入学习" scheme="http://1eeing.github.io/tags/%E6%B7%B1%E5%85%A5%E5%AD%A6%E4%B9%A0/"/>
    
      <category term="React" scheme="http://1eeing.github.io/tags/React/"/>
    
      <category term="Mobx" scheme="http://1eeing.github.io/tags/Mobx/"/>
    
  </entry>
  
  <entry>
    <title>【译】深入理解Mobx</title>
    <link href="http://1eeing.github.io/2019/03/08/%E3%80%90%E8%AF%91%E3%80%91%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Mobx/"/>
    <id>http://1eeing.github.io/2019/03/08/【译】深入理解Mobx/</id>
    <published>2019-03-07T17:50:56.573Z</published>
    <updated>2019-03-14T16:27:55.435Z</updated>
    
    <content type="html"><![CDATA[<p><img src="http://img0.imgtn.bdimg.com/it/u=1114646324,2521366840&amp;fm=26&amp;gp=0.jpg" alt="http://img0.imgtn.bdimg.com/it/u=1114646324,2521366840&amp;fm=26&amp;gp=0.jpg"></p><p>首先，先让我们看一下Mobx的核心概念。</p><ol><li><p><strong>可观察状态(Observable state)。</strong><br>任何可以变异且可以作为计算值源的值都是state。Mobx可以开箱即用地使绝大多数类型的值（基本类型，数组，类，对象）变成可观察的（甚至深度观察）。</p></li><li><p><strong>计算值(Computed values)。</strong><br>任何可观察的值可以使用纯函数计算得出任何值。计算值的范围可以从简单的字符串到复杂的对象甚至dom操作上。计算值会懒惰地对状态变化做出反应。</p></li><li><p><strong>反应(Reactions)。</strong><br>反应有点类似于计算值，但是它不产生新值，而是作为桥梁衔接了响应式编程和命令式编程，产生一个副作用（I/O操作），例如打印到控制台，发送网络请求，更新dom树等。</p></li><li><p><strong>操作(Actions)。</strong><br>操作是改变状态(state)的主要手段。操作不是状态改变后的反应，是改变的来源，例如用户事件或web-socket连接，用以改变可观察的状态。</p></li></ol><a id="more"></a><blockquote><p>计算值和反应在本文章的后续中都称为衍生(derivations)。到目前为止，这听起来可能有点学术性，所以，我们让它具体点。在excel电子表格中，所有具有值的数据单元格都是可观察状态的，公式和图标是可以从数据单元格和其他公式衍生的计算值。在屏幕上绘制数据单元格或公式的结果就是一个反应(reaction)，改变数据单元格或公式就是一个操作(action)</p></blockquote><p>下面这个例子结合了Mobx和React，并且包含了以上4个概念：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">  @observable firstName = <span class="string">"Michel"</span>;</span><br><span class="line">  @observable lastName = <span class="string">"Weststrate"</span>;</span><br><span class="line">  @observable nickName;</span><br><span class="line">  </span><br><span class="line">  @computed get fullName() &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.firstName + <span class="string">" "</span> + <span class="keyword">this</span>.lastName;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> michel = <span class="keyword">new</span> Person();</span><br><span class="line"></span><br><span class="line"><span class="comment">// Reaction: log the profile info whenever it changes</span></span><br><span class="line">autorun(<span class="function"><span class="params">()</span> =&gt;</span> <span class="built_in">console</span>.log(person.nickName ? person.nickName : person.fullName));</span><br><span class="line"></span><br><span class="line"><span class="comment">// Example React component that observes state</span></span><br><span class="line"><span class="keyword">const</span> profileView = observer(<span class="function"><span class="params">props</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">if</span> (props.person.nickName)</span><br><span class="line">    <span class="keyword">return</span> &lt;div&gt;&#123;props.person.nickName&#125;&lt;/div&gt;</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">    <span class="keyword">return</span> &lt;div&gt;&#123;props.person.fullName&#125;&lt;/div&gt;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// Action:</span></span><br><span class="line">setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> michel.nickName = <span class="string">"mweststrate"</span>, <span class="number">5000</span>)</span><br><span class="line"></span><br><span class="line">React.render(React.createElement(profileView, &#123; <span class="attr">person</span>: michel &#125;), <span class="built_in">document</span>.body);</span><br><span class="line"><span class="comment">// This snippet is runnable in jsfiddle: https://jsfiddle.net/mweststrate/049r6jox/</span></span><br><span class="line">view rawprofile.jsx hosted <span class="keyword">with</span> ❤ by GitHub</span><br></pre></td></tr></table></figure><p>我们可以画一张依赖图：</p><p><img src="https://cdn-images-1.medium.com/max/1600/1*YPlKuWsPrVbhxUN7YhyTpg.png" alt="https://cdn-images-1.medium.com/max/1600/1*YPlKuWsPrVbhxUN7YhyTpg.png"><br>Figure 1：profileView组件的依赖关系树。fullName处于reactive mode，主动观察firstName和lastName</p><p>这个应用中，状态由可观察状态捕获（蓝色图标）。绿色的fullName是计算值，由可观察状态firstName和lastName自动衍生得出。同样，profileView由nickName和fullName衍生得出。profileView将通过产生副作用来响应状态更改——它更新React组件树。</p><p>当使用Mobx时，依赖关系树被最低限度定义。举个例子，一旦profileView的有了nickName，且渲染不再受fullName的值的影响，也不受firstName和lastName的影响，那么他们之间所有的观察者关系将被清除，Mobx将自动的简化依赖树，如下图：</p><p><img src="https://cdn-images-1.medium.com/max/1600/1*SXiDJ_mQ0ctEj2QEurLpqA.png" alt="https://cdn-images-1.medium.com/max/1600/1*SXiDJ_mQ0ctEj2QEurLpqA.png"><br>Figure 2：当profileView具有nickName时的依赖关系树，与Figure 1相反，fullName现在处于lazy mode，且不再观察firstName和lastName</p><p>Mobx总是使用最小化计算次数去产生状态。接下来，我将介绍用于实现此目标的几种策略，但在深入了解计算值和反应如何与状态同步之前，让我们首先描述Mobx背后的原理：</p><p><strong>对状态变化做出反应总是比对状态变化做出动作要好。（Reacting to state changes is always better then acting on state changes.）</strong></p><p>应用程序响应状态更改的必要操作是通常会创建或更新一些值，大多数的操作(actions)管理着本地缓存。dom更新、批量更新值、请求后端，这些都可以被认为变相地使缓存失效。要确保这些缓存保持同步，你需要订阅(subscribe)未来的状态更改，以便再次触发你的操作。</p><p>但是观察者模式有一个基本的问题：当你的应用变大时，你可能会犯错，比如依然订阅不再使用的值或忘记订阅一些值。</p><p>像flux风格的订阅很容易出现这种超额订阅的情况。使用React时，你可以通过在渲染中打印来判断你的组件是否被超额订阅了。Mobx会将打印出的超额订阅数减少到0。这个想法很简单但违反直觉：订阅越多，重新计算越少。Mobx为你管理数千个观察者，你可以有效地权衡内存的CPU周期。</p><p>超额订阅也以非常微妙的形式存在。如果你订阅了使用的数据，但并未在所有条件下订阅，那么你依然需要超额订阅。例如，如果profileView组件订阅了fullName，并且profileView有nickName，这就将超额订阅。因此Mobx设计背后的一个重要原则是：</p><p><strong>在运行时才能实现最小、一致地订阅子集（A minimal, consistent set of subscriptions can only be achieved if subscriptions are determined at run-time）。</strong></p><p>Mobx背后的第二个重要思想是，对于任何比TodoMVC更复杂的应用程序，通常需要一个数据图而不是规范化的树，以一种最佳方式存储状态。数据图可以实现参照一致性并避免数据重复，从而保证衍生值永远不会过时。</p><p><strong>Mobx如何有效地将所有衍生保持在一个一致地状态？</strong></p><p>答案是：不缓存，只有在需要时再重新计算衍生。这不是很昂贵吗？Mobx认为不是，反而这是很高效地。原因是Mobx不会运行所有衍生，但确保参与reaction的computed values与可观察状态保持同步。这些衍生被称为响应式的。再次以excel举例：只有当那些被观察着的当前可见或被间接使用的公式发生变化时，才会去重新计算值。</p><p><strong>Lazy versus reactive evaluation</strong></p><p>那么反应没有直接或间接使用的计算呢？你依然可以随时检查计算值的值，如fullName。答案是简单的：如果一个计算不是reactive的，它将被按需处理。就像一个普通的getter函数一样。懒衍生如果没有用了，将被简单的垃圾回收。记住computed values总是需要使用纯函数，因为对于纯函数而言，它是懒衍生还是直接使用并不重要。在相同的可观察状态下，computed values总是给出相同的结果。</p><p><strong>运行计算</strong></p><p>Reaction和Computed values在Mobx中都以相同的方式运行。当重新计算被触发时，该函数将被压入到衍生堆栈中。只要计算正在运行，每个被访问的observable都会将自身注册为衍生堆栈最顶层函数的依赖项。当computed value被需要了，如果该值处于reactive状态，则该值可以简单的是最后已知的值。否则它将push自己到衍生堆栈中，切换到reactive模式并开始计算。</p><p><img src="https://cdn-images-1.medium.com/max/800/1*Pb3Wd14BlXPgqylBN_y-hQ.png" alt="https://cdn-images-1.medium.com/max/800/1*Pb3Wd14BlXPgqylBN_y-hQ.png"><br>Figure 4：profileView执行期间，一些observable state和computed values被观察着。computed values可能重新计算，这会产生依赖关系树，如Figure 1所示。</p><p>当一个计算完成后，将得到在执行期间访问的可观察列表。在profileView的例子中，这个list将只包含nickName或nickName和fullName属性。任何被移除的属性都将不再观察（此时computed values可能会从反应模式返回到惰性模式），任何被添加的可观察属性将被观察，直到下一次计算。例如，将来将更改firstName的值，fullName将会知道自己该被重新计算，从而profileView会重新计算。接下来会详细解释这一过程。</p><p><strong>传播状态变化</strong></p><p><img src="https://cdn-images-1.medium.com/max/800/1*Et95GdR7OeOofl_V0Od4iA.png" alt="https://cdn-images-1.medium.com/max/800/1*Et95GdR7OeOofl_V0Od4iA.png"></p><p>Figure 5：更改值1对依赖关系树的影响。虚线表示将被标记为旧的观察者。数字表示计算的顺序。</p><p>衍生将自动对状态变化做出反应。所有反应同步发生，更重要的是无瑕疵。修改可观察值时，将执行以下算法：</p><ol><li><p>可观察值向所有观察者发送过时通知，表明它已变得陈旧。任何受影响的computed values将以递归方式将通知传递给其观察者。因此，依赖关系树的一部分将被标记为陈旧。以Figure 5为例，当值1改变时观察者将变成陈旧的，并用橘色虚线标记。所有的衍生都可能被变化的值影响。</p></li><li><p>在发送陈旧通知并且存储新值之后，一个就绪通知将被发送。用于指示该值是否确实发生了变化。</p></li><li><p>一旦衍生收到步骤1中收到的每个陈旧通知的就绪通知，它就会知道所有的被观察值都稳定了，于是将开始重新计算。计算 就绪/陈旧 消息的数量将确保这一点。例如，计算值4将仅在计算值3变得稳定后重新计算。</p></li><li><p>如果没有就绪消息指出一个值变化了，衍生将直接告诉自己的观察者它已经准备好了且没有变化中的值，否则将重新计算并发送一个就绪消息给自己的观察者。执行顺序如Figure 5所示。注意，如果计算值4重新评估但没有产生新值，则最后一个“-”将永远不会执行。</p></li></ol><p>前两段总结了如何在运行时跟踪可观察值和衍生之间的依赖关系以及变化在衍生中是如何传播的。此时你会发现reaction基本上就是一个始终处于反应模式的computed value。<strong>重点：这个算法可以非常有效地实现而不需要闭包，只需要一堆指针数组。</strong>另外，Mobx还应用了许多其他优化，这些优化超出了本文的范围。</p><p><strong>同步执行</strong></p><p>人们常惊讶于Mobx同步运行所有内容。这有两大好处：第一点是不可能观察陈旧的衍生。因此，在更改影响它的值后，可以立即使用衍生值。第二点是这让追踪堆栈和调试变得简单，它避免了Promise/Async库所特有的无用堆栈跟踪。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">transaction(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">  michel.firstName = <span class="string">"Mich"</span>;</span><br><span class="line">  michel.lastName = <span class="string">"W."</span>;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>(事务示例，它确保没有人能追踪到像Michaaa这样的中间值)</p><p>同步执行还引入了对事务的需求。如果立即连续应用几个突变，在应用所有更改后，最好重新评估所有衍生。在transaction中包装action能实现这个目的。事务推迟所有就绪通知，直到事务块执行完成。请注意，事务仍然同步运行和更新所有内容。</p><p>这总结了Mobx最基本的实现细节。这没有涵盖所有内容，但是很高兴你可以组合你的computed value了。通过组合reactive computations，甚至可以自动的将一张数据图转换为另一张数据图并用最少的补丁数保持最新的衍生，这使得实现复杂模式变得简单。</p><p><strong>总结</strong></p><ol><li><p>复杂应用程序的状态最好用图表表示，以实现参考一致性，更接近问题核心的心理模型。</p></li><li><p>不应该使用手动定义的订阅或游标来强制更改状态，这将不可避免的导致由于订阅不足或超额订阅导致的错误。</p></li><li><p>使用运行时分析来确定最小的observer-&gt;observable的关系，这导致了一种计算模型，可以保证在没有观察过期值的情况下运行最小量的衍生。</p></li><li><p>任何不需要实现有效副作用的衍生都可以完全优化。</p></li></ol><p><strong>原文地址</strong><br><a href="https://hackernoon.com/becoming-fully-reactive-an-in-depth-explanation-of-mobservable-55995262a254" target="_blank" rel="noopener">https://hackernoon.com/becoming-fully-reactive-an-in-depth-explanation-of-mobservable-55995262a254</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;http://img0.imgtn.bdimg.com/it/u=1114646324,2521366840&amp;amp;fm=26&amp;amp;gp=0.jpg&quot; alt=&quot;http://img0.imgtn.bdimg.com/it/u=1114646324,2521366840&amp;amp;fm=26&amp;amp;gp=0.jpg&quot;&gt;&lt;/p&gt;
&lt;p&gt;首先，先让我们看一下Mobx的核心概念。&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;p&gt;&lt;strong&gt;可观察状态(Observable state)。&lt;/strong&gt;&lt;br&gt;任何可以变异且可以作为计算值源的值都是state。Mobx可以开箱即用地使绝大多数类型的值（基本类型，数组，类，对象）变成可观察的（甚至深度观察）。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;strong&gt;计算值(Computed values)。&lt;/strong&gt;&lt;br&gt;任何可观察的值可以使用纯函数计算得出任何值。计算值的范围可以从简单的字符串到复杂的对象甚至dom操作上。计算值会懒惰地对状态变化做出反应。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;strong&gt;反应(Reactions)。&lt;/strong&gt;&lt;br&gt;反应有点类似于计算值，但是它不产生新值，而是作为桥梁衔接了响应式编程和命令式编程，产生一个副作用（I/O操作），例如打印到控制台，发送网络请求，更新dom树等。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;strong&gt;操作(Actions)。&lt;/strong&gt;&lt;br&gt;操作是改变状态(state)的主要手段。操作不是状态改变后的反应，是改变的来源，例如用户事件或web-socket连接，用以改变可观察的状态。&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
    
    </summary>
    
      <category term="译文" scheme="http://1eeing.github.io/categories/%E8%AF%91%E6%96%87/"/>
    
    
      <category term="React" scheme="http://1eeing.github.io/tags/React/"/>
    
      <category term="Mobx" scheme="http://1eeing.github.io/tags/Mobx/"/>
    
      <category term="译文" scheme="http://1eeing.github.io/tags/%E8%AF%91%E6%96%87/"/>
    
  </entry>
  
  <entry>
    <title>深入了解React之Reconciliation</title>
    <link href="http://1eeing.github.io/2019/01/18/Reconciliation/"/>
    <id>http://1eeing.github.io/2019/01/18/Reconciliation/</id>
    <published>2019-01-17T16:31:40.712Z</published>
    <updated>2019-01-17T16:32:46.243Z</updated>
    
    <content type="html"><![CDATA[<h1 id="动机"><a href="#动机" class="headerlink" title="动机"></a>动机</h1><p>在使用React时，在单个时间点钟，可以将render函数视为创建React元素树。在下一个state或props更新时，render函数将返回一个不同的React元素树。然后，React需要弄清楚如何有效地更新UI以匹配最新的树。</p><p>这个算法问题有一些通用的解决方案，既生成将一棵树转换成另一棵树的最小操作次数。然而，现有技术的算法具有O(n^3)的复杂度，其中n是书中元素的数量。简单来说，对比两棵树需要的时间复杂度是O(n^2)，操作一棵树（移动、创建、删除）时需要遍历一次树，因此时间复杂度是O(n^3)。</p><p>如果在React中使用它，显示1000个元素将需要10亿次对比。这消耗太大了。<br>因此，React基于两个假设实现了一个启发式O(n)算法：</p><a id="more"></a><ol><li>不同类型的两个元素将产生不同的树</li><li>可以通过key来指定哪些子元素可以在不同渲染中保持稳定</li></ol><h1 id="diff算法"><a href="#diff算法" class="headerlink" title="diff算法"></a>diff算法</h1><p>在区分两棵树时，React首先会比较两个根元素。根据根元素的类型，行为会有所不同。</p><h2 id="不同类型的元素"><a href="#不同类型的元素" class="headerlink" title="不同类型的元素"></a>不同类型的元素</h2><p>每当根元素具有不同的类型时，React将拆除旧树并从头开始构建新树。从<code>&lt;a&gt;</code>到<code>&lt;img&gt;</code>，或从<code>&lt;Article&gt;</code>到<code>&lt;Comment&gt;</code>，都将导致完全重建。</p><p>在拆除树时，旧dom节点将被销毁。组件实例接收componentWillUnMount()。<br>构建新树时，会将新dom节点插入到dom中。组件实例接收componentWillMount()，然后接收componentDidMount()。与旧树相关联的任何状态都将丢失。</p><p>root下面的任何组件也将被卸载并且其状态被破坏。例如<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&lt;div&gt;</span><br><span class="line">  &lt;Counter /&gt;</span><br><span class="line">&lt;/div&gt;</span><br><span class="line"></span><br><span class="line">&lt;span&gt;</span><br><span class="line">  &lt;Counter /&gt;</span><br><span class="line">&lt;/span&gt;</span><br></pre></td></tr></table></figure></p><p>这会导致旧的<code>&lt;Counter&gt;</code>被破坏，并新建一个。</p><h2 id="相同类型的dom元素"><a href="#相同类型的dom元素" class="headerlink" title="相同类型的dom元素"></a>相同类型的dom元素</h2><p>当比较两个相同类型的React DOM元素时，React查看两者的属性，保持相同的底层dom节点，并仅更新更改的属性。例如：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;div className=&quot;before&quot; title=&quot;stuff&quot; /&gt;</span><br><span class="line"></span><br><span class="line">&lt;div className=&quot;after&quot; title=&quot;stuff&quot; /&gt;</span><br></pre></td></tr></table></figure></p><p>通过比较这两个元素，React知道只修改底层dom节点上的className。</p><p>更新样式时，React也知道只更新已更改的属性。例如：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;div style=&#123;&#123;color: &apos;red&apos;, fontWeight: &apos;bold&apos;&#125;&#125; /&gt;</span><br><span class="line"></span><br><span class="line">&lt;div style=&#123;&#123;color: &apos;green&apos;, fontWeight: &apos;bold&apos;&#125;&#125; /&gt;</span><br></pre></td></tr></table></figure></p><p>在这两个元素之间进行转换时，React知道只修改颜色样式，而不是fontWeight。<br>在处理dom节点之后，React对子节点进行递归。</p><h2 id="相同类型的组件元素"><a href="#相同类型的组件元素" class="headerlink" title="相同类型的组件元素"></a>相同类型的组件元素</h2><p>当组件更新时，实例保持不变，以便在渲染之间保持状态。React更新底层组件实例的props以匹配新元素，并在底层实例上调用componentWillReceiveProps()和componentWillUpdate()。</p><p>接下来，调用render()方法，diff算法开始递归计算前一个结果和新结果</p><h1 id="子节点的递归"><a href="#子节点的递归" class="headerlink" title="子节点的递归"></a>子节点的递归</h1><p>默认情况下，当对dom节点的子节点进行递归时，React会同时迭代两个子节点列表，并在出现差异时生成突变。</p><p>例如，在子节点末尾添加元素时，在两个树之间进行转换效果很好<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&lt;ul&gt;</span><br><span class="line">  &lt;li&gt;first&lt;/li&gt;</span><br><span class="line">  &lt;li&gt;second&lt;/li&gt;</span><br><span class="line">&lt;/ul&gt;</span><br><span class="line"></span><br><span class="line">&lt;ul&gt;</span><br><span class="line">  &lt;li&gt;first&lt;/li&gt;</span><br><span class="line">  &lt;li&gt;second&lt;/li&gt;</span><br><span class="line">  &lt;li&gt;third&lt;/li&gt;</span><br><span class="line">&lt;/ul&gt;</span><br></pre></td></tr></table></figure></p><p>React将对比两个<code>&lt;li&gt;first&lt;/li&gt;</code>和两个<code>&lt;li&gt;second&lt;/li&gt;</code>，然后插入<code>&lt;li&gt;third&lt;/li&gt;</code>。</p><p>如果你在开头插入一个元素，那会有糟糕的表现。例如<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&lt;ul&gt;</span><br><span class="line">  &lt;li&gt;Duke&lt;/li&gt;</span><br><span class="line">  &lt;li&gt;Villanova&lt;/li&gt;</span><br><span class="line">&lt;/ul&gt;</span><br><span class="line"></span><br><span class="line">&lt;ul&gt;</span><br><span class="line">  &lt;li&gt;Connecticut&lt;/li&gt;</span><br><span class="line">  &lt;li&gt;Duke&lt;/li&gt;</span><br><span class="line">  &lt;li&gt;Villanova&lt;/li&gt;</span><br><span class="line">&lt;/ul&gt;</span><br></pre></td></tr></table></figure></p><p>React将改变每个children，而不是意识到它可以保持<code>&lt;li&gt;Duke&lt;/li&gt;</code>和<code>&lt;li&gt;Villanova&lt;/li&gt;</code>不变。这种低效率可能是一个问题。</p><h1 id="keys"><a href="#keys" class="headerlink" title="keys"></a>keys</h1><p>为了解决这个问题，React支持一个key属性。当children有key时，React使用key来匹配旧树和新树中的children。例如，在上面的低效示例中添加一个key可以使树转换有效：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&lt;ul&gt;</span><br><span class="line">  &lt;li key=&quot;2015&quot;&gt;Duke&lt;/li&gt;</span><br><span class="line">  &lt;li key=&quot;2016&quot;&gt;Villanova&lt;/li&gt;</span><br><span class="line">&lt;/ul&gt;</span><br><span class="line"></span><br><span class="line">&lt;ul&gt;</span><br><span class="line">  &lt;li key=&quot;2014&quot;&gt;Connecticut&lt;/li&gt;</span><br><span class="line">  &lt;li key=&quot;2015&quot;&gt;Duke&lt;/li&gt;</span><br><span class="line">  &lt;li key=&quot;2016&quot;&gt;Villanova&lt;/li&gt;</span><br><span class="line">&lt;/ul&gt;</span><br></pre></td></tr></table></figure></p><p>现在React知道具有key2014的元素时新元素，并且2015和2016元素刚刚移动。</p><p>在实践中，找到key通常不难。它可能来自你的数据：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;li key=&#123;item.id&#125;&gt;&#123;item.name&#125;&lt;/li&gt;</span><br></pre></td></tr></table></figure></p><p>如果不是这种情况，你可以向模型添加新的id属性，或者对内容的某些部分进行hash编码以生存密钥。关键只需要在其兄弟姐妹中独一无二，而不是全树独一无二。</p><p>实在不行，可以将数组中的项目索引作为key。如果项目从不重新排序，这可以很好的工作，但重新排序将很慢。</p><p>当索引用作key时，重新排序也会导致组件状态出现问题。组件实例根据key进行更新和重用。如果key是索引，则移动项目会更改它。因此，诸如非受控组件的状态可能会以意想不到的方式混淆和更新。</p><h1 id="权衡"><a href="#权衡" class="headerlink" title="权衡"></a>权衡</h1><p>牢记协调算法的实现细节非常重要。React可以在每个动作上重新呈现整个应用程序，而最终结果是一样的。为了清楚可见，在这种情况下重新渲染意味着为所有组件调用渲染，但这并不意味着React将卸载并重新安装它们。它只会按照前面章节中规定的规则应用差异。</p><p>在当前的实现中，可以表明一个事实，即子树在其兄弟节点中移动，但你无法告知其移动到哪。该算法会重新渲染整个子树。</p><p>因为React依赖于启发式方法，如果不满足它们背后的假设，性能将受到影响。</p><ol><li>该算法不会尝试匹配不同组件类型的子树。如果你发现自己在具有非常相似输出的两种组件类型之间交替，则可能需要使其成为相同类型。</li><li>key应该是稳定的，可预测的和独特的。不稳定的key将导致许多组件实例和dom节点被不必要地重建，这可能导致性能下降和并丢失子组件的状态。</li></ol>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;动机&quot;&gt;&lt;a href=&quot;#动机&quot; class=&quot;headerlink&quot; title=&quot;动机&quot;&gt;&lt;/a&gt;动机&lt;/h1&gt;&lt;p&gt;在使用React时，在单个时间点钟，可以将render函数视为创建React元素树。在下一个state或props更新时，render函数将返回一个不同的React元素树。然后，React需要弄清楚如何有效地更新UI以匹配最新的树。&lt;/p&gt;
&lt;p&gt;这个算法问题有一些通用的解决方案，既生成将一棵树转换成另一棵树的最小操作次数。然而，现有技术的算法具有O(n^3)的复杂度，其中n是书中元素的数量。简单来说，对比两棵树需要的时间复杂度是O(n^2)，操作一棵树（移动、创建、删除）时需要遍历一次树，因此时间复杂度是O(n^3)。&lt;/p&gt;
&lt;p&gt;如果在React中使用它，显示1000个元素将需要10亿次对比。这消耗太大了。&lt;br&gt;因此，React基于两个假设实现了一个启发式O(n)算法：&lt;/p&gt;
    
    </summary>
    
      <category term="深入学习" scheme="http://1eeing.github.io/categories/%E6%B7%B1%E5%85%A5%E5%AD%A6%E4%B9%A0/"/>
    
    
      <category term="深入学习" scheme="http://1eeing.github.io/tags/%E6%B7%B1%E5%85%A5%E5%AD%A6%E4%B9%A0/"/>
    
      <category term="React" scheme="http://1eeing.github.io/tags/React/"/>
    
      <category term="Reconciliation" scheme="http://1eeing.github.io/tags/Reconciliation/"/>
    
  </entry>
  
  <entry>
    <title>深入了解React之Fiber</title>
    <link href="http://1eeing.github.io/2019/01/18/Fiber/"/>
    <id>http://1eeing.github.io/2019/01/18/Fiber/</id>
    <published>2019-01-17T16:29:57.000Z</published>
    <updated>2019-01-17T16:31:26.816Z</updated>
    
    <content type="html"><![CDATA[<h1 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h1><p>React 16种加入的新的react核心算法。也可理解为虚拟堆栈帧。</p><h1 id="Fiber的驱动理念"><a href="#Fiber的驱动理念" class="headerlink" title="Fiber的驱动理念"></a>Fiber的驱动理念</h1><ol><li>在UI中，不必立即应用每个更新，这样做可能会浪费，导致丢帧并降低用户体验</li><li>不同类型的更新具有不同的优先级，动画更新需要比数据存储更新更快地完成</li><li>基于推送的方法需要开发者决定如何安排工作，基于拉取的方法允许框架变得聪明并为你做出决策</li></ol><a id="more"></a><h1 id="什么是fiber（重要）"><a href="#什么是fiber（重要）" class="headerlink" title="什么是fiber（重要）"></a>什么是fiber（重要）</h1><p>使React能够实现调度（scheduling），具体如下</p><ol><li>暂停工作，稍后再回来</li><li>为不同类型的工作分配优先权</li><li>重用以前完成的工作</li><li>如果不再需要，则中止工作</li></ol><p>为了做到这一点，我们首先需要一种将工作分解为单元的方法，这种方法，就可以称之为Fiber。<br>在处理UI时，问题在于如果同时执行太多工作，则可能导致动画丢帧并且看起来不稳定。更重要的是，如果它被更新的更新取代，那么其中一些工作可能不是必要的。这是ui组件和funtion之间的差异，因为组件比一般的功能有更多特定的关注点。</p><p>有2个api实现了有助于解决这个问题的api</p><ul><li>requestIdleCallback，调度在空闲期间调用的低优先级函数</li><li>requestAnimationFrame，调度在下一个动画帧上调用的高优先级函数</li></ul><p>所以，为了使用这些API，需要一种方法将渲染工作分解为增量单元。如果仅依赖于调用堆栈，它将持续工作直到堆栈为空。</p><p>如果我们可以自定义调用堆栈的行为以优化渲染UI，随意终端调用堆栈并手动操作对战阵，那不是很好吗？这就是React Fiber的目的。</p><p>Fiber是堆栈的重新实现，专门用于React组件，可以将单根fiber视为虚拟堆栈帧。<br>重新实现堆栈的优点是，你可以将堆栈帧保留在内存中，然后想执行的时候就执行它们。这对于实现我们的调度目标至关重要。除了调度之外，手动处理堆栈帧还可以释放并发和错误边界等功能。</p><h1 id="fiber的结构"><a href="#fiber的结构" class="headerlink" title="fiber的结构"></a>fiber的结构</h1><p>fiber是一个javascript对象，里面包含有这些属性</p><h2 id="type和key"><a href="#type和key" class="headerlink" title="type和key"></a>type和key</h2><p>从ReactElements复制过来，用途也一样</p><h2 id="child和sibling"><a href="#child和sibling" class="headerlink" title="child和sibling"></a>child和sibling</h2><p>指向其他的fiber，描述fiber的递归树结构</p><h2 id="return"><a href="#return" class="headerlink" title="return"></a>return</h2><p>返回父fiber</p><h2 id="pendingProps和memoizedProps"><a href="#pendingProps和memoizedProps" class="headerlink" title="pendingProps和memoizedProps"></a>pendingProps和memoizedProps</h2><p>是一个function的参数。在执行开始前，设置pendingProps，在结束时设置memoizedProps。当传入的pendingProps和memoizedProps相等时，表示fiber先前的输出可以重复使用，从而防止不必要的工作。</p><h2 id="pendingWorkPriority"><a href="#pendingWorkPriority" class="headerlink" title="pendingWorkPriority"></a>pendingWorkPriority</h2><p>一个代表fiber工作优先级的数字</p><h2 id="alternate"><a href="#alternate" class="headerlink" title="alternate"></a>alternate</h2><p><strong><em>flush</em></strong><br>将fiber呈现在屏幕上</p><p><strong><em>work-in-process</em></strong><br>未完成的fiber。</p><p>当前fiber的备用是work-in-process<br>work-in-process的替代是当前fiber<br>使用cloneFiber函数创建fiber，而不是总是创建一个新对象，cloneFiber将尝试重用Fiber的备用，如果它存在，最小化分配（最新代码库中没有找到）</p><h2 id="output"><a href="#output" class="headerlink" title="output"></a>output</h2><p>告诉渲染器需要更改的部分</p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;介绍&quot;&gt;&lt;a href=&quot;#介绍&quot; class=&quot;headerlink&quot; title=&quot;介绍&quot;&gt;&lt;/a&gt;介绍&lt;/h1&gt;&lt;p&gt;React 16种加入的新的react核心算法。也可理解为虚拟堆栈帧。&lt;/p&gt;
&lt;h1 id=&quot;Fiber的驱动理念&quot;&gt;&lt;a href=&quot;#Fiber的驱动理念&quot; class=&quot;headerlink&quot; title=&quot;Fiber的驱动理念&quot;&gt;&lt;/a&gt;Fiber的驱动理念&lt;/h1&gt;&lt;ol&gt;
&lt;li&gt;在UI中，不必立即应用每个更新，这样做可能会浪费，导致丢帧并降低用户体验&lt;/li&gt;
&lt;li&gt;不同类型的更新具有不同的优先级，动画更新需要比数据存储更新更快地完成&lt;/li&gt;
&lt;li&gt;基于推送的方法需要开发者决定如何安排工作，基于拉取的方法允许框架变得聪明并为你做出决策&lt;/li&gt;
&lt;/ol&gt;
    
    </summary>
    
      <category term="深入学习" scheme="http://1eeing.github.io/categories/%E6%B7%B1%E5%85%A5%E5%AD%A6%E4%B9%A0/"/>
    
    
      <category term="深入学习" scheme="http://1eeing.github.io/tags/%E6%B7%B1%E5%85%A5%E5%AD%A6%E4%B9%A0/"/>
    
      <category term="React" scheme="http://1eeing.github.io/tags/React/"/>
    
      <category term="Fiber" scheme="http://1eeing.github.io/tags/Fiber/"/>
    
  </entry>
  
  <entry>
    <title>手把手教你用node撸一个图片压缩工具</title>
    <link href="http://1eeing.github.io/2018/10/27/imgMin/"/>
    <id>http://1eeing.github.io/2018/10/27/imgMin/</id>
    <published>2018-10-26T17:22:20.650Z</published>
    <updated>2018-10-26T17:34:30.703Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://tinypng.com/images/social/developer-api.jpg" alt="https://tinypng.com/images/social/developer-api.jpg"></p><blockquote><p>上篇文章中我们提到了用node撸一个简易的爬虫，本次基于上一篇文章中的项目<a href="https://github.com/1eeing/get_picture" target="_blank" rel="noopener">get_picture</a>给大家分享下我是如何用node撸一个图片压缩工具的。</p></blockquote><p><strong>历史</strong>：<br><a href="https://juejin.im/post/5bc717f4f265da0abf7d16d3" target="_blank" rel="noopener">《手把手教你用node撸一个简易的headless爬虫cli工具》</a></p><a id="more"></a><h1 id="tinypng"><a href="#tinypng" class="headerlink" title="tinypng"></a>tinypng</h1><p>依然是先介绍一下工具，本次我们主要用到了 <code>tinypng</code> 这个工具。tinypng是一个主流的图片压缩工具，他可以实现高保真的压缩我们的图片，一般我们可以进入他的官网<a href="https://tinypng.com/" target="_blank" rel="noopener">https://tinypng.com/</a>压缩图片，手动点击上传，但是每次只能压缩20张，这对于追求方便的我们来说肯定是不能满足的。我们需要一次性将所有图片都压缩！</p><p>这怎么办呢？tinypng官网十分的人性化，提供了各种服务端直接调用的接口，我们点开他的<a href="https://tinypng.com/developers/reference" target="_blank" rel="noopener">文档</a>看一看，找到node.js，通过<code>npm i --save tinify</code>安装在我们的项目中，其次可以看到他提供了各种各样的功能，包括<code>压缩图片</code>、<code>resize图片</code>、<code>上传cdn</code>等。我们主要用到了他的<code>压缩图片</code>、<code>验证key</code>、<code>查看已用数</code>。</p><h1 id="目录结构"><a href="#目录结构" class="headerlink" title="目录结构"></a>目录结构</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">|-- Documents</span><br><span class="line">    |-- .gitignore</span><br><span class="line">    |-- README.md</span><br><span class="line">    |-- package.json</span><br><span class="line">    |-- bin</span><br><span class="line">    |   |-- gp</span><br><span class="line">    |-- output</span><br><span class="line">    |   |-- .gitkeeper</span><br><span class="line">    |-- src</span><br><span class="line">        |-- app.js</span><br><span class="line">        |-- clean.js</span><br><span class="line">        |-- imgMin.js</span><br><span class="line">        |-- index.js</span><br><span class="line">        |-- config</span><br><span class="line">        |   |-- default.js</span><br><span class="line">        |-- helper</span><br><span class="line">            |-- questions.js</span><br><span class="line">            |-- regMap.js</span><br><span class="line">            |-- srcToImg.js</span><br><span class="line">            |-- tinify.js</span><br></pre></td></tr></table></figure><p>基于上一个项目，我们新增了两个文件</p><ul><li>/src/imgMin.js。即我们的主文件。</li><li>/src/helper/tinify.js。主要用于操作tinypng的相关API</li></ul><h1 id="主文件"><a href="#主文件" class="headerlink" title="主文件"></a>主文件</h1><p>在主文件中，我们主要用到了<code>node</code>的<code>fs模块</code>。<br>首先我们会判断输入的key是否有效，其次我们会判断该key剩余可用数是不是小于0，如果没问题的话，我们就开始查找检索路径下的所有文件。</p><p><strong>检索路径</strong><br>首先我们会通过<code>fs.stat</code>判断该路径是否是文件夹，如果是，则通过<code>fs.readdir</code>获取当前文件列表，遍历后然后将其传给获取图片方法。注意这边有个坑点，因为我们的操作几乎都是异步操作，所以我一开始也很理所当然的用了forEach来遍历，伪代码如下<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">files.forEach(<span class="keyword">async</span> (file) =&gt; &#123;</span><br><span class="line">  <span class="keyword">await</span> getImg(file);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></p><p>后来发现，这种写法会导致await并不能如我们预期的阻断来执行，而是变成了一个同步的过程（一开始的预期是一张图片压缩输出完才执行第二张，虽然这样会导致很慢。所以后面还是换成了同步压缩），这是因为<code>forEach</code>可以理解为传入一个function，然后在内部执行循环，在循环中执行function并传回index和item，如果传入的是async函数的话，则其实是并行执行了多个匿名async函数自调，因此await无法按照我们预期的来执行。所以该处我们采用<code>for-of</code>循环，伪代码如下<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="keyword">let</span> file <span class="keyword">of</span> files)&#123;</span><br><span class="line">  <span class="keyword">await</span> getImg(file);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p><strong>获取图片</strong><br>在获取图片中，我们依然会通过<code>fs.stat</code>来判断，如果当前文件依然是个文件夹，我们则递归调用<code>findImg</code>检索其下的文件，如果是图片，先判断当前累计图片总数有没有超过剩余数的最大值（如果使用异步压缩，则不需要进行这一步，因为每一次图片处理都是等待上一张图片处理完成后再进行处理；如果是同步压缩，则必须要这一步，否则如果压缩过程中超数量了，会导致整批压缩失败），如果没有超过，则通过调用<code>tinify.js</code>中的<code>imgMin</code>方法开始进行压缩。</p><p><strong>压缩图片</strong><br>在这一步中，我们先通过<code>fs.readFile</code>读取文件内容sourceData，再通过tinypng的API<code>tinify.fromBuffer(sourceData).toBuffer((err, resultData) =&gt; {})</code>方法获取图片压缩后的数据resuleData，最后通过<code>fs.writeFile</code>对原图片进行覆盖。需要注意一点，async/await中，只有遇到await才会等待执行，并且await后面需要跟一个promise对象，因此，我们把<code>readFile</code>、<code>tinify.fromBuffer(sourceData).toBuffer((err, resultData) =&gt; {})</code>、<code>fs.writeFile</code>用promise进行封装。<br>至此，我们的主程序就大功告成了！怎么样，是不是依然非常简单。<br>最后只要在commander中加入我们的新命令就好了。</p><p>/src/imgMin.js代码如下：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> path = <span class="built_in">require</span>(<span class="string">'path'</span>);</span><br><span class="line"><span class="keyword">const</span> fs = <span class="built_in">require</span>(<span class="string">'fs'</span>);</span><br><span class="line"><span class="keyword">const</span> chalk = <span class="built_in">require</span>(<span class="string">'chalk'</span>);</span><br><span class="line"><span class="keyword">const</span> defaultConf = <span class="built_in">require</span>(<span class="string">'./config/default'</span>);</span><br><span class="line"><span class="keyword">const</span> &#123; promisify &#125; = <span class="built_in">require</span>(<span class="string">'util'</span>);</span><br><span class="line"><span class="keyword">const</span> readdir = promisify(fs.readdir);</span><br><span class="line"><span class="keyword">const</span> stat = promisify(fs.stat);</span><br><span class="line"><span class="keyword">const</span> regMap = <span class="built_in">require</span>(<span class="string">'./helper/regMap'</span>);</span><br><span class="line"><span class="keyword">const</span> &#123; validate, leftCount, imgMin &#125; = <span class="built_in">require</span>(<span class="string">'./helper/tinify'</span>);</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ImgMin</span> </span>&#123;</span><br><span class="line">    <span class="keyword">constructor</span>(conf) &#123;</span><br><span class="line">        <span class="keyword">this</span>.conf = <span class="built_in">Object</span>.assign(&#123;&#125;, defaultConf, conf);</span><br><span class="line">        <span class="keyword">this</span>.imgs = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">async</span> isDir(filePath) &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">const</span> stats = <span class="keyword">await</span> stat(filePath);</span><br><span class="line">            <span class="keyword">if</span>(stats.isDirectory())&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (error) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">async</span> findImg(filePath) &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">const</span> isDirectory = <span class="keyword">await</span> <span class="keyword">this</span>.isDir(filePath);</span><br><span class="line">            <span class="keyword">if</span>(!isDirectory)&#123;</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">const</span> files = <span class="keyword">await</span> readdir(filePath);</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">let</span> file <span class="keyword">of</span> files)&#123;</span><br><span class="line">                <span class="comment">// 这里不能用forEach，只能用for循环</span></span><br><span class="line">                <span class="comment">// 加上await，则是一张张异步压缩图片，如果中间出错，则部分成功</span></span><br><span class="line">                <span class="comment">// 不加await，则是同步发起压缩图片请求，异步写入，如果中间出错，则全部失败</span></span><br><span class="line">                <span class="comment">// 这里为了压缩更快，采用同步写法</span></span><br><span class="line"></span><br><span class="line">                <span class="comment">// await this.getImg(file);</span></span><br><span class="line">                <span class="keyword">const</span> fullPath = path.join(filePath, file);</span><br><span class="line">                <span class="keyword">this</span>.getImg(fullPath);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (error) &#123;</span><br><span class="line">            <span class="built_in">console</span>.log(error);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">async</span> getImg(file) &#123;</span><br><span class="line">        <span class="keyword">const</span> stats = <span class="keyword">await</span> stat(file);</span><br><span class="line">        <span class="comment">// 如果是文件夹，则递归调用findImg</span></span><br><span class="line">        <span class="keyword">if</span>(stats.isDirectory())&#123;</span><br><span class="line">            <span class="keyword">this</span>.findImg();</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(stats.isFile())&#123;</span><br><span class="line">            <span class="keyword">if</span>(regMap.isTinyPic.test(file))&#123;</span><br><span class="line">                <span class="keyword">this</span>.imgs ++;</span><br><span class="line">                <span class="keyword">const</span> left = leftCount();</span><br><span class="line">                <span class="comment">// 剩余数判断，解决同步时剩余数不足导致的全部图片压缩失败问题</span></span><br><span class="line">                <span class="keyword">if</span>(<span class="keyword">this</span>.imgs &gt; left || left &lt; <span class="number">0</span>)&#123;</span><br><span class="line">                    <span class="built_in">console</span>.log(chalk.red(<span class="string">`当前key的可用剩余数不足！<span class="subst">$&#123;file&#125;</span> 压缩失败！`</span>));</span><br><span class="line">                    <span class="keyword">return</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">await</span> imgMin(file);</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="built_in">console</span>.log(chalk.red(<span class="string">`不支持的文件格式 <span class="subst">$&#123;file&#125;</span>`</span>));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">async</span> start() &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">const</span> isValidated = <span class="keyword">await</span> validate(<span class="keyword">this</span>.conf.key);</span><br><span class="line">            <span class="keyword">if</span>(!isValidated)&#123;</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">const</span> filePath = <span class="keyword">this</span>.conf.imgMinPath;</span><br><span class="line">            <span class="keyword">await</span> <span class="keyword">this</span>.findImg(filePath);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (error) &#123;</span><br><span class="line">            <span class="built_in">console</span>.log(error);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">module</span>.exports = ImgMin;</span><br></pre></td></tr></table></figure></p><p>/src/helper/tinify.js代码如下：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> fs = <span class="built_in">require</span>(<span class="string">'fs'</span>);</span><br><span class="line"><span class="keyword">const</span> tinify = <span class="built_in">require</span>(<span class="string">'tinify'</span>);</span><br><span class="line"><span class="keyword">const</span> chalk = <span class="built_in">require</span>(<span class="string">'chalk'</span>);</span><br><span class="line"><span class="keyword">const</span> &#123; promisify &#125; = <span class="built_in">require</span>(<span class="string">'util'</span>);</span><br><span class="line"><span class="keyword">const</span> readFile = promisify(fs.readFile);</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">setKey</span>(<span class="params">key</span>) </span>&#123;</span><br><span class="line">    tinify.key = key;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">validate</span>(<span class="params">key</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(chalk.green(<span class="string">'正在认证tinyPng的key...'</span>));</span><br><span class="line">    setKey(key);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="params">resolve</span> =&gt;</span> &#123;</span><br><span class="line">        tinify.validate(<span class="function">(<span class="params">err</span>) =&gt;</span> &#123;</span><br><span class="line">            <span class="keyword">if</span>(err)&#123;</span><br><span class="line">                <span class="built_in">console</span>.log(err);</span><br><span class="line">                <span class="keyword">return</span> resolve(<span class="literal">false</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="built_in">console</span>.log(chalk.green(<span class="string">'认证成功！'</span>));</span><br><span class="line">            <span class="keyword">const</span> left = leftCount();</span><br><span class="line">            <span class="keyword">if</span>(left &lt;= <span class="number">0</span>)&#123;</span><br><span class="line">                <span class="built_in">console</span>.log(chalk.red(<span class="string">'当前key的剩余可用数已用尽，请更换key重试！'</span>));</span><br><span class="line">                <span class="keyword">return</span> resolve(<span class="literal">false</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="built_in">console</span>.log(chalk.green(<span class="string">`当前key剩余可用数为 <span class="subst">$&#123;left&#125;</span>`</span>));</span><br><span class="line">            resolve(<span class="literal">true</span>);</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">compressionCount</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> tinify.compressionCount;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">leftCount</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">const</span> total = <span class="number">500</span>;</span><br><span class="line">    <span class="keyword">return</span> total - <span class="built_in">Number</span>(compressionCount());</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">writeFilePromise</span>(<span class="params">file, content, cb</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">        fs.writeFile(file, content, (err) =&gt; &#123;</span><br><span class="line">            <span class="keyword">if</span>(err)&#123;</span><br><span class="line">                <span class="keyword">return</span> reject(err);</span><br><span class="line">            &#125;</span><br><span class="line">            cb &amp;&amp; cb();</span><br><span class="line">            resolve();</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">toBufferPromise</span>(<span class="params">sourceData</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">        tinify.fromBuffer(sourceData).toBuffer(<span class="function">(<span class="params">err, resultData</span>) =&gt;</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (err) &#123;</span><br><span class="line">                <span class="keyword">return</span> reject(err);</span><br><span class="line">            &#125;</span><br><span class="line">            resolve(resultData);</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">imgMin</span>(<span class="params">img</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(chalk.blue(<span class="string">`开始压缩图片 <span class="subst">$&#123;img&#125;</span>`</span>));</span><br><span class="line">        <span class="keyword">const</span> sourceData = <span class="keyword">await</span> readFile(img);</span><br><span class="line">        <span class="keyword">const</span> resultData = <span class="keyword">await</span> toBufferPromise(sourceData);</span><br><span class="line">        <span class="keyword">await</span> writeFilePromise(img, resultData, () =&gt; <span class="built_in">console</span>.log(chalk.green(<span class="string">`图片压缩成功 <span class="subst">$&#123;img&#125;</span>`</span>)));</span><br><span class="line">    &#125; <span class="keyword">catch</span> (error) &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(error);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="built_in">module</span>.exports = &#123; validate, compressionCount, leftCount, imgMin &#125;;</span><br></pre></td></tr></table></figure></p><p><strong>命令行工具</strong><br>在index.js中，我们加入以下代码<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">program</span><br><span class="line">    .command(<span class="string">'imgMin'</span>)</span><br><span class="line">    .alias(<span class="string">'p'</span>)</span><br><span class="line">    .option(<span class="string">'-k, --key [key]'</span>, <span class="string">`Tinypng's key, Required`</span>)</span><br><span class="line">    .option(<span class="string">'-p, --path [path]'</span>, <span class="string">`Compress directory. By default, the /images in the current working directory are taken. </span></span><br><span class="line"><span class="string">    Please enter an absolute path such as /Users/admin/Documents/xx...`</span>)</span><br><span class="line">    .description(<span class="string">'Compress your images by tinypng.'</span>)</span><br><span class="line">    .action(<span class="function"><span class="params">options</span> =&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">let</span> conf = &#123;&#125;;</span><br><span class="line">        <span class="keyword">if</span>(!options.key)&#123;</span><br><span class="line">            <span class="built_in">console</span>.log(chalk.red(<span class="string">`Please enter your tinypng's key by "gp p -k [key]"`</span>));</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        options.key &amp;&amp; (conf.key = options.key);</span><br><span class="line">        options.path &amp;&amp; (conf.imgMinPath = options.path);</span><br><span class="line">        <span class="keyword">const</span> imgMin = <span class="keyword">new</span> ImgMin(conf);</span><br><span class="line">        imgMin.start();</span><br><span class="line">    &#125;);</span><br></pre></td></tr></table></figure></p><p>commander具体的用法本章就不再重复了，相信有心的同学通过上章的学习已经掌握基本用法了~</p><p>这样，我们就完成了我们的需求，再将其更新到npm中，我们就可以通过<code>gp p -k [key]</code>来压缩我们的图片。</p><h1 id="项目下载"><a href="#项目下载" class="headerlink" title="项目下载"></a>项目下载</h1><p><code>npm i get_picture -g</code></p><h1 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h1><ul><li>该项目的git链接 <a href="https://github.com/1eeing/get_picture" target="_blank" rel="noopener">https://github.com/1eeing/get_picture</a></li><li>tinypng官网<a href="https://tinypng.com/" target="_blank" rel="noopener">https://tinypng.com/</a></li><li>commander git链接 <a href="https://github.com/tj/commander.js" target="_blank" rel="noopener">https://github.com/tj/commander.js</a></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;https://tinypng.com/images/social/developer-api.jpg&quot; alt=&quot;https://tinypng.com/images/social/developer-api.jpg&quot;&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;上篇文章中我们提到了用node撸一个简易的爬虫，本次基于上一篇文章中的项目&lt;a href=&quot;https://github.com/1eeing/get_picture&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;get_picture&lt;/a&gt;给大家分享下我是如何用node撸一个图片压缩工具的。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;strong&gt;历史&lt;/strong&gt;：&lt;br&gt;&lt;a href=&quot;https://juejin.im/post/5bc717f4f265da0abf7d16d3&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;《手把手教你用node撸一个简易的headless爬虫cli工具》&lt;/a&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="个人原创" scheme="http://1eeing.github.io/categories/%E4%B8%AA%E4%BA%BA%E5%8E%9F%E5%88%9B/"/>
    
    
      <category term="node" scheme="http://1eeing.github.io/tags/node/"/>
    
      <category term="cli" scheme="http://1eeing.github.io/tags/cli/"/>
    
      <category term="commander" scheme="http://1eeing.github.io/tags/commander/"/>
    
      <category term="tinypng" scheme="http://1eeing.github.io/tags/tinypng/"/>
    
  </entry>
  
  <entry>
    <title>手把手教你用node撸一个简易的headless爬虫cli工具</title>
    <link href="http://1eeing.github.io/2018/10/17/get_picture/"/>
    <id>http://1eeing.github.io/2018/10/17/get_picture/</id>
    <published>2018-10-17T12:02:57.359Z</published>
    <updated>2018-10-18T13:54:59.804Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://img.alicdn.com/imgextra/i3/69942425/O1CN011TmgvWMBA2SfqY6_!!69942425.jpg" alt="https://img.alicdn.com/imgextra/i3/69942425/O1CN011TmgvWMBA2SfqY6_!!69942425.jpg"></p><blockquote><p>众所周知，node功能很强大，为前端提供了更多的可能。今天，就跟大家分享一下我是如何用node写一个headless爬虫的</p></blockquote><a id="more"></a><h1 id="用到的工具"><a href="#用到的工具" class="headerlink" title="用到的工具"></a>用到的工具</h1><ul><li>puppeteer</li><li>commander</li><li>inquirer</li><li>chalk</li></ul><p>下面就给大家讲一下这些工具都有什么作用</p><h2 id="puppeteer"><a href="#puppeteer" class="headerlink" title="puppeteer"></a>puppeteer</h2><p>headless爬虫主要靠它。它可以模拟用户打开网页的过程，但是并没有打开网页。写过自动化测试的同学应该对这个会比较熟悉，因为用它爬虫的过程跟自动化测试的过程几乎是一样的。</p><h2 id="commander"><a href="#commander" class="headerlink" title="commander"></a>commander</h2><p>基于node的cli命令行工具。利用它，我们可以很方便的写出各种各样的cli命令。</p><h2 id="inquirer"><a href="#inquirer" class="headerlink" title="inquirer"></a>inquirer</h2><p>交互式命令行工具。什么叫做交互式命令行呢？其实就是类似npm init的时候，问一个问题，我们答一个问题，最后根据答案生成package.json的过程。</p><h2 id="chalk"><a href="#chalk" class="headerlink" title="chalk"></a>chalk</h2><p>这个其实就是一个让我们在命令行中输出的文字更加优美的工具。</p><p>好了，介绍完了工具以后，让我们正式开始我们的项目。</p><h1 id="项目介绍"><a href="#项目介绍" class="headerlink" title="项目介绍"></a>项目介绍</h1><p>首先，要搞清楚我们想要实现的功能。我们想要实现的功能就是，在<strong>命令行</strong>中输入我们想要下载的图片，然后node去网上爬取我们想要的图片（这里就先去百度图片爬吧），直接下载到本地。以及输入一个命令，可以清空我们输出目录中的图片。</p><h1 id="文件目录"><a href="#文件目录" class="headerlink" title="文件目录"></a>文件目录</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">|-- Documents</span><br><span class="line">    |-- .gitignore</span><br><span class="line">    |-- README.md</span><br><span class="line">    |-- package.json</span><br><span class="line">    |-- bin</span><br><span class="line">    |   |-- gp</span><br><span class="line">    |-- output</span><br><span class="line">    |   |-- .gitkeeper</span><br><span class="line">    |-- src</span><br><span class="line">        |-- app.js</span><br><span class="line">        |-- clean.js</span><br><span class="line">        |-- index.js</span><br><span class="line">        |-- config</span><br><span class="line">        |   |-- default.js</span><br><span class="line">        |-- helper</span><br><span class="line">            |-- questions.js</span><br><span class="line">            |-- regMap.js</span><br><span class="line">            |-- srcToImg.js</span><br></pre></td></tr></table></figure><p>以上是项目用到的一个简单的目录结构</p><ul><li><strong>output</strong> 用以存放下载的图片</li><li><strong>bin</strong> cli工具会用到的文件</li><li><strong>src</strong> 代码主要存放于此<ul><li><strong>index.js</strong> 项目入口文件</li><li><strong>app.js</strong> 主要功能文件</li><li><strong>clean.js</strong> 用于清空图片操作的文件</li><li><strong>config</strong> 用于存放一些配置</li><li><strong>helper</strong> 用于存放一些辅助方法的文件</li></ul></li></ul><h1 id="开始项目"><a href="#开始项目" class="headerlink" title="开始项目"></a>开始项目</h1><p><strong>首先我们看一下app.js。</strong></p><p>我们用一个类包裹核心方法，是为了命令行工具可以更方便的调用我们的方法。</p><p>这个类很简单，<code>constructor</code>接收参数，<code>start</code>开启主要流程。<br><code>start</code>方法是一个async函数，因为<code>puppeteer</code>操作浏览器的过程几乎都是异步的。</p><p>接着我们用<code>puppeteer</code>生成page的实例，利用<code>goto</code>方法模拟进入百度图片页面。这时其实就是跟我们真实打开浏览器进入百度图片是一样的，只不过因为我们是headless的，所以我们无法感知打开浏览器的过程。</p><p>然后我们需要设置一下浏览器的宽度（想象一下），不能太大，也不能太小。太大会触发百度反爬虫机制，导致我们爬下来的图片是403或者别的错误。太小会导致爬到的图片非常少。</p><p>接下去我们聚焦搜索框，输入我们想要搜索的关键字（这个关键字呢就是我们在命令行输入的关键字），然后点击搜索。</p><p>等页面加载以后，我们用<code>page.$$eval</code>获取页面上所有<code>class</code>为<code>.main_img</code>的图片（具体规律需要自己去观察），再获取上面的<code>src</code>属性后，将<code>src</code>转为我们本地的图片。</p><p>到这里，app.js的任务就完成了。<br>很简单吧。</p><p>下面是代码。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> puppeteer = <span class="built_in">require</span>(<span class="string">'puppeteer'</span>);</span><br><span class="line"><span class="keyword">const</span> chalk = <span class="built_in">require</span>(<span class="string">'chalk'</span>);</span><br><span class="line"><span class="keyword">const</span> config = <span class="built_in">require</span>(<span class="string">'./config/default'</span>);</span><br><span class="line"><span class="keyword">const</span> srcToImg = <span class="built_in">require</span>(<span class="string">'./helper/srcToImg'</span>);</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">App</span> </span>&#123;</span><br><span class="line">    <span class="keyword">constructor</span>(conf) &#123;</span><br><span class="line">        <span class="comment">//有传入的参数既用传入的参数，没有既用默认的参数</span></span><br><span class="line">        <span class="keyword">this</span>.conf = <span class="built_in">Object</span>.assign(&#123;&#125;, config, conf);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">async</span> start () &#123;</span><br><span class="line">        <span class="comment">//用puppeteer生成一个browser的实例</span></span><br><span class="line">        <span class="comment">//用browser再生成一个page的实例</span></span><br><span class="line">        <span class="keyword">const</span> browser = <span class="keyword">await</span> puppeteer.launch();</span><br><span class="line">        <span class="keyword">const</span> page = <span class="keyword">await</span> browser.newPage();</span><br><span class="line">    </span><br><span class="line">        <span class="comment">//打开搜索引擎，先写死百度</span></span><br><span class="line">        <span class="keyword">await</span> page.goto(<span class="keyword">this</span>.conf.searchPath);</span><br><span class="line">        <span class="built_in">console</span>.log(chalk.green(<span class="string">`go to <span class="subst">$&#123;<span class="keyword">this</span>.conf.searchPath&#125;</span>`</span>));</span><br><span class="line">    </span><br><span class="line">        <span class="comment">//设置窗口大小，过大会引起反爬虫</span></span><br><span class="line">        <span class="keyword">await</span> page.setViewport(&#123;</span><br><span class="line">            width: <span class="number">1920</span>,</span><br><span class="line">            height: <span class="number">700</span></span><br><span class="line">        &#125;);</span><br><span class="line">    </span><br><span class="line">        <span class="comment">//搜索文字输入框聚焦</span></span><br><span class="line">        <span class="keyword">await</span> page.focus(<span class="string">'#kw'</span>);</span><br><span class="line">    </span><br><span class="line">        <span class="comment">//输入要搜索的关键字</span></span><br><span class="line">        <span class="keyword">await</span> page.keyboard.sendCharacter(<span class="keyword">this</span>.conf.keyword);</span><br><span class="line">    </span><br><span class="line">        <span class="comment">//点击搜索</span></span><br><span class="line">        <span class="keyword">await</span> page.click(<span class="string">'.s_search'</span>);</span><br><span class="line">        <span class="built_in">console</span>.log(chalk.green(<span class="string">`get start searching pictures`</span>));</span><br><span class="line">    </span><br><span class="line">        <span class="comment">//页面加载后要做的事</span></span><br><span class="line">        page.on(<span class="string">'load'</span>, <span class="keyword">async</span> () =&gt; &#123;</span><br><span class="line">            <span class="built_in">console</span>.log(chalk.green(<span class="string">`searching pictures done, start fetch...`</span>));</span><br><span class="line">            <span class="comment">//获取所有指定图片的src</span></span><br><span class="line">            <span class="keyword">const</span> srcs = <span class="keyword">await</span> page.$$<span class="built_in">eval</span>(<span class="string">'img.main_img'</span>, pictures =&gt; &#123;</span><br><span class="line">                <span class="keyword">return</span> pictures.map(<span class="function"><span class="params">img</span> =&gt;</span> img.src);</span><br><span class="line">            &#125;);</span><br><span class="line">            <span class="built_in">console</span>.log(chalk.green(<span class="string">`get <span class="subst">$&#123;srcs.length&#125;</span> pictures, start download`</span>));</span><br><span class="line">    </span><br><span class="line">            srcs.forEach(<span class="keyword">async</span> (src) =&gt; &#123;</span><br><span class="line">                <span class="keyword">await</span> page.waitFor(<span class="number">200</span>);</span><br><span class="line">                <span class="keyword">await</span> srcToImg(src, <span class="keyword">this</span>.conf.outputPath);</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="built_in">module</span>.exports = App;</span><br></pre></td></tr></table></figure></p><p><strong>接下来我们看一下，如何把图片的src属性转化为我们本地的图片呢？我们看下helper下的srcToImg.js</strong></p><p>首先，这个模块主要引入了node的<code>http</code>模块、<code>https</code>模块、<code>path</code>模块和<code>fs</code>模块及一些辅助工具，比如正则、将回调函数转化为promise的<code>promisify</code>和将输出更好看的<code>chalk</code>。</p><p>为什么我们要同时引入http和https模块呢？仔细观察百度图片搜索结果中的图片，我们可以发现，既有http的也有https的，所以我们引入两个模块，区分出具体的图片属于哪个就用哪个模块去请求图片。请求了图片以后，我们就用<code>fs</code>模块的<code>createWriteStream</code>方法，将图片存入我们的<code>output</code>目录中。</p><p>如果我们仔细观察了百度搜索结果中的图片的src，我们会发现，除了http和https开头的图片，还有base64的图片，所以我们要对base64的图片也做一下处理。</p><p>跟普通图片一样的处理，先根据<code>src</code>分割出扩展名，再计算出存储的路径和文件名，最后写入调用<code>fs</code>模块的<code>writeFile</code>方法写入文件（这里就简单的用writeFile了）。</p><p>以上，图片就存入本地了。</p><p>代码如下。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> http = <span class="built_in">require</span>(<span class="string">'http'</span>);</span><br><span class="line"><span class="keyword">const</span> https = <span class="built_in">require</span>(<span class="string">'https'</span>);</span><br><span class="line"><span class="keyword">const</span> path = <span class="built_in">require</span>(<span class="string">'path'</span>);</span><br><span class="line"><span class="keyword">const</span> fs = <span class="built_in">require</span>(<span class="string">'fs'</span>);</span><br><span class="line"><span class="keyword">const</span> &#123; promisify &#125; = <span class="built_in">require</span>(<span class="string">'util'</span>);</span><br><span class="line"><span class="keyword">const</span> chalk = <span class="built_in">require</span>(<span class="string">'chalk'</span>);</span><br><span class="line"><span class="keyword">const</span> writeFile = promisify(fs.writeFile);</span><br><span class="line"><span class="keyword">const</span> regMap = <span class="built_in">require</span>(<span class="string">'./regMap'</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> urlToImg = promisify(<span class="function">(<span class="params">url, dir</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">let</span> mod;</span><br><span class="line">    <span class="keyword">if</span>(regMap.isHttp.test(url))&#123;</span><br><span class="line">        mod = http;</span><br><span class="line">    &#125;<span class="keyword">else</span> <span class="keyword">if</span>(regMap.isHttps.test(url))&#123;</span><br><span class="line">        mod = https;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//获取图片的扩展名</span></span><br><span class="line">    <span class="keyword">const</span> ext = path.extname(url);</span><br><span class="line">    <span class="comment">//拼接图片存储的路径和扩展名</span></span><br><span class="line">    <span class="keyword">const</span> file = path.join(dir, <span class="string">`<span class="subst">$&#123;<span class="built_in">parseInt</span>(<span class="built_in">Math</span>.random() * <span class="number">1000000</span>)&#125;</span><span class="subst">$&#123;ext&#125;</span>`</span>);</span><br><span class="line"></span><br><span class="line">    mod.get(url, res =&gt; &#123;</span><br><span class="line">        <span class="comment">//采用stream的形式，比直接写入更快捷</span></span><br><span class="line">        res.pipe(fs.createWriteStream(file)).on(<span class="string">'finish'</span>, () =&gt; &#123;</span><br><span class="line">            <span class="built_in">console</span>.log(file);</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> base64ToImg = <span class="keyword">async</span> (base64Str, dir) =&gt; &#123;</span><br><span class="line">    <span class="keyword">const</span> matchs = base64Str.match(regMap.isBase64);</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">const</span> ext = matchs[<span class="number">1</span>].split(<span class="string">'/'</span>)[<span class="number">1</span>].replace(<span class="string">'jpeg'</span>, <span class="string">'jpg'</span>);</span><br><span class="line">        <span class="keyword">const</span> file = path.join(dir, <span class="string">`<span class="subst">$&#123;<span class="built_in">parseInt</span>(<span class="built_in">Math</span>.random() * <span class="number">1000000</span>)&#125;</span>.<span class="subst">$&#123;ext&#125;</span>`</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">await</span> writeFile(file, matchs[<span class="number">2</span>], <span class="string">'base64'</span>);</span><br><span class="line">        <span class="built_in">console</span>.log(file);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (error) &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(chalk.red(<span class="string">'无法识别的图片'</span>));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="built_in">module</span>.exports = <span class="function">(<span class="params">src, dir</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">if</span>(regMap.isPic.test(src))&#123;</span><br><span class="line">        urlToImg(src, dir);</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        base64ToImg(src, dir);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p><p><strong>我们再看一下如何清空output下的图片呢？</strong><br>这里我们还是用到了<code>node</code>的<code>fs</code>模块，首先利用<code>fs.readdir</code>方法读取<code>output</code>文件夹，然后遍历其下的文件，如果是图片，则调用<code>fs.unlink</code>方法删除它。也很简单，对吧。</p><p>代码如下<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> fs = <span class="built_in">require</span>(<span class="string">'fs'</span>);</span><br><span class="line"><span class="keyword">const</span> regMap = <span class="built_in">require</span>(<span class="string">'./helper/regMap'</span>);</span><br><span class="line"><span class="keyword">const</span> config = <span class="built_in">require</span>(<span class="string">'./config/default'</span>);</span><br><span class="line"><span class="keyword">const</span> cleanPath = config.outputPath;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Clean</span> </span>&#123;</span><br><span class="line">    <span class="keyword">constructor</span>() &#123;&#125;</span><br><span class="line"></span><br><span class="line">    clean() &#123;</span><br><span class="line">        fs.readdir(cleanPath, (err, files) =&gt; &#123;</span><br><span class="line">            <span class="keyword">if</span>(err)&#123;</span><br><span class="line">                <span class="keyword">throw</span> err;</span><br><span class="line">            &#125;</span><br><span class="line">            files.forEach(<span class="function"><span class="params">file</span> =&gt;</span> &#123;</span><br><span class="line">                <span class="keyword">if</span>(regMap.isPic.test(file))&#123;</span><br><span class="line">                    <span class="keyword">const</span> img = <span class="string">`<span class="subst">$&#123;cleanPath&#125;</span>/<span class="subst">$&#123;file&#125;</span>`</span>;</span><br><span class="line">                    fs.unlink(img, (e) =&gt; &#123;</span><br><span class="line">                        <span class="keyword">if</span>(e) &#123;</span><br><span class="line">                            <span class="keyword">throw</span> e;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">            <span class="built_in">console</span>.log(<span class="string">'clean finished'</span>);</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="built_in">module</span>.exports = Clean;</span><br></pre></td></tr></table></figure></p><p><strong>最后我们看一下如何写cli工具呢？</strong><br>首先我们需要在<code>bin</code>目录下新建一个脚本文件<code>gp</code>，如下<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">#! /usr/bin/env node</span><br><span class="line">module.exports = require(&apos;../src/index&apos;);</span><br></pre></td></tr></table></figure></p><p>意思是找到<code>/usr/bin/env</code>下的<code>node</code>来启动第二行的代码</p><p>其次我们需要在package.json里加入一个<code>bin</code>对象，对象下属性名是我们命令的名字，属性是<code>bin</code>下的脚本文件的路径，如下<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">"bin"</span>: &#123;</span><br><span class="line">  <span class="string">"gp"</span>: <span class="string">"bin/gp"</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>接着我们来看下<code>index.js</code><br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> program = <span class="built_in">require</span>(<span class="string">'commander'</span>);</span><br><span class="line"><span class="keyword">const</span> inquirer = <span class="built_in">require</span>(<span class="string">'inquirer'</span>);</span><br><span class="line"><span class="keyword">const</span> pkg = <span class="built_in">require</span>(<span class="string">'../package.json'</span>);</span><br><span class="line"><span class="keyword">const</span> qs = <span class="built_in">require</span>(<span class="string">'./helper/questions'</span>);</span><br><span class="line"><span class="keyword">const</span> App = <span class="built_in">require</span>(<span class="string">'./app'</span>);</span><br><span class="line"><span class="keyword">const</span> Clean = <span class="built_in">require</span>(<span class="string">'./clean'</span>);</span><br><span class="line"></span><br><span class="line">program</span><br><span class="line">    .version(pkg.version, <span class="string">'-v, --version'</span>);</span><br><span class="line"></span><br><span class="line">program</span><br><span class="line">    .command(<span class="string">'search'</span>)</span><br><span class="line">    .alias(<span class="string">'s'</span>)</span><br><span class="line">    .description(<span class="string">'get search pictures what you want.'</span>)</span><br><span class="line">    .action(<span class="keyword">async</span> () =&gt; &#123;</span><br><span class="line">        <span class="keyword">const</span> answers = <span class="keyword">await</span> inquirer.prompt(qs.startQuestions);</span><br><span class="line">        <span class="keyword">const</span> app = <span class="keyword">new</span> App(answers);</span><br><span class="line">        <span class="keyword">await</span> app.start();</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">program</span><br><span class="line">    .command(<span class="string">'clean'</span>)</span><br><span class="line">    .alias(<span class="string">'c'</span>)</span><br><span class="line">    .description(<span class="string">'clean all pictures in directory "output".'</span>)</span><br><span class="line">    .action(<span class="keyword">async</span> () =&gt; &#123;</span><br><span class="line">        <span class="keyword">const</span> answers = <span class="keyword">await</span> inquirer.prompt(qs.confirmClean);</span><br><span class="line">        <span class="keyword">const</span> clean = <span class="keyword">new</span> Clean();</span><br><span class="line">        answers.isRemove &amp;&amp; <span class="keyword">await</span> clean.clean();</span><br><span class="line">    &#125;);</span><br><span class="line">    </span><br><span class="line">program.parse(process.argv);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(process.argv.length &lt; <span class="number">3</span>)&#123;</span><br><span class="line">    program.help();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>我们引入<code>commander</code>和<code>inquirer</code>，<code>program.command</code>方法是为我们生成命令名的，<code>alias</code>是该命令的缩写，<code>description</code>是该命令的描述，<code>action</code>是该命令要做的事情。</p><p>我们首先用<code>command</code>生成了两个命令，<code>search</code>和<code>clean</code>，接着可以看到，我们在<code>action</code>中用了<code>inquirer</code>，<code>inquirer</code>的提问是一个异步的过程，所以我们也一样用了<code>async</code>和<code>await</code>，<code>inquirer</code>接收一个问题数组，里面包含问题的type、name、message和验证方法等，具体的可以参考inquirer的文档。我们这里的问题如下，这里返回了两个数组，一个是用于输入关键字的时候的，一个是用于清空图片时确认的。提问数组中会验证是否有填写关键字，如果没有，则不会继续下一步并提示你该输入关键字，否则就正式开始爬虫流程。删除确认数组就是简单的一个确认，如果确认了，则开始删除图片。最后，用<code>program.parse</code>将命令注入到<code>node</code>的<code>process.argv</code>中，根据命令行有没有输入参数提示help信息。</p><p>至此，我们的程序大功告成。接下去我们只要将我们的程序发布到npm里，就可以让其他人下载来使用了~npm的发布我们这里就不再赘述啦，不清楚的同学网上随便搜一下就ok啦。</p><p><code>src/helper/questions.js</code>如下<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> config = <span class="built_in">require</span>(<span class="string">'../config/default'</span>);</span><br><span class="line"></span><br><span class="line">exports.startQuestions = [</span><br><span class="line">    &#123;</span><br><span class="line">        type: <span class="string">'input'</span>,</span><br><span class="line">        name: <span class="string">'keyword'</span>,</span><br><span class="line">        message: <span class="string">'What pictures do yo want to get ?'</span>,</span><br><span class="line">        validate: <span class="function"><span class="keyword">function</span>(<span class="params">keyword</span>) </span>&#123;</span><br><span class="line">            <span class="keyword">const</span> done = <span class="keyword">this</span>.async();</span><br><span class="line">            <span class="keyword">if</span>(keyword === <span class="string">''</span>)&#123;</span><br><span class="line">                done(<span class="string">'Please enter the keyword to get pictures'</span>);</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            done(<span class="literal">null</span>, <span class="literal">true</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">];</span><br><span class="line"></span><br><span class="line">exports.confirmClean = [</span><br><span class="line">    &#123;</span><br><span class="line">        type: <span class="string">'confirm'</span>,</span><br><span class="line">        name: <span class="string">'isRemove'</span>,</span><br><span class="line">        message: <span class="string">`Do you want to remove all pictures in <span class="subst">$&#123;config.outputPath&#125;</span> ?`</span>,</span><br><span class="line">        <span class="keyword">default</span>: <span class="literal">true</span>,</span><br><span class="line">    &#125;</span><br><span class="line">];</span><br></pre></td></tr></table></figure></p><h1 id="项目下载"><a href="#项目下载" class="headerlink" title="项目下载"></a>项目下载</h1><p><code>npm i get_picture -g</code></p><h1 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h1><ul><li>该项目的git链接 <a href="https://github.com/1eeing/get_picture" target="_blank" rel="noopener">https://github.com/1eeing/get_picture</a></li><li>puppeteer git链接 <a href="https://github.com/GoogleChrome/puppeteer" target="_blank" rel="noopener">https://github.com/GoogleChrome/puppeteer</a></li><li>commander git链接 <a href="https://github.com/tj/commander.js" target="_blank" rel="noopener">https://github.com/tj/commander.js</a></li><li>inquirer git链接 <a href="https://github.com/SBoudrias/Inquirer.js" target="_blank" rel="noopener">https://github.com/SBoudrias/Inquirer.js</a></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;https://img.alicdn.com/imgextra/i3/69942425/O1CN011TmgvWMBA2SfqY6_!!69942425.jpg&quot; alt=&quot;https://img.alicdn.com/imgextra/i3/69942425/O1CN011TmgvWMBA2SfqY6_!!69942425.jpg&quot;&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;众所周知，node功能很强大，为前端提供了更多的可能。今天，就跟大家分享一下我是如何用node写一个headless爬虫的&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="个人原创" scheme="http://1eeing.github.io/categories/%E4%B8%AA%E4%BA%BA%E5%8E%9F%E5%88%9B/"/>
    
    
      <category term="node" scheme="http://1eeing.github.io/tags/node/"/>
    
      <category term="cli" scheme="http://1eeing.github.io/tags/cli/"/>
    
      <category term="commander" scheme="http://1eeing.github.io/tags/commander/"/>
    
      <category term="inquirer" scheme="http://1eeing.github.io/tags/inquirer/"/>
    
      <category term="puppeteer" scheme="http://1eeing.github.io/tags/puppeteer/"/>
    
      <category term="爬虫" scheme="http://1eeing.github.io/tags/%E7%88%AC%E8%99%AB/"/>
    
  </entry>
  
  <entry>
    <title>彻底搞懂Nginx</title>
    <link href="http://1eeing.github.io/2018/09/13/Nginx/"/>
    <id>http://1eeing.github.io/2018/09/13/Nginx/</id>
    <published>2018-09-12T16:05:30.481Z</published>
    <updated>2018-12-08T15:40:42.912Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>Nginx在工作中用的很多，平时开发也一直用Nginx来代理，但是一直对Nginx是一个模糊的概念。这次打算结合理论和工作中的Nginx配置彻底搞清楚Nginx。</p><h1 id="Nginx能做什么"><a href="#Nginx能做什么" class="headerlink" title="Nginx能做什么"></a>Nginx能做什么</h1><ol><li>正向代理</li><li>反向代理</li><li>负载均衡</li><li>HTTP服务器</li></ol><h1 id="正向代理"><a href="#正向代理" class="headerlink" title="正向代理"></a>正向代理</h1><p>正向代理，也就是传说中的代理，他的工作原理就像一个跳板，简单的说，我是一个用户，我访问不了某网站，但是我能访问一个代理服务器，这个代理服务器呢，他能访问那个我不能访问的网站，于是我先连上代理服务器，告诉他我需要那个无法访问网站的内容，代理服务器去取回来，然后返回给我。从网站的角度，只在代理服务器来取内容的时候有一次记录，有时候并不知道是用户的请求，也隐藏了用户的资料，这取决于代理告不告诉网站。</p><a id="more"></a><p>专业点说：<strong>正向代理是一个位于客户端和原始服务器（origin server）之间的服务器，为了从原始服务器取得内容，客户端向代理发送一个请求并制定目标（原始服务器），然后代理向原始服务器转交请求并将获得的内容返回给客户端。客户端必须要进行一些特殊的设置才能使用正向代理</strong></p><p>关键代码如下<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">resolver 114.114.114.114 8.8.8.8;</span><br><span class="line">server &#123;</span><br><span class="line">  resolver_timeout 5s;</span><br><span class="line">  listen 81;</span><br><span class="line">  </span><br><span class="line">  location / &#123;</span><br><span class="line">    proxy_pass http://$host$request_uri;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>resolver是配置正向代理的DNS服务器，listen是正向代理的端口，配置好了就可以在代理插件上通过服务器ip+端口号进行代理了。</p><h1 id="反向代理"><a href="#反向代理" class="headerlink" title="反向代理"></a>反向代理</h1><p>继续举例。<br>用户访问<a href="http://www.test.com/readme，但www.test.com上并不存在readme页面，他是偷偷从另外一台服务器上取回来，然后作为自己的内容返回用户，但用户并不知情。这里提到的www.test.com这个域名对应的服务器就设置了反向代理功能。" target="_blank" rel="noopener">http://www.test.com/readme，但www.test.com上并不存在readme页面，他是偷偷从另外一台服务器上取回来，然后作为自己的内容返回用户，但用户并不知情。这里提到的www.test.com这个域名对应的服务器就设置了反向代理功能。</a></p><p>结论就是：<strong>反向代理和正向代理正好相反，对于客户端而言他就像是原始服务器，并且客户端不需要进行任何特别的设置。客户端向反向代理的命名空间中的内容发送普通请求，接着反向代理将判断向何处（原始服务器）转交请求，并将获得的内容返回给客户端，就像这些内容原本就是他自己的一样。</strong></p><p>关键代码如下<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">server &#123;</span><br><span class="line">  listen 80;</span><br><span class="line">  server_name localhost;</span><br><span class="line">  </span><br><span class="line">  location / &#123;</span><br><span class="line">    proxy_pass http://localhost:8080;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>这样当我们访问localhost:80时，80端口会向8080端口转交请求，并将内容返回给我们客户端，就相当于访问localhost:8080了。</p><h1 id="负载均衡"><a href="#负载均衡" class="headerlink" title="负载均衡"></a>负载均衡</h1><p>负载均衡也是Nginx常用的一个功能，负载均衡的意思就是分摊到多个操作单元上进行执行，例如Web服务器，FTP服务器、企业关键应用服务器和其它关键人物服务器等，从而共同完成工作任务。简单而言，就是当有2台或以上服务器时，根据规则随机的将请求分发到制定的服务器上处理，负载均衡配置一般都需要同时配置反向代理，通过反向代理跳转到负载均衡。</p><p>Nginx自带3种负载均衡策略，还有2种常用的第三方策略。</p><h2 id="RR（默认）"><a href="#RR（默认）" class="headerlink" title="RR（默认）"></a>RR（默认）</h2><p>每个请求按时间顺序逐一分配到不同的后端服务器，如果后端服务器挂了，则自动剔除。</p><p>核心代码<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">upstream test &#123;</span><br><span class="line">  server localhost:8080;</span><br><span class="line">  server localhost:8081;</span><br><span class="line">&#125;</span><br><span class="line">server &#123;</span><br><span class="line">  listen 80;</span><br><span class="line">  server_name localhost;</span><br><span class="line">  </span><br><span class="line">  location / &#123;</span><br><span class="line">    proxy_pass http://test;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p><code>upstream</code> 部分即为负载均衡的核心代码。<br>这里配置2个端口，而8081端口是访问不到的，但是我们访问 <a href="http://localhost" target="_blank" rel="noopener">http://localhost</a> 的时候也不会有问题，会默认跳转到 <a href="http://localhost:8080" target="_blank" rel="noopener">http://localhost:8080</a> 具体是因为Nginx会自动判断服务器的状态，如果服务器挂了，则不会跳转到这台服务器。</p><h2 id="权重"><a href="#权重" class="headerlink" title="权重"></a>权重</h2><p>制定轮询几率，weight和访问比率成正比，用于后端服务器性能不均的情况。</p><p>核心代码如下<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">upstream test &#123;</span><br><span class="line">  server localhost:8080 weight=9;</span><br><span class="line">  server localhost:8081 weight=1;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>那么10次一般只有1次会访问到8081，剩下9次会访问到8080。</p><h2 id="ip-hash"><a href="#ip-hash" class="headerlink" title="ip_hash"></a>ip_hash</h2><p>上面的2种方式都有一个问题，那就是下一个请求来的时候请求可能分到另一个服务器，当我们的程序不是无状态的时候（采用了session保存数据），这时候就有一个很大的问题了，比如把登录信息保存到session种，那么跳转到另外一台服务器的时候就需要重新登录了，所以很多时候我们需要一个客户只访问一个服务器，那么就需要用iphash了，iphash的每个请求按访问ip的hash结果分配，这样每个方可固定访问一个后端服务器，可以解决session的问题。</p><p>核心代码如下<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">upstream &#123;</span><br><span class="line">  ip_hash;</span><br><span class="line">  server localhost:8080;</span><br><span class="line">  server localhost:8081;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2 id="fair（第三方）"><a href="#fair（第三方）" class="headerlink" title="fair（第三方）"></a>fair（第三方）</h2><p>按后端服务器的响应时间来分配请求，响应时间短的优先分配。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">upstream backend &#123;</span><br><span class="line">  fair;</span><br><span class="line">  server localhost:8080;</span><br><span class="line">  server localhost:8081;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2 id="url-hash（第三方）"><a href="#url-hash（第三方）" class="headerlink" title="url_hash（第三方）"></a>url_hash（第三方）</h2><p>按访问url的hash结果来分配请求，使每个url定向到同一个后端服务器，后端服务器为缓存时比较有效。在upstream中加入hash语句，server语句中不能写入weight等其他的参数，hash_method使使用的hash算法</p><p>核心代码如下<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">upstream backend &#123;</span><br><span class="line">  hash $request_uri;</span><br><span class="line">  hash_method crc32;</span><br><span class="line">  server localhost:8080;</span><br><span class="line">  server localhost:8081;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h1 id="HTTP服务器"><a href="#HTTP服务器" class="headerlink" title="HTTP服务器"></a>HTTP服务器</h1><p>Nginx本身也是一个静态资源的服务器，当只有静态资源的时候，就可以使用Nginx来做服务器，同时现在也很流行动静分离，就可以通过Nginx来实现。</p><p>首先看看Nginx做静态资源服务器<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">server &#123;</span><br><span class="line">  listen 80;</span><br><span class="line">  server_name localhost;</span><br><span class="line">  </span><br><span class="line">  location / &#123;</span><br><span class="line">    root e:\wwwroot;</span><br><span class="line">    index index.html;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>这样如果访问到 <a href="http://localhost" target="_blank" rel="noopener">http://localhost</a> 就会默认访问到E盘wwwroot目录下面的index.html，如果一个网站只是静态页面的话，那么就可以通过这种方式来实现部署。</p><h2 id="动静分离"><a href="#动静分离" class="headerlink" title="动静分离"></a>动静分离</h2><p>动静分离是让动态网站里的动态网页根据一定规则把不变的资源和经常变的资源区分开来，动静资源做好了拆分以后，我们就可以根据静态资源的特点将其做缓存操作，这就是网站静态化处理的核心思路。</p><p>核心代码如下<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">upstream test &#123;</span><br><span class="line">  server localhost:8080;</span><br><span class="line">  server localhost:8081;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">server &#123;</span><br><span class="line">  listen 80;</span><br><span class="line">  server_name localhost;</span><br><span class="line">  </span><br><span class="line">  location / &#123;</span><br><span class="line">    root e:\wwwroot;</span><br><span class="line">    index index.html;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  # 所有静态请求都由nginx处理</span><br><span class="line">  location ~ \.(gif|jpg|jpeg|png|bmp|swf|css|js)$ &#123;</span><br><span class="line">    root e:\wwwroot;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  # 所有动态请求都转发给tomcat处理</span><br><span class="line">  location ~ \.(jsp|do)$ &#123;</span><br><span class="line">    proxy_pass http://test;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>这样我们就可以把html、图片、css以及js放到wwwroot目录下，而tomcat只复杂处理jsp和请求，例如当我们后缀为gif的时候，Nginx默认会从wwwroot获取到当前请求的动态图文件返回，当然这里的静态文件跟Nginx是同意爱服务器，我们也可以在另外一台服务器，然后通过反向代理和负载均衡配置过去就好了。</p><h1 id="实际业务中用到的conf文件分析"><a href="#实际业务中用到的conf文件分析" class="headerlink" title="实际业务中用到的conf文件分析"></a>实际业务中用到的conf文件分析</h1><p>主要代码如下<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">server &#123;</span><br><span class="line">  listen 80;</span><br><span class="line">  </span><br><span class="line">  # host中绑定的www.sb.com实际是localhost</span><br><span class="line">  server_name www.sb.com;</span><br><span class="line"></span><br><span class="line">  # 静态资源从这里返回，缓存的过期时间是1天</span><br><span class="line">  location ~* ^.+\.(woff|woff2|ttf|json|log|jpg|jpeg|gif|png|ico|html|cfm|cfc|afp|asp|lasso|pl|py|txt|fla|swf|zip)$ &#123;</span><br><span class="line">    root /Users/admin/Documents/sb;</span><br><span class="line">    expires 1d;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  # jss、css和less这些静态资源依然走这个目录，过期时间2小时</span><br><span class="line">  location ~* ^.+\.(js|css|less)$ &#123;</span><br><span class="line">    root /Users/admin/Documents/sb;</span><br><span class="line">    expires 2h;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  # 监听80端口，当访问www.sb.com:80的时候</span><br><span class="line">  # 会将请求转发到 http://101.37.111.40</span><br><span class="line">  # 最后将结果返回给客户端</span><br><span class="line">  location ~ /&#123;</span><br><span class="line">    proxy_pass http://101.37.111.40;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>可以看到，项目中用到了反向代理和将Nginx作为静态资源服务器。<br>PS：如果将<a href="http://www.sb.com的host绑定到测试环境，经过验证，不会走进本地Nginx配置。关于这个可以这么理解，Nginx在本地起了一个服务器，如果请求的是本地，则会走进此服务器，如果请求的是其他域名，则不会走进本地Nginx服务器，即和本地Nginx没有关系。" target="_blank" rel="noopener">www.sb.com的host绑定到测试环境，经过验证，不会走进本地Nginx配置。关于这个可以这么理解，Nginx在本地起了一个服务器，如果请求的是本地，则会走进此服务器，如果请求的是其他域名，则不会走进本地Nginx服务器，即和本地Nginx没有关系。</a></p><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><ul><li><a href="https://www.geekjc.com/post/58e70c55e8d0c72d3c4fa340#4." target="_blank" rel="noopener">https://www.geekjc.com/post/58e70c55e8d0c72d3c4fa340#4.</a></li><li><a href="http://blog.51cto.com/freeloda/1288553" target="_blank" rel="noopener">http://blog.51cto.com/freeloda/1288553</a></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;Nginx在工作中用的很多，平时开发也一直用Nginx来代理，但是一直对Nginx是一个模糊的概念。这次打算结合理论和工作中的Nginx配置彻底搞清楚Nginx。&lt;/p&gt;
&lt;h1 id=&quot;Nginx能做什么&quot;&gt;&lt;a href=&quot;#Nginx能做什么&quot; class=&quot;headerlink&quot; title=&quot;Nginx能做什么&quot;&gt;&lt;/a&gt;Nginx能做什么&lt;/h1&gt;&lt;ol&gt;
&lt;li&gt;正向代理&lt;/li&gt;
&lt;li&gt;反向代理&lt;/li&gt;
&lt;li&gt;负载均衡&lt;/li&gt;
&lt;li&gt;HTTP服务器&lt;/li&gt;
&lt;/ol&gt;
&lt;h1 id=&quot;正向代理&quot;&gt;&lt;a href=&quot;#正向代理&quot; class=&quot;headerlink&quot; title=&quot;正向代理&quot;&gt;&lt;/a&gt;正向代理&lt;/h1&gt;&lt;p&gt;正向代理，也就是传说中的代理，他的工作原理就像一个跳板，简单的说，我是一个用户，我访问不了某网站，但是我能访问一个代理服务器，这个代理服务器呢，他能访问那个我不能访问的网站，于是我先连上代理服务器，告诉他我需要那个无法访问网站的内容，代理服务器去取回来，然后返回给我。从网站的角度，只在代理服务器来取内容的时候有一次记录，有时候并不知道是用户的请求，也隐藏了用户的资料，这取决于代理告不告诉网站。&lt;/p&gt;
    
    </summary>
    
      <category term="学习笔记" scheme="http://1eeing.github.io/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="学习笔记" scheme="http://1eeing.github.io/tags/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
      <category term="基础知识" scheme="http://1eeing.github.io/tags/%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"/>
    
      <category term="计算机通识" scheme="http://1eeing.github.io/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E9%80%9A%E8%AF%86/"/>
    
      <category term="网络" scheme="http://1eeing.github.io/tags/%E7%BD%91%E7%BB%9C/"/>
    
      <category term="服务器" scheme="http://1eeing.github.io/tags/%E6%9C%8D%E5%8A%A1%E5%99%A8/"/>
    
      <category term="Nginx" scheme="http://1eeing.github.io/tags/Nginx/"/>
    
  </entry>
  
  <entry>
    <title>【基础篇】git高级操作</title>
    <link href="http://1eeing.github.io/2018/08/27/git%E9%AB%98%E7%BA%A7%E6%93%8D%E4%BD%9C/"/>
    <id>http://1eeing.github.io/2018/08/27/git高级操作/</id>
    <published>2018-08-26T17:14:20.019Z</published>
    <updated>2018-08-26T17:16:04.813Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Rebase"><a href="#Rebase" class="headerlink" title="Rebase"></a>Rebase</h1><p>改命令可以说和merge命令得到的结果基本是一致的<br>通常merge操作将分支上的代码合并到master中，分支样子如下所示</p><p><img src="https://user-gold-cdn.xitu.io/2018/4/23/162f109db27be054?w=505&amp;h=461&amp;f=png&amp;s=22796" alt="https://user-gold-cdn.xitu.io/2018/4/23/162f109db27be054?w=505&amp;h=461&amp;f=png&amp;s=22796"></p><p>使用rebase后，会将develop上的commit按顺序移到master的第三个commit后面，分支样子如下</p><a id="more"></a><p><img src="https://user-gold-cdn.xitu.io/2018/4/23/162f11cc2cb8b332?w=505&amp;h=563&amp;f=png&amp;s=26514" alt="https://user-gold-cdn.xitu.io/2018/4/23/162f11cc2cb8b332?w=505&amp;h=563&amp;f=png&amp;s=26514"></p><p>rebase对比merge<br>优点：</p><ul><li>合并后的结果很清晰，只有一条线</li></ul><p>缺点：</p><ul><li>如果一旦出现冲突，解决冲突很麻烦，可能要解决多个冲突，但是merge出现冲突只需要解决一次</li></ul><p>使用rebase应该在需要被rebase的分支上操作，并且该分支是本地分支。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">## branch develop</span><br><span class="line">git rebase master</span><br><span class="line">git checkout master</span><br><span class="line">## 用于将 master 上的 HEAD 移动到最新的commit</span><br><span class="line">git merge develop</span><br></pre></td></tr></table></figure></p><hr><h1 id="stash"><a href="#stash" class="headerlink" title="stash"></a>stash</h1><p>stash用于临时保存工作目录的改动。开发中可能会遇到代码写一半需要切分支打包的问题，如果这时候你不想commit的话，就可以使用该命令<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git stash</span><br></pre></td></tr></table></figure></p><p>使用该命令可以暂存你的工作目录，恢复如下<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git stash pop</span><br></pre></td></tr></table></figure></p><hr><h1 id="reflog"><a href="#reflog" class="headerlink" title="reflog"></a>reflog</h1><p>reflog可以看到HEAD的移动记录，加入之前误删了一个分支，可以通过git reflog看到移动HEAD的哈希值</p><p><img src="https://user-gold-cdn.xitu.io/2018/4/23/162f14df98ce3d83?w=950&amp;h=118&amp;f=png&amp;s=77151" alt="https://user-gold-cdn.xitu.io/2018/4/23/162f14df98ce3d83?w=950&amp;h=118&amp;f=png&amp;s=77151"></p><p>从图中可以看出，HEAD的最后一次移动行为是merge后，接下来分支new就被删除了，那么我们可以通过以下命令找回new分支</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git checkout 37d9aca</span><br><span class="line">git checkout -b new</span><br></pre></td></tr></table></figure><blockquote><p>reflog 记录是时效的，只会保存一段时间内的记录。</p></blockquote><hr><h1 id="Reset"><a href="#Reset" class="headerlink" title="Reset"></a>Reset</h1><p>如果你想删除刚写的commit，就可以通过以下命令实现</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git reset --hard HEAD^</span><br></pre></td></tr></table></figure><p>但是reset的本质并不是删除了commit，而是重新设置了HEAD和它指向的branch。</p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;Rebase&quot;&gt;&lt;a href=&quot;#Rebase&quot; class=&quot;headerlink&quot; title=&quot;Rebase&quot;&gt;&lt;/a&gt;Rebase&lt;/h1&gt;&lt;p&gt;改命令可以说和merge命令得到的结果基本是一致的&lt;br&gt;通常merge操作将分支上的代码合并到master中，分支样子如下所示&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://user-gold-cdn.xitu.io/2018/4/23/162f109db27be054?w=505&amp;amp;h=461&amp;amp;f=png&amp;amp;s=22796&quot; alt=&quot;https://user-gold-cdn.xitu.io/2018/4/23/162f109db27be054?w=505&amp;amp;h=461&amp;amp;f=png&amp;amp;s=22796&quot;&gt;&lt;/p&gt;
&lt;p&gt;使用rebase后，会将develop上的commit按顺序移到master的第三个commit后面，分支样子如下&lt;/p&gt;
    
    </summary>
    
      <category term="学习笔记" scheme="http://1eeing.github.io/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="基础知识" scheme="http://1eeing.github.io/tags/%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"/>
    
      <category term="计算机通识" scheme="http://1eeing.github.io/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E9%80%9A%E8%AF%86/"/>
    
      <category term="Git高级操作" scheme="http://1eeing.github.io/tags/Git%E9%AB%98%E7%BA%A7%E6%93%8D%E4%BD%9C/"/>
    
  </entry>
  
  <entry>
    <title>【算法篇】树、动态规划及字符串相关</title>
    <link href="http://1eeing.github.io/2018/08/27/%E6%A0%91%E5%92%8C%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"/>
    <id>http://1eeing.github.io/2018/08/27/树和动态规划/</id>
    <published>2018-08-26T17:11:12.317Z</published>
    <updated>2018-09-12T16:06:07.777Z</updated>
    
    <content type="html"><![CDATA[<h1 id="树"><a href="#树" class="headerlink" title="树"></a>树</h1><h2 id="非递归实现中先序、中序、后续遍历"><a href="#非递归实现中先序、中序、后续遍历" class="headerlink" title="非递归实现中先序、中序、后续遍历"></a>非递归实现中先序、中序、后续遍历</h2><p>非递归实现使用了栈的结构，通过栈的先进后出模拟递归实现。</p><p>以下是先序遍历代码实现<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">pre</span>(<span class="params">root</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span>(root)&#123;</span><br><span class="line">    <span class="keyword">let</span> stack = [];</span><br><span class="line">    <span class="comment">// 先将根节点 push</span></span><br><span class="line">    stack.push(root);</span><br><span class="line">    <span class="comment">// 判断栈中是否为空</span></span><br><span class="line">    <span class="keyword">while</span>(stack.length &gt; <span class="number">0</span>)&#123;</span><br><span class="line">      <span class="comment">// 弹出栈顶元素</span></span><br><span class="line">      root = stack.pop();</span><br><span class="line">      <span class="built_in">console</span>.log(root);</span><br><span class="line">      <span class="comment">// 因为先序遍历是先左后右，栈是先进后出结构</span></span><br><span class="line">      <span class="comment">// 所以先push右边再push左边</span></span><br><span class="line">      <span class="keyword">if</span>(root.right)&#123;</span><br><span class="line">        stack.push(root.right);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">if</span>(root.left)&#123;</span><br><span class="line">        stack.push(root.left);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><a id="more"></a><p>以下是中序遍历代码实现<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">mid</span>(<span class="params">root</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span>(root)&#123;</span><br><span class="line">    <span class="keyword">let</span> stack = [];</span><br><span class="line">    <span class="comment">// 中序遍历是先左再根最后右</span></span><br><span class="line">    <span class="comment">// 所以首先应该先把最左边节点遍历到底依次push进栈</span></span><br><span class="line">    <span class="comment">// 当左边没有节点时，就打印栈顶元素，然后寻找右节点</span></span><br><span class="line">    <span class="comment">// 对于最左边的叶节点来说，可以把它看成是两个 null 节点的父节点</span></span><br><span class="line">    <span class="comment">// 左边打印不出东西就把父节点拿出来打印，然后再看右节点</span></span><br><span class="line">    <span class="keyword">while</span>(stack.length &gt; <span class="number">0</span> || root)&#123;</span><br><span class="line">      <span class="keyword">if</span>(root) &#123;</span><br><span class="line">        stack.push(root);</span><br><span class="line">        root = root.left;</span><br><span class="line">      &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        root = stack.pop();</span><br><span class="line">        <span class="built_in">console</span>.log(root);</span><br><span class="line">        root = root.right;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>以下是后续遍历代码实现，该代码使用了两个栈来实现遍历，相比一个栈的遍历来说要容易理解得多<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">pos</span>(<span class="params">root</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span>(root)&#123;</span><br><span class="line">    <span class="keyword">let</span> stack1 = [];</span><br><span class="line">    <span class="keyword">let</span> stack2 = [];</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 后续遍历是先左再右最后根</span></span><br><span class="line">    <span class="comment">// 所以对于一个栈来说，应该先push根节点</span></span><br><span class="line">    <span class="comment">// 然后push右节点，最后push左节点</span></span><br><span class="line">    stack1.push(root);</span><br><span class="line">    <span class="keyword">while</span>(stack1.length &gt; <span class="number">0</span>)&#123;</span><br><span class="line">      root = stack1.pop();</span><br><span class="line">      stack2.push(root);</span><br><span class="line">      <span class="keyword">if</span>(root.left)&#123;</span><br><span class="line">        stack1.push(root.left);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">if</span>(root.right)&#123;</span><br><span class="line">        stack1.push(root.right)</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span>(stack2.length &gt; <span class="number">0</span>)&#123;</span><br><span class="line">      <span class="built_in">console</span>.log(stack2.pop());</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2 id="中序遍历的前驱后续节点"><a href="#中序遍历的前驱后续节点" class="headerlink" title="中序遍历的前驱后续节点"></a>中序遍历的前驱后续节点</h2><p>实现这个算法的前提是节点有一个parent的指针指向父节点，根节点指向null</p><p><img src="https://user-gold-cdn.xitu.io/2018/4/24/162f61ad8e8588b7?w=682&amp;h=486&amp;f=png&amp;s=41027" alt="https://user-gold-cdn.xitu.io/2018/4/24/162f61ad8e8588b7?w=682&amp;h=486&amp;f=png&amp;s=41027"></p><p>如果所示，该树的中序遍历结果是4,2,5,1,6,3,7</p><h3 id="前驱节点"><a href="#前驱节点" class="headerlink" title="前驱节点"></a>前驱节点</h3><p>对于节点2来说，他的前驱节点就是4，按照中序遍历规则（左、根、右），可以得出以下结论</p><ol><li>如果选取的节点的左节点不为空，就找该左节点最右的节点。对于节点1来说，他有左节点2，那么节点2的最右节点就是5</li><li>如果左节点为空，且目标节点是父节点的右节点，那么前驱节点为父节点。对于节点5来说，没有左节点，且是节点2的右节点，所以节点2是前驱节点</li><li>如果左节点为空，且目标节点是父节点的左节点，向上寻找到第一个是父节点的右节点的节点。对于节点6来说，没有左节点，且是节点3的左节点，所以向上寻找到节点1，发现节点3是节点1的右节点，所以节点1是节点6的前驱节点</li></ol><p>代码实现<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">predecessor</span>(<span class="params">node</span>)</span>&#123;</span><br><span class="line">  <span class="keyword">if</span>(!node) rteurn;</span><br><span class="line">  <span class="comment">// 结论1</span></span><br><span class="line">  <span class="keyword">if</span>(node.left)&#123;</span><br><span class="line">    <span class="keyword">return</span> getRight(node.left);</span><br><span class="line">  &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">    <span class="keyword">let</span> parent = node.parent;</span><br><span class="line">    <span class="comment">// 结论23的判断</span></span><br><span class="line">    <span class="keyword">while</span>(parent &amp;&amp; parent.right === node)&#123;</span><br><span class="line">      node = parent;</span><br><span class="line">      parent = node.parent;</span><br><span class="line">    &#125;</span><br><span class="line">    retrn parent;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getRight</span>(<span class="params">node</span>)</span>&#123;</span><br><span class="line">  <span class="keyword">if</span>(!node) <span class="keyword">return</span>;</span><br><span class="line">  node = node.right;</span><br><span class="line">  <span class="keyword">while</span>(node) node = node.right;</span><br><span class="line">  <span class="keyword">return</span> node;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="后继节点"><a href="#后继节点" class="headerlink" title="后继节点"></a>后继节点</h3><p>对于节点2来说，他的后继节点就是5，按照中序遍历原则，可以得出以下结论</p><ol><li>如果有右节点，就找到该右节点的最左节点。对于节点1来说，他有右节点3，那么节点3的最左节点就是6</li><li>如果没有右节点，就向上遍历直到找到一个节点是父节点的左节点。对于节点5来说，没有右节点，就向上寻找到节点2，该节点是父节点1的左节点，所以节点1是后继节点</li></ol><p>代码实现：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">successor</span>(<span class="params">node</span>)</span>&#123;</span><br><span class="line">  <span class="keyword">if</span>(!node) <span class="keyword">return</span>;</span><br><span class="line">  <span class="comment">// 结论1</span></span><br><span class="line">  <span class="keyword">if</span>(node.right)&#123;</span><br><span class="line">    <span class="keyword">return</span> getLeft(node.right);</span><br><span class="line">  &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">    <span class="comment">// 结论2</span></span><br><span class="line">    <span class="keyword">let</span> parent = node.parent;</span><br><span class="line">    <span class="comment">// 判断parent为空</span></span><br><span class="line">    <span class="keyword">while</span>(parent &amp;&amp; parent.left === node)&#123;</span><br><span class="line">      node = parent;</span><br><span class="line">      parent = node.parent;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> parent;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getLeft</span>(<span class="params">node</span>)</span>&#123;</span><br><span class="line">  <span class="keyword">if</span>(!node) <span class="keyword">return</span></span><br><span class="line">  node = node.left;</span><br><span class="line">  <span class="keyword">while</span>(node) node = node.left;</span><br><span class="line">  <span class="keyword">return</span> node;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><hr><h1 id="动态规划"><a href="#动态规划" class="headerlink" title="动态规划"></a>动态规划</h1><p>动态规划背后的基本思想非常简单，就是将一个问题拆分为子问题，一般来说这些子问题都是非常相似的，那么我们可以通过只解决一次每个子问题来达到减少计算量的目的。</p><p>一旦得出每个子问题的解，就存储该结果以便下次使用。</p><h2 id="斐波那契数列"><a href="#斐波那契数列" class="headerlink" title="斐波那契数列"></a>斐波那契数列</h2><p>斐波那契数列就是从0和1开始，后面的数都是前两个数之和。<br>那么显而易见，我们可以通过递归的方式来完成求解斐波那契数列</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fib</span>(<span class="params">n</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span>(n &lt; <span class="number">2</span> &amp;&amp; n &gt;= <span class="number">0</span>) <span class="keyword">return</span> n;</span><br><span class="line">  <span class="keyword">return</span> fib(n - <span class="number">1</span>) + fib(n - <span class="number">2</span>);</span><br><span class="line">&#125;</span><br><span class="line">fib(<span class="number">10</span>);</span><br></pre></td></tr></table></figure><p>以上代码已经可以完美的解决问题，但是以上解法却存在很严重的性能问题，当n越大的时候，需要的时间是指数增长的，这时候就可以通过动态规划来解决这个问题。</p><p>动态规划的本质其实就两点</p><ol><li>自底向上分解子问题</li><li>通过变量存储已经计算过的解</li></ol><p>根据上面两点，斐波那契数列的动态规划思路也就出来了</p><ol><li>斐波那契数列从0和1开始，那么这就是这个子问题的最底层</li><li>通过数组来存储每一位所对应的斐波那契数列的值</li></ol><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fib</span>(<span class="params">n</span>)</span>&#123;</span><br><span class="line">  <span class="keyword">let</span> array = <span class="keyword">new</span> <span class="built_in">Array</span>(n + <span class="number">1</span>).fill(<span class="literal">null</span>);</span><br><span class="line">  array[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">  array[<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">let</span> i = <span class="number">2</span>; i &lt;= n; i++)&#123;</span><br><span class="line">    array[i] = array[i - <span class="number">1</span>] + array[i - <span class="number">2</span>];</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> array[n];</span><br><span class="line">&#125;</span><br><span class="line">fib(<span class="number">10</span>);</span><br></pre></td></tr></table></figure><h2 id="0-1-背包问题"><a href="#0-1-背包问题" class="headerlink" title="0 - 1 背包问题"></a>0 - 1 背包问题</h2><p>该问题可以描述为：给定一组物品，没种物品都有自己的重量和价格，在限定的总重量内，我们如何选择，才能使得物品的总价格最高。每个问题只能放入至多一次。</p><p>假设我们有以下物品</p><table><thead><tr><th>物品ID/重量</th><th style="text-align:center">价值</th></tr></thead><tbody><tr><td>1</td><td style="text-align:center">3</td></tr><tr><td>2</td><td style="text-align:center">7</td></tr><tr><td>3</td><td style="text-align:center">12</td></tr></tbody></table><p>对于一个总容量为5的背包来说，我们可以放入重量2和3的物品来达到背包被的物品总价值最高。<br>对于这个问题来说，子问题就两个，分别是放物品和不放物品，可以通过以下表格来理解子问题</p><table><thead><tr><th style="text-align:center">物品ID/剩余容量</th><th style="text-align:center">0</th><th>1</th><th>2</th><th>3</th><th>4</th><th>5</th></tr></thead><tbody><tr><td style="text-align:center">1</td><td style="text-align:center">0</td><td>3</td><td>3</td><td>3</td><td>3</td><td>3</td></tr><tr><td style="text-align:center">2</td><td style="text-align:center">0</td><td>3</td><td>7</td><td>10</td><td>10</td><td>10</td></tr><tr><td style="text-align:center">3</td><td style="text-align:center">0</td><td>3</td><td>7</td><td>12</td><td>15</td><td>19</td></tr></tbody></table><p>直接来分析能放三种物品的情况，也就是最后一行</p><ul><li>当容量少于3时，只取上一行对应的数据，因为当前容量不能容纳物品3</li><li>当容量为3时，考虑两种情况，分别为放入物品3和不放物品3<ul><li>不放物品3的情况下，总价值为10</li><li>放入物品3的情况下，总价值为12，所以应该放入物品3</li></ul></li><li>当容量为4时，考虑两种情况，分别为放入物品3和不放物品3<ul><li>不放物品3的情况下，总价值为10</li><li>放入物品3的情况下，和放入物品1的价值相加，得出总价值为15，所以应该放入物品3</li></ul></li><li>当容量为5时，考虑两种情况，分别为放入物品3和不放物品3<ul><li>不放物品3的情况下，总价值为10</li><li>放入物品3的情况下，和放入物品2的价值相加，得出总价值为19，所以应该放入物品3</li></ul></li></ul><p>代码如下<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @param &#123;*&#125; w 物品重量</span></span><br><span class="line"><span class="comment"> * @param &#123;*&#125; v 物品价值</span></span><br><span class="line"><span class="comment"> * @param &#123;*&#125; c 总容量</span></span><br><span class="line"><span class="comment"> * @returns</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">knapsack</span>(<span class="params">w,v,c</span>)</span>&#123;</span><br><span class="line">  <span class="keyword">let</span> length = w.length;</span><br><span class="line">  <span class="keyword">if</span>(length === <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// 对照表格，生成的二维数组，第一维代表物品，第二维代表背包剩余容量</span></span><br><span class="line">  <span class="comment">// 第二维中的元素代表背包物品总价值</span></span><br><span class="line">  <span class="keyword">let</span> array = <span class="keyword">new</span> <span class="built_in">Array</span>(length).fill(<span class="keyword">new</span> <span class="built_in">Array</span>(c + <span class="number">1</span>).fill(<span class="literal">null</span>));</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// 完成底部子问题的解</span></span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">let</span> i = <span class="number">0</span>; i &lt;= c; i++)&#123;</span><br><span class="line">    <span class="comment">// 对照表格第一行，array[0]代表物品1</span></span><br><span class="line">    <span class="comment">// i代表剩余总容量</span></span><br><span class="line">    <span class="comment">// 当剩余总容量大于物品1的重量时，记录下背包物品总价值，否则价值为0</span></span><br><span class="line">    array[<span class="number">0</span>][i] = i &gt;= w[<span class="number">0</span>] ? v[<span class="number">0</span>] : <span class="number">0</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// 自底向上开始解决子问题，从物品2开始</span></span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">let</span> i = <span class="number">1</span>; i &lt; length; i++)&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">let</span> j = <span class="number">0</span>; j &lt;= c; j++)&#123;</span><br><span class="line">      <span class="comment">// 这里求解子问题，分别为不放当前物品和放当前物品</span></span><br><span class="line">      <span class="comment">// 先求不放当前物品的背包总价值，这里的值也就是对应表格中上一行对应的值</span></span><br><span class="line">      array[i][j] = array[i - <span class="number">1</span>][j];</span><br><span class="line">      <span class="comment">// 判断当前剩余容量是否可以放入当前物品</span></span><br><span class="line">      <span class="keyword">if</span>(j &gt;= w[i])&#123;</span><br><span class="line">        <span class="comment">// 可以放入的话，就比大小</span></span><br><span class="line">        <span class="comment">// 放入当前物品和不放入当前物品，哪个背包总价值大</span></span><br><span class="line">        array[i][j] = <span class="built_in">Math</span>.max(array[i][j], v[i] + array[i <span class="number">-1</span>][j - w[i]])</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> array[length - <span class="number">1</span>][c];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2 id="最长递增子序列"><a href="#最长递增子序列" class="headerlink" title="最长递增子序列"></a>最长递增子序列</h2><p>这个问题的动态思路解法很简单，直接上代码<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">lis</span>(<span class="params">n</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span>(n.length === <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">let</span> array = <span class="keyword">new</span> <span class="built_in">Array</span>(n.length).fill(<span class="number">1</span>);</span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">let</span> i = <span class="number">1</span>; i &lt; n.length; i ++)&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">let</span> j = <span class="number">0</span>; j &lt; i; j++)&#123;</span><br><span class="line">      <span class="keyword">if</span>(n[i] &gt; n[j])&#123;</span><br><span class="line">        array[i] = <span class="built_in">Math</span>.max(array[i], <span class="number">1</span> + array[j]);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">let</span> res = <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; array.length; i++)&#123;</span><br><span class="line">    res = <span class="built_in">Math</span>.max(res, array[i]);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><hr><h1 id="字符串相关"><a href="#字符串相关" class="headerlink" title="字符串相关"></a>字符串相关</h1><p>在字符串相关的算法中，Trie树可以解决很多问题，同时又具备良好的空间和时间复杂度，比如以下问题</p><ul><li>词频统计</li><li>前缀匹配</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;树&quot;&gt;&lt;a href=&quot;#树&quot; class=&quot;headerlink&quot; title=&quot;树&quot;&gt;&lt;/a&gt;树&lt;/h1&gt;&lt;h2 id=&quot;非递归实现中先序、中序、后续遍历&quot;&gt;&lt;a href=&quot;#非递归实现中先序、中序、后续遍历&quot; class=&quot;headerlink&quot; title=&quot;非递归实现中先序、中序、后续遍历&quot;&gt;&lt;/a&gt;非递归实现中先序、中序、后续遍历&lt;/h2&gt;&lt;p&gt;非递归实现使用了栈的结构，通过栈的先进后出模拟递归实现。&lt;/p&gt;
&lt;p&gt;以下是先序遍历代码实现&lt;br&gt;&lt;figure class=&quot;highlight js&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;15&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;16&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;17&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;18&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;19&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;20&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;21&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;function&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;pre&lt;/span&gt;(&lt;span class=&quot;params&quot;&gt;root&lt;/span&gt;) &lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt;(root)&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;let&lt;/span&gt; stack = [];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;comment&quot;&gt;// 先将根节点 push&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    stack.push(root);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;comment&quot;&gt;// 判断栈中是否为空&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;while&lt;/span&gt;(stack.length &amp;gt; &lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;)&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;      &lt;span class=&quot;comment&quot;&gt;// 弹出栈顶元素&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;      root = stack.pop();&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;      &lt;span class=&quot;built_in&quot;&gt;console&lt;/span&gt;.log(root);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;      &lt;span class=&quot;comment&quot;&gt;// 因为先序遍历是先左后右，栈是先进后出结构&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;      &lt;span class=&quot;comment&quot;&gt;// 所以先push右边再push左边&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;      &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt;(root.right)&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        stack.push(root.right);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;      &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;      &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt;(root.left)&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        stack.push(root.left);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;      &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="学习笔记" scheme="http://1eeing.github.io/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="学习笔记" scheme="http://1eeing.github.io/tags/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
      <category term="基础知识" scheme="http://1eeing.github.io/tags/%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"/>
    
      <category term="计算机通识" scheme="http://1eeing.github.io/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E9%80%9A%E8%AF%86/"/>
    
      <category term="算法" scheme="http://1eeing.github.io/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="动态规划" scheme="http://1eeing.github.io/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"/>
    
      <category term="树" scheme="http://1eeing.github.io/tags/%E6%A0%91/"/>
    
      <category term="字符串相关" scheme="http://1eeing.github.io/tags/%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%9B%B8%E5%85%B3/"/>
    
  </entry>
  
  <entry>
    <title>【浏览器篇】浏览器的缓存策略</title>
    <link href="http://1eeing.github.io/2018/08/19/%E6%B5%8F%E8%A7%88%E5%99%A8%E7%9A%84%E7%BC%93%E5%AD%98%E7%AD%96%E7%95%A5/"/>
    <id>http://1eeing.github.io/2018/08/19/浏览器的缓存策略/</id>
    <published>2018-08-18T16:49:14.743Z</published>
    <updated>2018-08-18T16:52:45.893Z</updated>
    
    <content type="html"><![CDATA[<p>通常浏览器缓存策略分为两种</p><ul><li>强缓存<br>实现强缓存可以通过两种响应头实现，表示在缓存期间不需要请求，state code为200<ul><li>Expires：HTTP/1.0的产物，表示在XX时间后过期，受限于本地时间</li><li>Cache-Control：HTTP/1.1，优先级高于Expires，值为max-age=xx，表示xx秒后过期</li></ul></li></ul><a id="more"></a><ul><li><p>协商缓存</p><ul><li><p>Last-Modified和If-Modified-Since：Last-Modified表示本地文件最后修改日期，If-Modified-Since会将   Last-Modified的值发送给服务器，询问服务器在该日期后资源是否有更新，有更新的话就会将新的资源发送   回来。但是如果在本地打开缓存文件，就会造成Last-Modified被修改，所以在HTTP/1.1中出现了ETag。</p></li><li><p>ETag和If-None-Match：Etag类似于文件指纹，If-None-Match会将当前Etag发送给服务器，询问该资源ETag   是否有变动，有的话则将新的资源发送回来。优先级比Last-Modified高。</p></li></ul></li></ul><p>对于大部分的场景都可以使用强缓存配合协商缓存解决，但是在一些特殊的地方可能需要选择特殊的缓存策略</p><ul><li>对于某些不需要缓存的资源，可以使用Cache-Control: no-store</li><li>对于频繁变动的资源，可以使用Cache-Control配合ETag使用</li><li>对于代码文件来说，可以使用Cache-Control: max-age=3153600，并配合缓存策略使用，然后对文件进行指纹吹，一旦文件名变动就会下载新的文件</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;通常浏览器缓存策略分为两种&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;强缓存&lt;br&gt;实现强缓存可以通过两种响应头实现，表示在缓存期间不需要请求，state code为200&lt;ul&gt;
&lt;li&gt;Expires：HTTP/1.0的产物，表示在XX时间后过期，受限于本地时间&lt;/li&gt;
&lt;li&gt;Cache-Control：HTTP/1.1，优先级高于Expires，值为max-age=xx，表示xx秒后过期&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
      <category term="学习笔记" scheme="http://1eeing.github.io/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="学习笔记" scheme="http://1eeing.github.io/tags/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
      <category term="基础知识" scheme="http://1eeing.github.io/tags/%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"/>
    
      <category term="计算机通识" scheme="http://1eeing.github.io/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E9%80%9A%E8%AF%86/"/>
    
      <category term="浏览器" scheme="http://1eeing.github.io/tags/%E6%B5%8F%E8%A7%88%E5%99%A8/"/>
    
      <category term="缓存策略" scheme="http://1eeing.github.io/tags/%E7%BC%93%E5%AD%98%E7%AD%96%E7%95%A5/"/>
    
  </entry>
  
  <entry>
    <title>【算法篇】排序与链表</title>
    <link href="http://1eeing.github.io/2018/08/18/%E6%8E%92%E5%BA%8F%E5%92%8C%E9%93%BE%E8%A1%A8/"/>
    <id>http://1eeing.github.io/2018/08/18/排序和链表/</id>
    <published>2018-08-18T14:06:03.879Z</published>
    <updated>2018-08-18T14:11:14.603Z</updated>
    
    <content type="html"><![CDATA[<h1 id="排序"><a href="#排序" class="headerlink" title="排序"></a>排序</h1><p>排序算法是计算机中比较常用的算法，这边整理了如下几种排序算法：</p><ul><li>冒泡排序</li><li>插入排序</li><li>选择排序</li><li>归并排序</li><li>快排</li><li>堆排序</li></ul><p>以下两个函数是排序中会用到的通用函数</p><a id="more"></a><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">checkArray</span>(<span class="params">array</span>)</span>&#123;</span><br><span class="line">  <span class="keyword">if</span>(!array || array.length &lt;= <span class="number">2</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">  <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">swap</span>(<span class="params">array, left, right</span>)</span>&#123;</span><br><span class="line">  <span class="keyword">let</span> rightValue = array[right];</span><br><span class="line">  array[right] = array[left];</span><br><span class="line">  array[left] = rightValue;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="冒泡排序"><a href="#冒泡排序" class="headerlink" title="冒泡排序"></a>冒泡排序</h2><p>冒泡排序的原理如下，从第一个元素开始，把当前元素和下一个索引元素进行比较。如果当前元素大，那么就交换位置，重复操作直到比较到最后一个元素，那么此时最后一个元素就是该数组中最大的数。下一轮重复以上操作，但是此时最后一个元素已经是最大数了，所以不需要再比较最后一个元素，只需要比较到 <code>length - 1</code> 的位置。</p><p><img src="https://user-gold-cdn.xitu.io/2018/4/12/162b895b452b306c?w=670&amp;h=508&amp;f=gif&amp;s=282307" alt="https://user-gold-cdn.xitu.io/2018/4/12/162b895b452b306c?w=670&amp;h=508&amp;f=gif&amp;s=282307"></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">bubble</span>(<span class="params">arr</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> <span class="keyword">continue</span> = checkArray(arr);</span><br><span class="line">  <span class="keyword">if</span>(!<span class="keyword">continue</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">let</span> i = arr.length - <span class="number">1</span>; i &gt; <span class="number">0</span>; i--)&#123;</span><br><span class="line">    <span class="comment">// 从0到length - 1遍历</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">let</span> j = <span class="number">0</span>; j &lt; i; j++)&#123;</span><br><span class="line">      <span class="keyword">if</span>(arr[j] &gt; arr[j + <span class="number">1</span>])&#123;</span><br><span class="line">        swap(arr, j, j+<span class="number">1</span>);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>该算法的操作次数是一个等差数列 <code>n + (n - 1) + (n - 2) + …… + 1</code> ，去掉常数项以后得出时间复杂度是O(n * n)</p><h2 id="插入排序"><a href="#插入排序" class="headerlink" title="插入排序"></a>插入排序</h2><p>插入排序的原理如下。第一个元素默认是已排序元素，取出下一个元素和当前元素比较，如果当前元素大就交换位置。那么此时第一个元素就是当前的最小数，所以下次取出操作从第三个元素开始，向前对比，重复之前的操作。</p><p><img src="https://user-gold-cdn.xitu.io/2018/4/12/162b895c7e59dcd1?w=670&amp;h=508&amp;f=gif&amp;s=609549" alt="https://user-gold-cdn.xitu.io/2018/4/12/162b895c7e59dcd1?w=670&amp;h=508&amp;f=gif&amp;s=609549"></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">insertion</span>(<span class="params">arr</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> <span class="keyword">continue</span> = checkArray(arr);</span><br><span class="line">  <span class="keyword">if</span>(!<span class="keyword">continue</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">let</span> i = <span class="number">1</span>; i &lt; arr.length; i++)&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">let</span> j = i - <span class="number">1</span>; j &gt;=<span class="number">0</span> &amp;&amp; arr[j] &gt; arr[j + <span class="number">1</span>]; j--)&#123;</span><br><span class="line">      swap(arr, j, j + <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> arr;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>该算法的操作次数是一个等差数列 <code>n + (n - 1) + (n - 2) + …… + 1</code> ，去掉常数项以后得出时间复杂度是O(n * n)</p><h2 id="选择排序"><a href="#选择排序" class="headerlink" title="选择排序"></a>选择排序</h2><p>选择排序的原理如下。遍历数组，设置最小值的索引为0，如果取出的值比当前最小值小，就替换最小值索引，遍历完成后，将第一个元素和最小值索引上的值交换。如上操作后，第一个元素就是数组中的最小值，下次遍历就可以从索引1开始重复上述操作。</p><p><img src="https://user-gold-cdn.xitu.io/2018/4/13/162bc8ea14567e2e?w=670&amp;h=508&amp;f=gif&amp;s=965636" alt="https://user-gold-cdn.xitu.io/2018/4/13/162bc8ea14567e2e?w=670&amp;h=508&amp;f=gif&amp;s=965636"></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">selection</span>(<span class="params">arr</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> <span class="keyword">continue</span> = checkArray(arr);</span><br><span class="line">  <span class="keyword">if</span>(!<span class="keyword">continue</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; arr.length; i++)&#123;</span><br><span class="line">    <span class="keyword">let</span> minIndex = i;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">let</span> j = i + <span class="number">1</span>; j &lt; arr.length; j++)&#123;</span><br><span class="line">      minIndex = arr[j] &lt; arr[minIndex] ? j : minIndex;</span><br><span class="line">    &#125;</span><br><span class="line">    swap(arr, i, minIndex);</span><br><span class="line">  &#125;</span><br><span class="line">  retrn arr;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>时间复杂度O(n * n)。</p><h2 id="归并排序"><a href="#归并排序" class="headerlink" title="归并排序"></a>归并排序</h2><p>递归的将数组两两分开直到最多包含两个元素，然后将数组排序合并，最终合并为排序好的数组。假设我有一组数组[3,1,2,8,9,7,6]，中间数索引是3，先排序数组[3,1,2,8]。在这个左边数组上，继续拆分直到变成数组包含两个元素（如果数组长度是奇数的话，会有一个拆分数组只包含一个元素）。然后排序数组[3,1]和[2,8]，然后再排序数组 [1,3,2,8]，这样左边数组就排序完成，然后按照以上思路排序右边数组，最后将数组[1,2,3,8]和[6,7,9]排序。</p><p><img src="https://user-gold-cdn.xitu.io/2018/4/13/162be13c7e30bd86?w=896&amp;h=1008&amp;f=gif&amp;s=937952" alt="https://user-gold-cdn.xitu.io/2018/4/13/162be13c7e30bd86?w=896&amp;h=1008&amp;f=gif&amp;s=937952"></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">sort</span>(<span class="params">arr</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> <span class="keyword">continue</span> = checkArray(arr);</span><br><span class="line">  <span class="keyword">if</span>(!<span class="keyword">continue</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  mergeSort(arr, <span class="number">0</span>, arr.length - <span class="number">1</span>);</span><br><span class="line">  <span class="keyword">return</span> arr;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">mergeSort</span>(<span class="params">arr, left, right</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 左右索引相同说明已经只有一个数</span></span><br><span class="line">  <span class="keyword">if</span>(left === right) <span class="keyword">return</span>;</span><br><span class="line">  <span class="comment">// 等同于 left + (right - left) / 2</span></span><br><span class="line">  <span class="comment">// 相比 (left + right) / 2 更加安全，不会溢出</span></span><br><span class="line">  <span class="comment">// 使用位运算，因为快</span></span><br><span class="line">  <span class="keyword">let</span> mid = <span class="built_in">parseInt</span>(left + (right - left) &gt;&gt; <span class="number">1</span>);</span><br><span class="line">  mergeSort(arr, left, mid);</span><br><span class="line">  mergeSort(arr, mid + <span class="number">1</span>, right);</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">let</span> help = [];</span><br><span class="line">  <span class="keyword">let</span> i = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">let</span> p1 = left;</span><br><span class="line">  <span class="keyword">let</span> p2 = mid + <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">while</span>(p1 &lt;= mid &amp;&amp; p2 &lt;= right)&#123;</span><br><span class="line">    help[i++] = arr[p1] &lt; arr[p2] ? arr[p1++] : arr[p2++];</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">while</span>(p1 &lt;= mid)&#123;</span><br><span class="line">    help[i++] = arr[p1++];</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">while</span>(p2 &lt;= right) &#123;</span><br><span class="line">    help[i++] = arr[p2++];</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; help.length; i++)&#123;</span><br><span class="line">    arr[left + i] = help[i];</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> arr;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>时间复杂度O(N * logN)。</p><h2 id="快排"><a href="#快排" class="headerlink" title="快排"></a>快排</h2><p>随机选取一个数组中的值作为基准值，从左至右取值与基准值对比大小。比基准值小的放数组左边，大的放右边，对比完成后将基准值和第一个比基准值大的值交换位置。然后将数组以基准值的位置分为两部分，继续递归以上操作。</p><p><img src="https://user-gold-cdn.xitu.io/2018/4/16/162cd23e69ca9ea3?w=824&amp;h=506&amp;f=gif&amp;s=867744" alt="https://user-gold-cdn.xitu.io/2018/4/16/162cd23e69ca9ea3?w=824&amp;h=506&amp;f=gif&amp;s=867744"></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">sort</span>(<span class="params">arr</span>)</span>&#123;</span><br><span class="line">  <span class="keyword">let</span> <span class="keyword">continue</span> = checkArray(arr);</span><br><span class="line">  <span class="keyword">if</span>(!<span class="keyword">continue</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  quickSort(arr, <span class="number">0</span>, arr.length - <span class="number">1</span>);</span><br><span class="line">  <span class="keyword">return</span> arr;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">quickSort</span>(<span class="params">arr, left, right</span>)</span>&#123;</span><br><span class="line">  <span class="keyword">if</span>(left &lt; right)&#123;</span><br><span class="line">    swap(arr, , right);</span><br><span class="line">    <span class="keyword">let</span> indexs = part(arr, <span class="built_in">parseInt</span>(<span class="built_in">Math</span>.random() * (right - left + <span class="number">1</span>)) + left, right);</span><br><span class="line">    quickSort(arr, left, indexs[<span class="number">0</span>]);</span><br><span class="line">    quickSort(arr, indexs[<span class="number">1</span>] + <span class="number">1</span>, right);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">part</span>(<span class="params">arr, left, right</span>)</span>&#123;</span><br><span class="line">  <span class="keyword">let</span> less = left - <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">let</span> more = right;</span><br><span class="line">  <span class="keyword">while</span>(left &lt; more) &#123;</span><br><span class="line">    <span class="keyword">if</span>(arr[left] &lt; arr[right])&#123;</span><br><span class="line">      ++less;</span><br><span class="line">      ++left;</span><br><span class="line">    &#125;<span class="keyword">else</span> <span class="keyword">if</span>(arr[left] &gt; arr[right])&#123;</span><br><span class="line">      swap(arr, --more, left);</span><br><span class="line">    &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">      left ++;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  swap(arr, right, more);</span><br><span class="line">  <span class="keyword">return</span> [less, more];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>该算法的复杂度和归并排序是相同的，但是额外空间复杂度比归并排序少，只需O(logN)，并且相比归并排序来说，所需的常数时间也更少。</p><h2 id="堆排序"><a href="#堆排序" class="headerlink" title="堆排序"></a>堆排序</h2><p>堆排序利用了二叉堆的特性来做，二叉堆通常用数组表示，并且二叉堆是一颗完全二叉树（所有叶子节点都是从左往右顺序排序，并且其他层的节点都是满的）。二叉堆又分为大根堆与小根堆。</p><blockquote><ul><li>大根堆是某个节点的所有子节点的值都比他小</li><li>小根堆是某个节点的所有子节点的值都比他大</li></ul></blockquote><p>堆排序的原理就是组成一个大根堆或者小根堆。以小根堆为例，某个节点的左边子节点索引是 i <em> 2 + 1，右边是i </em> 2 + 2 ，父节点是 (i - 1) / 2。</p><ol><li>首先遍历数组，判断该节点的父节点是否比他小，如果小就交换位置并继续判断，直到他的父节点比他大。</li><li>重新以上操作1，直到数组首位是最大值</li><li>将首位和末尾交换位置并将数组长度减一，表示数组末尾已是最大值，不需要再比较大小。</li><li>对比左右节点哪个大，然后记住大的节点的索引并且和父节点对比大小，如果子节点大就交换位置</li><li>重复 3-4 直到整个数组都是大根堆</li></ol><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">heap</span>(<span class="params">arr</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> <span class="keyword">continue</span> = checkArray(arr);</span><br><span class="line">  <span class="keyword">if</span>(!<span class="keyword">continue</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 将最大值交换到首位</span></span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; arr.length; i++)&#123;</span><br><span class="line">    heapInsert(arr, i);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">let</span> size = arr.length;</span><br><span class="line">  <span class="comment">// 交换首位和末尾</span></span><br><span class="line">  swap(arr, <span class="number">0</span>, --size);</span><br><span class="line">  <span class="keyword">while</span>(size &gt; <span class="number">0</span>)&#123;</span><br><span class="line">    heapify(arr, <span class="number">0</span>, size);</span><br><span class="line">    swap(arr, <span class="number">0</span>, --size);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> arr;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">heapInsert</span>(<span class="params">arr, index</span>)</span>&#123;</span><br><span class="line">  <span class="comment">// 如果当前节点比父节点大，就交换</span></span><br><span class="line">  <span class="keyword">while</span>(arr[index] &gt; arr[<span class="built_in">parseInt</span>((index - <span class="number">1</span>) / <span class="number">2</span>)])&#123;</span><br><span class="line">    swap(arr, index, <span class="built_in">parseInt</span>((index - <span class="number">1</span>) / <span class="number">2</span>));</span><br><span class="line">    <span class="comment">// 将索引变成父节点</span></span><br><span class="line">    index = <span class="built_in">parseInt</span>((index - <span class="number">1</span>) / <span class="number">2</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">heapify</span>(<span class="params">arr, index, size</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> left = index * <span class="number">2</span> + <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">while</span>(left &lt; size) &#123;</span><br><span class="line">    <span class="comment">// 判断左右节点大小</span></span><br><span class="line">    <span class="keyword">let</span> largest = left + <span class="number">1</span> &lt; size &amp;&amp; arr[left] &lt; arr[left + <span class="number">1</span>] ? left + <span class="number">1</span> : left;</span><br><span class="line">    <span class="comment">// 判断子节点和父节点大小</span></span><br><span class="line">    largest = arr[index] &gt; arr[largest] ? largest : index;</span><br><span class="line">    <span class="keyword">if</span>(largest === index) <span class="keyword">break</span>;</span><br><span class="line">    swap(arr, index, largest);</span><br><span class="line">    index = largest;</span><br><span class="line">    left = index * <span class="number">2</span> + <span class="number">1</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>以上实现了小根堆，如果需要实现大根堆，只需要把节点对比反一下就好。<br>该算法复杂度是O(logN)。</p><h2 id="系统自带排序实现"><a href="#系统自带排序实现" class="headerlink" title="系统自带排序实现"></a>系统自带排序实现</h2><p>每个语言的排序内部实现都是不同的。<br>对于js来说，数组长度大于10会采用快排，否则使用插入排序。选择插入排序是因为虽然时间复杂度很差，但是在数据量很小的情况下和O(n * logN) 相差无几，然后插入排序需要的时间常数很小，所以相对别的排序来说更快。</p><p>对于java来说，还会考虑内部的元素的类型。对于存储对象的数组来说，会采用稳定性好的算法。稳定性的意思就是对于相同值来说，相对顺序不能改变。</p><hr><h1 id="链表"><a href="#链表" class="headerlink" title="链表"></a>链表</h1><h2 id="反转单向链表"><a href="#反转单向链表" class="headerlink" title="反转单向链表"></a>反转单向链表</h2><p>思路很简单，使用三个变量分别表示当前节点和当前节点的前后节点。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">reverseList</span>(<span class="params">head</span>)</span>&#123;</span><br><span class="line">  <span class="comment">// 判断下变量边界问题</span></span><br><span class="line">  <span class="keyword">if</span>(!head || !head.next) <span class="keyword">return</span> head;</span><br><span class="line">  <span class="comment">// 初始设置为空，因为第一个节点反转后就是尾部，尾部节点指向 null</span></span><br><span class="line">  <span class="keyword">let</span> pre = <span class="literal">null</span>;</span><br><span class="line">  <span class="keyword">let</span> current = head;</span><br><span class="line">  <span class="keyword">let</span> next;</span><br><span class="line">  <span class="comment">// 判断当前节点是否为空</span></span><br><span class="line">  <span class="comment">// 不为空就先获取当前节点的下一节点</span></span><br><span class="line">  <span class="comment">// 然后把当前节点的next设为上一个节点</span></span><br><span class="line">  <span class="comment">// 然后把current设为下一个节点，pre设为当前节点</span></span><br><span class="line">  <span class="keyword">while</span>(current) &#123;</span><br><span class="line">    next = current.next;</span><br><span class="line">    current.next = pre;</span><br><span class="line">    pre = current;</span><br><span class="line">    current = next;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> pre;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;排序&quot;&gt;&lt;a href=&quot;#排序&quot; class=&quot;headerlink&quot; title=&quot;排序&quot;&gt;&lt;/a&gt;排序&lt;/h1&gt;&lt;p&gt;排序算法是计算机中比较常用的算法，这边整理了如下几种排序算法：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;冒泡排序&lt;/li&gt;
&lt;li&gt;插入排序&lt;/li&gt;
&lt;li&gt;选择排序&lt;/li&gt;
&lt;li&gt;归并排序&lt;/li&gt;
&lt;li&gt;快排&lt;/li&gt;
&lt;li&gt;堆排序&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;以下两个函数是排序中会用到的通用函数&lt;/p&gt;
    
    </summary>
    
      <category term="学习笔记" scheme="http://1eeing.github.io/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="学习笔记" scheme="http://1eeing.github.io/tags/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
      <category term="基础知识" scheme="http://1eeing.github.io/tags/%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"/>
    
      <category term="计算机通识" scheme="http://1eeing.github.io/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E9%80%9A%E8%AF%86/"/>
    
      <category term="算法" scheme="http://1eeing.github.io/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="排序" scheme="http://1eeing.github.io/tags/%E6%8E%92%E5%BA%8F/"/>
    
      <category term="链表" scheme="http://1eeing.github.io/tags/%E9%93%BE%E8%A1%A8/"/>
    
  </entry>
  
  <entry>
    <title>【算法篇】时间复杂度与位运算</title>
    <link href="http://1eeing.github.io/2018/08/18/%E6%97%B6%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6%E4%B8%8E%E4%BD%8D%E8%BF%90%E7%AE%97/"/>
    <id>http://1eeing.github.io/2018/08/18/时间复杂度与位运算/</id>
    <published>2018-08-18T14:03:51.907Z</published>
    <updated>2018-08-18T14:05:28.071Z</updated>
    
    <content type="html"><![CDATA[<h1 id="时间复杂度"><a href="#时间复杂度" class="headerlink" title="时间复杂度"></a>时间复杂度</h1><p>通常使用最差的时间复杂度来衡量一个算法的好坏。</p><p>常数时间O(1)代表这个操作和数据量没关系，是一个固定时间的操作，比如说四则运算。</p><p>对于一个算法来说，可能会计算出如下操作次数 <code>aN + 1</code>，<code>N</code> 代表数据量。那么该算法的时间复杂度就是O(N)。因为我们在计算时间复杂度的时候，数据量通常是非常大的，这时候低阶项和常数项可以忽略不计。</p><a id="more"></a><p>当然可能会出现两个算法都是O(N)的时间复杂度，那么对比两个算法的好坏就要通过对比低阶项和常数项了。</p><hr><h1 id="位运算"><a href="#位运算" class="headerlink" title="位运算"></a>位运算</h1><p>位运算在算法中很有用，速度可以比四则运算快很多。</p><p>在学习位运算之前应该知道十进制如何转二进制，二进制如何转十进制。这里说明下简单的计算方式：</p><ul><li>十进制 <code>33</code> 可以看成是 <code>32 + 1</code> ，并且 <code>33</code> 应该是六位二进制的，因为 <code>33</code> 近似 <code>32</code>，而 <code>32</code> 是2的五次方，所以是六位，那么十进制 <code>33</code> 就是 <code>100001</code> ，只要是2的此房，那么就是1，否则都为0</li><li>二进制 <code>100001</code> 同理，首位是2^5，末位是2^0，相加得出 <code>33</code></li></ul><h2 id="左移-lt-lt"><a href="#左移-lt-lt" class="headerlink" title="左移 &lt;&lt;"></a>左移 &lt;&lt;</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">10</span> &lt;&lt; <span class="number">1</span> <span class="comment">// -&gt; 20</span></span><br></pre></td></tr></table></figure><p>左移就是将二进制全部往左移动，10在二进制中表示为1010，左移一位后变为10100，转变为10进制也就是20，所以基本可以把左移堪称是 <code>a * (2 ^ b)</code></p><h2 id="右移-gt-gt"><a href="#右移-gt-gt" class="headerlink" title="右移 &gt;&gt;"></a>右移 &gt;&gt;</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">10</span> &gt;&gt; <span class="number">1</span> <span class="comment">// -&gt; 5</span></span><br></pre></td></tr></table></figure><p>右移就是将二进制全部往右移动并去除多余的右边，所以右移等于 <code>a / (2 ^ b)</code></p><blockquote><p>右移很好用，比如可以用在二分算法取中间值</p></blockquote><h2 id="按位操作"><a href="#按位操作" class="headerlink" title="按位操作"></a>按位操作</h2><h3 id="按位与-amp"><a href="#按位与-amp" class="headerlink" title="按位与 &amp;"></a>按位与 &amp;</h3><p>每一位都为1，结果才为1<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">8</span> &amp; <span class="number">7</span></span><br><span class="line"><span class="comment">// 1000 &amp; 0111 -&gt; 0000 -&gt; 0</span></span><br></pre></td></tr></table></figure></p><h3 id="按位或"><a href="#按位或" class="headerlink" title="按位或 |"></a>按位或 |</h3><p>其中一位为1，结果就是1<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">8</span> | <span class="number">7</span></span><br><span class="line"><span class="comment">// 1000 | 0111 -&gt; 1111 -&gt; 15</span></span><br></pre></td></tr></table></figure></p><h3 id="按位异或"><a href="#按位异或" class="headerlink" title="按位异或 ^"></a>按位异或 ^</h3><p>每一位都不同，结果才为1<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">8</span> ^ <span class="number">7</span></span><br><span class="line"><span class="comment">// 1000 ^ 0111 -&gt; 1111 -&gt; 15</span></span><br><span class="line"></span><br><span class="line"><span class="number">8</span> ^ <span class="number">8</span></span><br><span class="line"><span class="comment">// 1000 ^ 1000 -&gt; 0000 -&gt; 0</span></span><br></pre></td></tr></table></figure></p><p>从以上代码中可以发现按位异或就是不进位加法</p><h3 id="两个数不使用四则运算得出和"><a href="#两个数不使用四则运算得出和" class="headerlink" title="两个数不使用四则运算得出和"></a>两个数不使用四则运算得出和</h3><p>这道题中可以按位异或，因为按位异或就是不进位加法， <code>8 ^ 8 = 0</code>，如果进位了，就是16了，所以我们只需要将两个数进行异或操作，然后进位。那么也就是说两个二进制都是1的位置，左边应该有一个进位1，所以可以得出以下公式 <code>a + b = (a ^ b) + ((a &amp; b) &lt;&lt; 1)</code> ，然后通过迭代的方式模拟加法。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">sum</span>(<span class="params">a, b</span>)</span>&#123;</span><br><span class="line">  <span class="keyword">if</span>(a == <span class="number">0</span>) <span class="keyword">return</span> b</span><br><span class="line">  <span class="keyword">if</span>(b == <span class="number">0</span>) <span class="keyword">return</span> a</span><br><span class="line">  <span class="keyword">let</span> newA = a ^ b;</span><br><span class="line">  <span class="keyword">let</span> newB = (a &amp; b) &lt;&lt; <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">return</span> sum(newA, newB);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;时间复杂度&quot;&gt;&lt;a href=&quot;#时间复杂度&quot; class=&quot;headerlink&quot; title=&quot;时间复杂度&quot;&gt;&lt;/a&gt;时间复杂度&lt;/h1&gt;&lt;p&gt;通常使用最差的时间复杂度来衡量一个算法的好坏。&lt;/p&gt;
&lt;p&gt;常数时间O(1)代表这个操作和数据量没关系，是一个固定时间的操作，比如说四则运算。&lt;/p&gt;
&lt;p&gt;对于一个算法来说，可能会计算出如下操作次数 &lt;code&gt;aN + 1&lt;/code&gt;，&lt;code&gt;N&lt;/code&gt; 代表数据量。那么该算法的时间复杂度就是O(N)。因为我们在计算时间复杂度的时候，数据量通常是非常大的，这时候低阶项和常数项可以忽略不计。&lt;/p&gt;
    
    </summary>
    
      <category term="学习笔记" scheme="http://1eeing.github.io/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="学习笔记" scheme="http://1eeing.github.io/tags/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
      <category term="基础知识" scheme="http://1eeing.github.io/tags/%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"/>
    
      <category term="计算机通识" scheme="http://1eeing.github.io/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E9%80%9A%E8%AF%86/"/>
    
      <category term="算法" scheme="http://1eeing.github.io/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="时间复杂度" scheme="http://1eeing.github.io/tags/%E6%97%B6%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6/"/>
    
      <category term="位运算" scheme="http://1eeing.github.io/tags/%E4%BD%8D%E8%BF%90%E7%AE%97/"/>
    
  </entry>
  
  <entry>
    <title>从iframe高度自适应了解postMessage</title>
    <link href="http://1eeing.github.io/2018/08/12/postMessage/"/>
    <id>http://1eeing.github.io/2018/08/12/postMessage/</id>
    <published>2018-08-12T12:33:35.772Z</published>
    <updated>2018-12-08T15:33:24.977Z</updated>
    
    <content type="html"><![CDATA[<h3 id="背景："><a href="#背景：" class="headerlink" title="背景："></a>背景：</h3><blockquote><p>iframe在我们的项目里用的比较多，也是为了复用一些代码，在这样的情况下，iframe的高度自然而然就成了一个大问题，不合适的iframe高度会使页面出现2个及以上的滚动条，这对用户体验及美观（前端的强迫症）来说都是比较痛苦的。因此我们需要让iframe的高度达到一个合适的高度，从而达到除了外部的滚动条外，不产生多余的其他滚动条。</p></blockquote><a id="more"></a><h2 id="如何用postMessage来实现？"><a href="#如何用postMessage来实现？" class="headerlink" title="如何用postMessage来实现？"></a>如何用postMessage来实现？</h2><blockquote><p>postMessage的实现类似sub、pub，首先需要在父页面绑定一个接收事件，接收来自子页面的message事件，一般会用origin来判断是否来自期望的子页面。</p></blockquote><h3 id="父页面接收消息"><a href="#父页面接收消息" class="headerlink" title="父页面接收消息"></a>父页面接收消息</h3><p>父页面伪代码如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">window.addEventListener(&apos;message&apos;, function(e)&#123;</span><br><span class="line">  /*</span><br><span class="line">   *  e里面会有一些参数，我们用到以下两个</span><br><span class="line">   *  e.origin 来源</span><br><span class="line">   *  e.data 参数</span><br><span class="line">   */</span><br><span class="line"></span><br><span class="line">  //判断origin是否来自xxx，是则将data传递过去</span><br><span class="line">  if(e.origin == &apos;xxx&apos;)&#123;</span><br><span class="line">      callback(e.data);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">function callback(data) &#123;</span><br><span class="line">  //判断事件名，执行相应的操作</span><br><span class="line">  if(data.eventName == &apos;changeHeight&apos;)&#123;</span><br><span class="line">      changeHeight(data.height);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function changeHeight(height) &#123;</span><br><span class="line">  var selector = &apos;xxx&apos;;</span><br><span class="line">  selector.height = height;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="子页面发送消息"><a href="#子页面发送消息" class="headerlink" title="子页面发送消息"></a>子页面发送消息</h3><blockquote><p>otherWindow.postMessage(data, targetOrigin, [transfer]);</p></blockquote><ol><li><p>otherWindow 其他窗口的一个引用，比如iframe的contentWindow属性、执行window.open返回的窗口对象、或者是命名过或数值索引的window.frames。</p></li><li><p>data 将要发送到其他 window的数据。它将会被结构化克隆算法序列化。这意味着你可以不受什么限制的将数据对象安全的传送给目标窗口而无需自己序列化。</p></li><li><p>targetOrigin 通过窗口的origin属性来指定哪些窗口能接收到消息事件，其值可以是字符串”“（表示无限制）或者一个URI。在发送消息的时候，如果目标窗口的协议、主机地址或端口这三者的任意一项不匹配targetOrigin提供的值，那么消息就不会被发送；只有三者完全匹配，消息才会被发送。这个机制用来控制消息可以发送到哪些窗口；例如，当用postMessage传送密码时，这个参数就显得尤为重要，必须保证它的值与这条包含密码的信息的预期接受者的orign属性完全一致，来防止密码被恶意的第三方截获。如果你明确的知道消息应该发送到哪个窗口，那么请始终提供一个有确切值的targetOrigin，而不是。不提供确切的目标将导致数据泄露到任何对数据感兴趣的恶意站点。</p></li><li><p>transfer 是一串和message 同时传递的 Transferable 对象. 这些对象的所有权将被转移给消息的接收方，而发送一方将不再保有所有权。</p></li></ol><p>子页面伪代码如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">var data = &#123;</span><br><span class="line">  eventName: &apos;changeHeight&apos;,</span><br><span class="line">  height: $(&apos;body&apos;).height()</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">var targetOrigin = &apos;https://www.sb.com&apos;;</span><br><span class="line">window.postMessage(data, targetOrigin);</span><br></pre></td></tr></table></figure><p>以上，我们就完成了使用postMessage来改变父页面的高度。</p><h2 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h2><ul><li><p>使用message来接收消息时，为了安全起见，请对origin进行判断，防止不期望的页面发起攻击</p></li><li><p>使用message来发送事件时，请明确targetOrigin，防止第三方截获你发送的数据</p></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;背景：&quot;&gt;&lt;a href=&quot;#背景：&quot; class=&quot;headerlink&quot; title=&quot;背景：&quot;&gt;&lt;/a&gt;背景：&lt;/h3&gt;&lt;blockquote&gt;
&lt;p&gt;iframe在我们的项目里用的比较多，也是为了复用一些代码，在这样的情况下，iframe的高度自然而然就成了一个大问题，不合适的iframe高度会使页面出现2个及以上的滚动条，这对用户体验及美观（前端的强迫症）来说都是比较痛苦的。因此我们需要让iframe的高度达到一个合适的高度，从而达到除了外部的滚动条外，不产生多余的其他滚动条。&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="个人原创" scheme="http://1eeing.github.io/categories/%E4%B8%AA%E4%BA%BA%E5%8E%9F%E5%88%9B/"/>
    
    
      <category term="基础知识" scheme="http://1eeing.github.io/tags/%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"/>
    
      <category term="计算机通识" scheme="http://1eeing.github.io/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E9%80%9A%E8%AF%86/"/>
    
      <category term="postMessage" scheme="http://1eeing.github.io/tags/postMessage/"/>
    
      <category term="massageChannel" scheme="http://1eeing.github.io/tags/massageChannel/"/>
    
      <category term="个人原创" scheme="http://1eeing.github.io/tags/%E4%B8%AA%E4%BA%BA%E5%8E%9F%E5%88%9B/"/>
    
  </entry>
  
  <entry>
    <title>【基础篇】数据结构</title>
    <link href="http://1eeing.github.io/2018/08/11/dataMap/"/>
    <id>http://1eeing.github.io/2018/08/11/dataMap/</id>
    <published>2018-08-11T00:12:50.501Z</published>
    <updated>2018-08-11T00:16:39.233Z</updated>
    
    <content type="html"><![CDATA[<h1 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a>数据结构</h1><h2 id="栈"><a href="#栈" class="headerlink" title="栈"></a>栈</h2><h3 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h3><p>栈是一个线性结构，在计算机中是一个相当常见的数据结构。<br>栈的特点是只能在某一段添加或删除数据，遵循先进后出的原则。</p><p><img src="https://user-gold-cdn.xitu.io/2018/5/20/1637b785d2d68735?w=640&amp;h=460&amp;f=png&amp;s=6932" alt="https://user-gold-cdn.xitu.io/2018/5/20/1637b785d2d68735?w=640&amp;h=460&amp;f=png&amp;s=6932"></p><a id="more"></a><h3 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h3><p>可以把栈看成是数组的一个子集，所以可以使用数组来实现。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">Class Stack&#123;</span><br><span class="line">  <span class="keyword">constructor</span>() &#123;</span><br><span class="line">    <span class="keyword">this</span>.stack = [];</span><br><span class="line">  &#125;</span><br><span class="line">  push(item) &#123;</span><br><span class="line">    <span class="keyword">this</span>.stack.push(item);</span><br><span class="line">  &#125;</span><br><span class="line">  pop() &#123;</span><br><span class="line">    <span class="keyword">this</span>.stack.pop();</span><br><span class="line">  &#125;</span><br><span class="line">  peek() &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.stack[<span class="keyword">this</span>.getCount() - <span class="number">1</span>]</span><br><span class="line">  &#125;</span><br><span class="line">  getCount() &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.stack.length</span><br><span class="line">  &#125;</span><br><span class="line">  isEmpty() &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.getCount() === <span class="number">0</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="应用"><a href="#应用" class="headerlink" title="应用"></a>应用</h3><p>参考leetcode 序号20的题目，<a href="https://leetcode-cn.com/problems/valid-parentheses/description/" target="_blank" rel="noopener">匹配有效括号</a></p><hr><h2 id="队列"><a href="#队列" class="headerlink" title="队列"></a>队列</h2><h3 id="概念-1"><a href="#概念-1" class="headerlink" title="概念"></a>概念</h3><p>队列是一个线性结构，特点是在某一端添加数据，在另一端删除数据，遵循先进先出的原则。</p><h3 id="实现-1"><a href="#实现-1" class="headerlink" title="实现"></a>实现</h3><p><strong>单链队列</strong><br>单链队列在出队操作的时候需要 O(n) 的时间复杂度<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Queue</span></span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>() &#123;</span><br><span class="line">    <span class="keyword">this</span>.queue = [];</span><br><span class="line">  &#125;</span><br><span class="line">  enQueue(item) &#123;</span><br><span class="line">    <span class="keyword">this</span>.queue.push(item);</span><br><span class="line">  &#125;</span><br><span class="line">  deQueue() &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.queue.shift();</span><br><span class="line">  &#125;</span><br><span class="line">  getHeaer() &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.queue[<span class="number">0</span>];</span><br><span class="line">  &#125;</span><br><span class="line">  getLength() &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.queue.length;</span><br><span class="line">  &#125;</span><br><span class="line">  isEmpty() &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.getLength() === <span class="number">0</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p><strong>循环队列</strong><br>出队操作平时的时间复杂度为O(1)<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SqQueue</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>(length) &#123;</span><br><span class="line">    <span class="keyword">this</span>.queue = <span class="keyword">new</span> <span class="built_in">Array</span>(length + <span class="number">1</span>);</span><br><span class="line">    <span class="comment">//队头</span></span><br><span class="line">    <span class="keyword">this</span>.first = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">//队尾</span></span><br><span class="line">    <span class="keyword">this</span>.last = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">//当前队列大小</span></span><br><span class="line">    <span class="keyword">this</span>.size = <span class="number">0</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  enQueue(item) &#123;</span><br><span class="line">    <span class="comment">// 判断队尾 + 1是否为队头</span></span><br><span class="line">    <span class="comment">// 如果是就代表需要扩容数组</span></span><br><span class="line">    <span class="comment">// % this.queue.length 是为了防止数组越界</span></span><br><span class="line">    <span class="keyword">if</span>(<span class="keyword">this</span>.first === (<span class="keyword">this</span>.last + <span class="number">1</span>) % <span class="keyword">this</span>.queue.length) &#123;</span><br><span class="line">      <span class="keyword">this</span>.resize(<span class="keyword">this</span>.getLength() * <span class="number">2</span> + <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">this</span>.queue[<span class="keyword">this</span>.last] = item;</span><br><span class="line">    <span class="keyword">this</span>.size ++;</span><br><span class="line">    <span class="keyword">this</span>.last = (<span class="keyword">this</span>.last + <span class="number">1</span>) % <span class="keyword">this</span>.queue.length;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  deQueue() &#123;</span><br><span class="line">    <span class="keyword">if</span>(<span class="keyword">this</span>.isEmpty()) &#123;</span><br><span class="line">      <span class="keyword">throw</span> <span class="built_in">Error</span>(<span class="string">'Queue is empty'</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">let</span> r = <span class="keyword">this</span>.queue[<span class="keyword">this</span>.first];</span><br><span class="line">    <span class="keyword">this</span>.queue[<span class="keyword">this</span>.first] = <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">this</span>.first = (<span class="keyword">this</span>.first + <span class="number">1</span>) % <span class="keyword">this</span>.queue.length;</span><br><span class="line">    <span class="keyword">this</span>.size --;</span><br><span class="line">    <span class="comment">// 判断当前队列大小是否过小</span></span><br><span class="line">    <span class="comment">// 为了保证不浪费空间，在队列空间等于总长度四分之一时</span></span><br><span class="line">    <span class="comment">// 且不为2时缩小总长度为当前的一半</span></span><br><span class="line">    <span class="keyword">if</span>(<span class="keyword">this</span>.size === <span class="keyword">this</span>.getLength() / <span class="number">4</span> &amp;&amp; <span class="keyword">this</span>.getLength() !== <span class="number">2</span>)&#123;</span><br><span class="line">      <span class="keyword">this</span>.resize(<span class="keyword">this</span>.getLength() / <span class="number">2</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> r;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  getHeader() &#123;</span><br><span class="line">    <span class="keyword">if</span>(<span class="keyword">this</span>.isEmpty())&#123;</span><br><span class="line">      <span class="keyword">throw</span> <span class="built_in">Error</span>(<span class="string">'queue is empty'</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.queue[<span class="keyword">this</span>.first];</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  getLength() &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.queue.length - <span class="number">1</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  isEmpty() &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.first === <span class="keyword">this</span>.last;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  resize(length) &#123;</span><br><span class="line">    <span class="keyword">let</span> q = <span class="keyword">new</span> <span class="built_in">Array</span>(length);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; length; i++)&#123;</span><br><span class="line">      q[i] = <span class="keyword">this</span>.queue[(i + <span class="keyword">this</span>.first) % <span class="keyword">this</span>.queue.length]</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">this</span>.queue = q;</span><br><span class="line">    <span class="keyword">this</span>.first = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">this</span>.last = <span class="keyword">this</span>.size;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><hr><h2 id="链表"><a href="#链表" class="headerlink" title="链表"></a>链表</h2><h3 id="概念-2"><a href="#概念-2" class="headerlink" title="概念"></a>概念</h3><p>链表是一个线性结构，同时也是一个天然的递归结构。链表结构可以充分利用计算机内存空间，实现灵活的内存动态管理。但是链表失去了数组随机读取的优点，同时链表由于增加了节点的指针域，空间开销比较大。</p><h3 id="单向链表实现"><a href="#单向链表实现" class="headerlink" title="单向链表实现"></a>单向链表实现</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Node</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>(v, next) &#123;</span><br><span class="line">    <span class="keyword">this</span>.value = v;</span><br><span class="line">    <span class="keyword">this</span>.next = next;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">LinkList</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>() &#123;</span><br><span class="line">    <span class="comment">// 链表长度</span></span><br><span class="line">    <span class="keyword">this</span>.size = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// 虚拟头部</span></span><br><span class="line">    <span class="keyword">this</span>.dummyNode = <span class="keyword">new</span> Node(<span class="literal">null</span>, <span class="literal">null</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  find(header, index, currentIndex) &#123;</span><br><span class="line">    <span class="keyword">if</span>(index === currentIndex) <span class="keyword">return</span> header;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.find(header.next, index, currentIndex + <span class="number">1</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  addNode(v, index) &#123;</span><br><span class="line">    <span class="keyword">this</span>.checkIndex(index);</span><br><span class="line">    <span class="comment">// 当往链表末尾插入时，prev.next为空</span></span><br><span class="line">    <span class="comment">// 其他情况时，因为要插入节点，所以插入的节点</span></span><br><span class="line">    <span class="comment">// 的next 应该是 prev.next</span></span><br><span class="line">    <span class="keyword">let</span> prev = <span class="keyword">this</span>.find(<span class="keyword">this</span>.dummyNode, index, <span class="number">0</span>);</span><br><span class="line">    prev.next = <span class="keyword">new</span> Node(v, prev.next);</span><br><span class="line">    <span class="keyword">this</span>.size ++;</span><br><span class="line">    <span class="keyword">return</span> prev.next;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  insertNode(v, index) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.addNode(v, index);</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  addToFirst(v) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.addNode(v, <span class="number">0</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  addToLast(v) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.addNode(v, <span class="keyword">this</span>.size);</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  removeNode(index, isLast) &#123;</span><br><span class="line">    <span class="keyword">this</span>.checkIndex(index);</span><br><span class="line">    index = isLast ? index - <span class="number">1</span> : index;</span><br><span class="line">    <span class="keyword">let</span> prev = <span class="keyword">this</span>.find(<span class="keyword">this</span>.dummyNode, index, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">let</span> node = prev.next;</span><br><span class="line">    prev.next = node.next;</span><br><span class="line">    node.next = <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">this</span>.size --;</span><br><span class="line">    <span class="keyword">return</span> node;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  removeFirstNode() &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.removeNode(<span class="number">0</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  removeLastNode() &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.removeNode(<span class="keyword">this</span>.size, <span class="literal">true</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  checkIndex(index) &#123;</span><br><span class="line">    <span class="keyword">if</span>(index &lt; <span class="number">0</span> || index &gt; <span class="keyword">this</span>.size) <span class="keyword">throw</span> <span class="built_in">Error</span>(<span class="string">'Index Error'</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  getNode(index) &#123;</span><br><span class="line">    <span class="keyword">this</span>.checkIndex(index);</span><br><span class="line">    <span class="keyword">if</span>(<span class="keyword">this</span>.isEmpty()) <span class="keyword">return</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.find(<span class="keyword">this</span>.dummyNode, index, <span class="number">0</span>).next;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  isEmpty() &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.size === <span class="number">0</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  getSize() &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.size;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h2 id="树"><a href="#树" class="headerlink" title="树"></a>树</h2><h3 id="二叉树"><a href="#二叉树" class="headerlink" title="二叉树"></a>二叉树</h3><p>树拥有很多种结构，二叉树是树中最常用的结构，同时也是一个天然的递归结构。<br>二叉树拥有一个根节点，每个节点至多拥有两个子节点，分别为：左节点和右节点。树的最底部节点称之为叶节点，当一棵树的叶数量为满时，该树可以称之为<strong>满二叉树</strong></p><p><img src="https://user-gold-cdn.xitu.io/2018/5/22/163884f74c9f4e4d?w=320&amp;h=267&amp;f=png&amp;s=11622" alt="https://user-gold-cdn.xitu.io/2018/5/22/163884f74c9f4e4d?w=320&amp;h=267&amp;f=png&amp;s=11622"></p><h3 id="二分搜索树"><a href="#二分搜索树" class="headerlink" title="二分搜索树"></a>二分搜索树</h3><p>二分搜索树也是二叉树，拥有二叉树的特性。但是区别在于二分搜索树每个节点的值都比它的左子树的值大，比右子树的值小。</p><p>这种存储方式很适合于数据搜索。如下图，当需要查找6的时候，因为需要查找的值比根节点的值大，所以只需要在根节点的右子树上寻找，大大提高了搜索效率。</p><p><img src="https://user-gold-cdn.xitu.io/2018/5/22/1638850ba7458208?w=596&amp;h=485&amp;f=png&amp;s=36796" alt="https://user-gold-cdn.xitu.io/2018/5/22/1638850ba7458208?w=596&amp;h=485&amp;f=png&amp;s=36796"></p><p><strong><em> 实现 </em></strong><br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Node</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>(value) &#123;</span><br><span class="line">    <span class="keyword">this</span>.value = value;</span><br><span class="line">    <span class="keyword">this</span>.left = <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">this</span>.right = <span class="literal">null</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">BST</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>() &#123;</span><br><span class="line">    <span class="keyword">this</span>.root = <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">this</span>.size = <span class="number">0</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  getSize() &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.size;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  isEmpty() &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.size === <span class="number">0</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  addNode(v) &#123;</span><br><span class="line">    <span class="keyword">this</span>.root = <span class="keyword">this</span>._addChild(<span class="keyword">this</span>.root, v);</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// 添加节点时，需要比较添加的节点值和当前节点值的大小</span></span><br><span class="line">  _addChild(node, v) &#123;</span><br><span class="line">    <span class="keyword">if</span>(!node) &#123;</span><br><span class="line">      <span class="keyword">this</span>.size ++;</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">new</span> Node(v);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span>(node.value &gt; v) &#123;</span><br><span class="line">      node.left = <span class="keyword">this</span>._addChild(node.left, v);</span><br><span class="line">    &#125;<span class="keyword">else</span> <span class="keyword">if</span>(node.value &lt; v)&#123;</span><br><span class="line">      node.right = <span class="keyword">this</span>._addChild(node.right, v);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>以上是最基本的二分搜索树实现，接下来实现树的遍历。</p><p>对于树的遍历来说，有三种遍历方法，分别是</p><ul><li>先序遍历</li><li>中序遍历</li><li>后序遍历</li></ul><p>三种遍历的区别在于何时访问节点。在遍历树的过程中，每个节点都会遍历三次，分别是</p><ul><li>遍历到自己</li><li>遍历左子树</li><li>遍历右子树</li></ul><p>如果需要实现先序遍历，只需要第一次遍历到节点时进行操作即可。</p><p><strong>递归实现</strong><br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 先序遍历可用于打印树的结构</span></span><br><span class="line"><span class="comment">// 先序遍历先访问根节点，然后访问左节点，最后访问右节点。</span></span><br><span class="line">preTraversal() &#123;</span><br><span class="line">  <span class="keyword">this</span>._pre(<span class="keyword">this</span>.root);</span><br><span class="line">&#125;</span><br><span class="line">_pre(node) &#123;</span><br><span class="line">  <span class="keyword">if</span>(node) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(node.value);</span><br><span class="line">    <span class="keyword">this</span>._pre(node.left);</span><br><span class="line">    <span class="keyword">this</span>._pre(node.right);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 中序遍历可用于排序</span></span><br><span class="line"><span class="comment">// 对于BST来说，中序遍历可以实现一次遍历就得到有序的值</span></span><br><span class="line"><span class="comment">// 中序遍历表示先访问左节点，然后访问根节点，最后访问右节点。</span></span><br><span class="line">midTraversal() &#123;</span><br><span class="line">  <span class="keyword">this</span>._mid(<span class="keyword">this</span>.root);</span><br><span class="line">&#125;</span><br><span class="line">_mid(node) &#123;</span><br><span class="line">  <span class="keyword">if</span>(node)&#123;</span><br><span class="line">    <span class="keyword">this</span>._mid(node.left);</span><br><span class="line">    <span class="built_in">console</span>.log(node.value);</span><br><span class="line">    <span class="keyword">this</span>._mid(node.right);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 后序遍历可用于先操作子节点再操作父节点的场景</span></span><br><span class="line"><span class="comment">// 后序遍历表示先访问左节点，然后访问右节点，最后访问根节点。</span></span><br><span class="line">backTraversal() &#123;</span><br><span class="line">  <span class="keyword">this</span>._back(<span class="keyword">this</span>.root);</span><br><span class="line">&#125;</span><br><span class="line">_back(node) &#123;</span><br><span class="line">  <span class="keyword">if</span>(node) &#123;</span><br><span class="line">    <span class="keyword">this</span>._back(node.left);</span><br><span class="line">    <span class="keyword">this</span>._back(node.right);</span><br><span class="line">    <span class="built_in">console</span>.log(node.value);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>以上的这几种遍历都可以称之为<strong>深度遍历</strong>，对应的还有种遍历叫做<strong>广度遍历</strong>，也就是一层层地遍历树。对于广度遍历来说，我们需要利用之前讲过的队列结构来完成。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">breadthTraversal() &#123;</span><br><span class="line">  <span class="keyword">if</span>(!<span class="keyword">this</span>.root) <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">  <span class="keyword">let</span> q = <span class="keyword">new</span> Queue();</span><br><span class="line">  <span class="comment">// 将根节点入队</span></span><br><span class="line">  q.enQueue(<span class="keyword">this</span>.root);</span><br><span class="line">  <span class="comment">// 循环判断队列是否为空，为空代表树遍历完毕</span></span><br><span class="line">  <span class="keyword">while</span>(!q.isEmpty()) &#123;</span><br><span class="line">    <span class="comment">// 将队首出队，判断是否有左右子树</span></span><br><span class="line">    <span class="comment">// 有的话，就先左后右入队</span></span><br><span class="line">    <span class="keyword">let</span> n = q.deQueue();</span><br><span class="line">    <span class="built_in">console</span>.log(n.value);</span><br><span class="line">    <span class="keyword">if</span>(n.left) q.enQueue(n.left);</span><br><span class="line">    <span class="keyword">if</span>(n.right) q.enQueue(n.right);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>如何在树中寻找最小值或最大值呢？</strong><br>因为二分搜索树的特性，所以最小值一定在根节点的最左边，最大值相反<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">getMin() &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">this</span>._getMin(<span class="keyword">this</span>.root).value;</span><br><span class="line">&#125;</span><br><span class="line">_getMin(node) &#123;</span><br><span class="line">  <span class="keyword">if</span>(!node.left) <span class="keyword">return</span> node;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">this</span>._getMin(node.left);</span><br><span class="line">&#125;</span><br><span class="line">getMax() &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">this</span>._getMax(<span class="keyword">this</span>.root).value;</span><br><span class="line">&#125;</span><br><span class="line">_getMax(node) &#123;</span><br><span class="line">  <span class="keyword">if</span>(!node.right) <span class="keyword">return</span> node;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">this</span>._getMax(node.right);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p><strong>向上取整和向下取整</strong>，这两个操作是相反的，所以代码也是类似的，这里只介绍如何向下取整。既然是向下取整，那么根据二分搜索树的特性，值一定在根节点的左侧。只需要一直遍历左子树直到当前节点的值不再大于等于需要的值，然后判断节点是否还拥有右子树，如果有的话，继续递归判断</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">floor(v) &#123;</span><br><span class="line">  <span class="keyword">let</span> node = <span class="keyword">this</span>._floor(<span class="keyword">this</span>.root, v);</span><br><span class="line">  <span class="keyword">return</span> node ? node.value : <span class="literal">null</span>;</span><br><span class="line">&#125;</span><br><span class="line">_floor(node, v) &#123;</span><br><span class="line">  <span class="keyword">if</span>(!node) <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">  <span class="keyword">if</span>(node.value === v) <span class="keyword">return</span> v;</span><br><span class="line">  <span class="comment">// 如果当前节点值还比需要的值大，就继续递归</span></span><br><span class="line">  <span class="keyword">if</span>(node.value &gt; v) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>._floor(node.left, v);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 判断当前节点是否拥有右子树</span></span><br><span class="line">  <span class="keyword">let</span> right = <span class="keyword">this</span>._floor(node.right, v);</span><br><span class="line">  <span class="keyword">if</span>(right) <span class="keyword">return</span> right;</span><br><span class="line">  <span class="keyword">return</span> node;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>排名</strong>，这是用于获取给定值的排名或者排名第几的节点的值，这两个操作也是相反的，所以这个只介绍如何获取排名第几的节点的值。对于这个操作而言，我们需要略微的改造点代码，让每个节点拥有一个size属性，该属性表示该节点下有多少子节点（包括自身）</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Node</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>(value) &#123;</span><br><span class="line">    <span class="keyword">this</span>.value = value;</span><br><span class="line">    <span class="keyword">this</span>.left = <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">this</span>.right = <span class="literal">null</span>;</span><br><span class="line">    <span class="comment">// 修改代码</span></span><br><span class="line">    <span class="keyword">this</span>.size = <span class="number">1</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//新增代码</span></span><br><span class="line">_getSize(node) &#123;</span><br><span class="line">  <span class="keyword">return</span> node ? node.size : <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">_addChild(node, v) &#123;</span><br><span class="line">  <span class="keyword">if</span>(!node)&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> Node(v);</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">if</span>(node.value &gt; v) &#123;</span><br><span class="line">    <span class="comment">// 修改代码</span></span><br><span class="line">    node.size ++;</span><br><span class="line">    node.left = <span class="keyword">this</span>._addChild(node.left, v);</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span>(node.value &lt; v) &#123;</span><br><span class="line">    <span class="comment">// 修改代码</span></span><br><span class="line">    node.size ++; <span class="comment">// FIXME</span></span><br><span class="line">    node.right = <span class="keyword">this</span>._addChild(node.right, v);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> node;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">select(k) &#123;</span><br><span class="line">  <span class="keyword">let</span> node = <span class="keyword">this</span>._select(<span class="keyword">this</span>.root, k);</span><br><span class="line">  <span class="keyword">return</span> node ? node.value : <span class="literal">null</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">_select(node, k) &#123;</span><br><span class="line">  <span class="keyword">if</span>(!node) <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">  <span class="comment">// 先获取左子树下有几个节点</span></span><br><span class="line">  <span class="keyword">let</span> size = node.left ? node.left.size : <span class="number">0</span>;</span><br><span class="line">  <span class="comment">// 判断size是否大于k</span></span><br><span class="line">  <span class="comment">// 如果大于k，代表所需要的节点在左节点</span></span><br><span class="line">  <span class="keyword">if</span>(size &gt; k) <span class="keyword">return</span> <span class="keyword">this</span>._select(node.left, k);</span><br><span class="line">  <span class="comment">// 如果小于k，代表所需要的节点在右节点</span></span><br><span class="line">  <span class="comment">// 注意这里需要重新计算 k，减去根节点除了右子树的节点数量</span></span><br><span class="line">  <span class="keyword">if</span>(size &lt; k) <span class="keyword">return</span> <span class="keyword">this</span>._select(node.right, k-size<span class="number">-1</span>);</span><br><span class="line">  <span class="keyword">return</span> node;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>接下来我们看二分搜索树中最难实现的部分：<strong>删除节点</strong>。因为对于删除节点来说，会存在以下几种情况</p><ul><li>需要删除的节点没有子树</li><li>需要删除的节点只有一条子树</li><li>需要删除的节点有左右两条树</li></ul><p>对于前两种情况很好解决，但是第三种情况就有难度了，所以先来实现相对简单的操作：删除最小节点，对于删除最小节点来说，是不存在第三种情况的，删除最大节点操作是和删除最小节点相反的，所以这里也就不再赘述。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">delectMin() &#123;</span><br><span class="line">  <span class="keyword">this</span>.root = <span class="keyword">this</span>._delectMin(<span class="keyword">this</span>.root);</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="keyword">this</span>.root);</span><br><span class="line">&#125;</span><br><span class="line">_delectMin(node) &#123;</span><br><span class="line">  <span class="comment">// 一直递归左子树</span></span><br><span class="line">  <span class="comment">// 如果左子树为空，就判断节点是否拥有右子树</span></span><br><span class="line">  <span class="comment">// 有右子树的话就把需要删除的节点替换为右子树</span></span><br><span class="line">  <span class="keyword">if</span>((node != <span class="literal">null</span>) &amp; !node.left) <span class="keyword">return</span> node.right;</span><br><span class="line">  node.left = <span class="keyword">this</span>._delectMin(node.left);</span><br><span class="line">  <span class="comment">// 最后需要重新维护下节点的 size</span></span><br><span class="line">  node.size = <span class="keyword">this</span>._getSize(node.left) + <span class="keyword">this</span>._getSize(node.right) + <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">return</span> node;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>最后讲解的就是如何删除任意节点了。<br>对于这个操作，T.Hibbard在1962年提出了解决这个难题的办法，也就是如何解决第三种情况。</p><p>当遇到这种情况时，需要取出当前节点的后继节点（也就是当前节点右子树的最小节点）来替换需要删除的节点。然后将需要删除节点的左子树赋值给后继节点，右子树删除后继节点后赋值给它。</p><blockquote><p>因为二分搜索树的特性，父节点一定比所有左子节点大，比所有右子节点小。那么当需要删除父节点时，势必需要拿出一个比父节点大的节点来替换父节点。这个节点肯定不存在于左子树，必然存在于右子树。然后又需要保持父节点都是比右子节点小的，那么就可以取出右子树中最小的那个节点来替换父节点。</p></blockquote><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">delect(v) &#123;</span><br><span class="line">  <span class="keyword">this</span>.root = <span class="keyword">this</span>._delect(<span class="keyword">this</span>.root, v);</span><br><span class="line">&#125;</span><br><span class="line">_delect(node, v) &#123;</span><br><span class="line">  <span class="keyword">if</span>(!node) <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">  <span class="comment">// 寻找节点比当前节点小，去左子树找</span></span><br><span class="line">  <span class="keyword">if</span>(node.value &lt; v)&#123;</span><br><span class="line">    node.right = <span class="keyword">this</span>._delect(node.right, v);</span><br><span class="line">  &#125;<span class="keyword">else</span> <span class="keyword">if</span>(node.value &gt; v)&#123;</span><br><span class="line">    <span class="comment">// 寻找的节点比当前节点大，去右子树找</span></span><br><span class="line">    node.left = <span class="keyword">this</span>._delect(node.left, v);</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// 进入这个条件说明已经找到节点</span></span><br><span class="line">    <span class="comment">// 先判断节点是否拥有左右子树中的一个</span></span><br><span class="line">    <span class="comment">// 是的话，将子树返回出去，这里和 _delectMin 的操作一样</span></span><br><span class="line">    <span class="keyword">if</span>(!node.left) <span class="keyword">return</span> node.right;</span><br><span class="line">    <span class="keyword">if</span>(!node.right) <span class="keyword">return</span> node.left;</span><br><span class="line">    <span class="comment">// 进入这里，代表节点拥有左右子树</span></span><br><span class="line">    <span class="comment">// 先取出当前节点的后继节点，也就是取当前节点右子树的最小值</span></span><br><span class="line">    <span class="keyword">let</span> min = <span class="keyword">this</span>._getMin(node.right);</span><br><span class="line">    <span class="comment">// 取出最小值后，删除最小值</span></span><br><span class="line">    <span class="comment">// 然后把删除节点后的子树赋值给最小值节点</span></span><br><span class="line">    min.right = <span class="keyword">this</span>._delectMin(node.right);</span><br><span class="line">    <span class="comment">// 左子树不动</span></span><br><span class="line">    min.left = node.left;</span><br><span class="line">    node = min;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">//维护size</span></span><br><span class="line">  node.size = <span class="keyword">this</span>._getSize(node.left) + <span class="keyword">this</span>._getSize(node.right) + <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">return</span> node;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="AVL树"><a href="#AVL树" class="headerlink" title="AVL树"></a>AVL树</h3><p><strong><em>概念</em></strong><br>二分搜索树实际在业务中是受到限制的，因为并不是严格的O(logN)，在极端情况下会退化成链表，比如加入一组升序的数字就会造成这种情况。</p><p>AVL树改进了二分搜索树，在AVL树中任意节点的左右子树的高度差都不大于1，这样保证了时间复杂度是严格的O(logN)。基于此，对AVL树增加或删除节点时可能需要旋转树来达到高度的平衡。</p><p><strong><em>实现</em></strong><br>因为AVL树是改进了二分搜索树，所以部分代码是于二分搜索树重复的，对于重复内容不再解析。<br>对于AVL树来说，添加节点会有四种情况。</p><p><img src="https://user-gold-cdn.xitu.io/2018/6/23/1642cc145a0cfb26?w=800&amp;h=566&amp;f=png&amp;s=73573" alt="https://user-gold-cdn.xitu.io/2018/6/23/1642cc145a0cfb26?w=800&amp;h=566&amp;f=png&amp;s=73573"></p><p>对于左左情况来说，新增加的节点位于节点2的左侧，这时树已经不平衡了，需要旋转。因为搜索树的特性，节点比左节点大，比右节点小，所以旋转以后也要实现这个特性。</p><p>旋转之前：new &lt; 2 &lt; C &lt; 3 &lt; B &lt; 5 &lt; A，右旋之后节点3为根节点，这时候需要将节点3的右节点加到节点5的左边，最后还需要更新节点的高度。</p><p>对于右右情况，相反与左左，不再赘述。</p><p>对于左右情况来说，新增加的节点位于节点4的右侧。对于这种情况，需要通过两次旋转来达到目的。</p><p>首先对节点的左节点左旋，这时树满足左左的情况，再对节点进行一次右旋就可以达到目的。</p><p><strong><em>代码如下</em></strong><br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Node</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>(value) &#123;</span><br><span class="line">    <span class="keyword">this</span>.value = value;</span><br><span class="line">    <span class="keyword">this</span>.left = <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">this</span>.right = <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">this</span>.height = <span class="number">1</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">AVL</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>() &#123;</span><br><span class="line">    <span class="keyword">this</span>.root = <span class="literal">null</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  addNode(v) &#123;</span><br><span class="line">    <span class="keyword">this</span>.root = <span class="keyword">this</span>._addChild(<span class="keyword">this</span>.root, v);</span><br><span class="line">  &#125;</span><br><span class="line">  _addChild(node, v) &#123;</span><br><span class="line">    <span class="keyword">if</span>(!node) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">new</span> Node(v);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(node.value &gt; v) &#123;</span><br><span class="line">      node.left = <span class="keyword">this</span>._addChild(node.left, v);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span>(node.value &lt; v) &#123;</span><br><span class="line">      node.right = <span class="keyword">this</span>._addChild(node.right, v);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      node.value = v;</span><br><span class="line">    &#125;</span><br><span class="line">    node.height = <span class="number">1</span> + <span class="built_in">Math</span>.max(<span class="keyword">this</span>._getHeight(node.left), <span class="keyword">this</span>._getHeight(node.right));</span><br><span class="line">    <span class="keyword">let</span> factor = <span class="keyword">this</span>._getBalanceFactor(node);</span><br><span class="line">    <span class="comment">// 当需要右旋时，根节点的左树一定比右树高度高</span></span><br><span class="line">    <span class="keyword">if</span>(factor &gt; <span class="number">1</span> &amp;&amp; <span class="keyword">this</span>._getBalanceFactor(node.left) &gt;= <span class="number">0</span>)&#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">this</span>._rightRotate(node);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 当需要左旋时，根节点的左树一定比右树高度矮</span></span><br><span class="line">    <span class="keyword">if</span>(factor &lt; <span class="number">-1</span> &amp;&amp; <span class="keyword">this</span>._getBalanceFactor(node.right) &lt;= <span class="number">0</span>)&#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">this</span>._leftRotate(node);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 左右情况</span></span><br><span class="line">    <span class="comment">// 节点的左树比右树高，且节点的左树的右数比节点的左树的左数高</span></span><br><span class="line">    <span class="keyword">if</span>(factor &gt; <span class="number">1</span> &amp;&amp; <span class="keyword">this</span>._getBanlanceFactor(node.left) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">      node.left = <span class="keyword">this</span>._leftRotate(node.left);</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">this</span>._rightRotate(node);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 右左情况</span></span><br><span class="line">    <span class="comment">// 节点的左树比右树矮，且节点的右树的右数比节点的右树的左数矮</span></span><br><span class="line">    <span class="keyword">if</span>(factor &lt; <span class="number">-1</span> &amp;&amp; <span class="keyword">this</span>._getBalanceFactor(node.right) &gt; <span class="number">0</span>)&#123;</span><br><span class="line">      node.right = <span class="keyword">this</span>._rightRotate(node.right);</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">this</span>._leftRotate(node);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> node;</span><br><span class="line">  &#125;</span><br><span class="line">  _getHeight(node) &#123;</span><br><span class="line">    <span class="keyword">if</span>(!node) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">return</span> node.height;</span><br><span class="line">  &#125;</span><br><span class="line">  _getBalanceFactor(node) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>._getHeight(node.left) - <span class="keyword">this</span>._getHeight(node.right);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 节点右旋</span></span><br><span class="line">  _rightRotate(node) &#123;</span><br><span class="line">    <span class="comment">// 旋转后新根节点</span></span><br><span class="line">    <span class="keyword">let</span> newRoot = node.left;</span><br><span class="line">    <span class="comment">// 需要移动的节点</span></span><br><span class="line">    <span class="keyword">let</span> moveNode = newRoot.right;</span><br><span class="line">    <span class="comment">// 节点2的右节点改为节点5</span></span><br><span class="line">    newRoot.right = node;</span><br><span class="line">    <span class="comment">// 节点5的左节点改为节点3</span></span><br><span class="line">    node.left = moveNode;</span><br><span class="line">    <span class="comment">// 更新树的高度</span></span><br><span class="line">    node.height = <span class="number">1</span> + <span class="built_in">Math</span>.max(<span class="keyword">this</span>._getHeight(node.left), <span class="keyword">this</span>._getHeight(node.right));</span><br><span class="line">    newRoot.height = <span class="number">1</span> + <span class="built_in">Math</span>.max(<span class="keyword">this</span>._getHeight(newRoot.left), <span class="keyword">this</span>._getHeight(newRoot.right));</span><br><span class="line">    <span class="keyword">return</span> newRoot;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 节点左旋</span></span><br><span class="line">  _leftRotate(node) &#123;</span><br><span class="line">    <span class="comment">// 旋转后新根节点</span></span><br><span class="line">    <span class="keyword">let</span> newRoot = node.right;</span><br><span class="line">    <span class="comment">// 需要移动的节点</span></span><br><span class="line">    <span class="keyword">let</span> moveNode = newRoot.left;</span><br><span class="line">    <span class="comment">// 节点6的左节点改为节点4</span></span><br><span class="line">    newRoot.left = node;</span><br><span class="line">    <span class="comment">// 节点4的右节点改为节点5</span></span><br><span class="line">    node.right = moveNode;</span><br><span class="line">    <span class="comment">// 更新树的高度</span></span><br><span class="line">    node.height = <span class="number">1</span> + <span class="built_in">Math</span>.max(<span class="keyword">this</span>._getHeight(node.left), <span class="keyword">this</span>._getHeight(node.right));</span><br><span class="line">    newRoot.height = <span class="number">1</span> + <span class="built_in">Math</span>.max(<span class="keyword">this</span>._getHeight(newRoot.left), <span class="keyword">this</span>._getHeight(newRoot.right));</span><br><span class="line">    <span class="keyword">return</span> newRoot;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><hr><h2 id="Trie"><a href="#Trie" class="headerlink" title="Trie"></a>Trie</h2><h3 id="概念-3"><a href="#概念-3" class="headerlink" title="概念"></a>概念</h3><p>在计算机科学，trie又称前缀树或字典树，是一种有序树，用于保存关联数组，其中的键通常是字符串。</p><p>简单点来说，这个结构的作用大多是为了方便搜索字符串，该树有以下几个特点</p><ul><li>根节点代表空字符串，每个节点都有N（加入搜索英文字符，就有26条）条连接，每条链接代表一个字符</li><li>节点不存储字符，只有路径才存储，这点和其他的树结构不同</li><li>从根节点开始到任意一个节点，将沿途经过的字符连接起来就是该节点对应的字符串。</li></ul><p><img src="https://user-gold-cdn.xitu.io/2018/6/9/163e1d2f6cec3348?w=640&amp;h=600&amp;f=png&amp;s=48344" alt="https://user-gold-cdn.xitu.io/2018/6/9/163e1d2f6cec3348?w=640&amp;h=600&amp;f=png&amp;s=48344"></p><h3 id="实现-2"><a href="#实现-2" class="headerlink" title="实现"></a>实现</h3><p>总得来说Trie的实现相比别的树结构来说简单的多，实现就以搜索英文字符为例<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TrieNode</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>() &#123;</span><br><span class="line">    <span class="comment">// 代表每个字符经过节点的次数</span></span><br><span class="line">    <span class="keyword">this</span>.path = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// 代表到该节点的字符串有几个</span></span><br><span class="line">    <span class="keyword">this</span>.end = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// 链接</span></span><br><span class="line">    <span class="keyword">this</span>.next = <span class="keyword">new</span> <span class="built_in">Array</span>(<span class="number">26</span>).fill(<span class="literal">null</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Trie</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>() &#123;</span><br><span class="line">    <span class="comment">// 根节点，代表空字符</span></span><br><span class="line">    <span class="keyword">this</span>.root = <span class="keyword">new</span> TrieNode();</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 插入字符串</span></span><br><span class="line">  insert(str) &#123;</span><br><span class="line">    <span class="keyword">if</span>(!str) <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">let</span> node = <span class="keyword">this</span>.root;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; str.length; i++) &#123;</span><br><span class="line">      <span class="comment">// 获得字符先对应的索引</span></span><br><span class="line">      <span class="keyword">let</span> index = str[i].charCodeAt() - <span class="string">'a'</span>.charCodeAt();</span><br><span class="line">      <span class="comment">// 如果索引对应没有值，就创建</span></span><br><span class="line">      <span class="keyword">if</span>(!node.next[index]) &#123;</span><br><span class="line">        node.next[index] = <span class="keyword">new</span> TrieNode();</span><br><span class="line">      &#125;</span><br><span class="line">      node.path += <span class="number">1</span>;</span><br><span class="line">      node = node.next[index];</span><br><span class="line">    &#125;</span><br><span class="line">    node.end += <span class="number">1</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 搜索字符串出现的次数</span></span><br><span class="line">  search(str) &#123;</span><br><span class="line">    <span class="keyword">if</span>(!str) <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">let</span> node = <span class="keyword">this</span>.root;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; str.length; i++)&#123;</span><br><span class="line">      <span class="keyword">let</span> index = str[i].charCodeAt() - <span class="string">'a'</span>.charCodeAt();</span><br><span class="line">      <span class="comment">// 如果索引对应没有值，代表没有需要搜索的字符串</span></span><br><span class="line">      <span class="keyword">if</span>(!node.next[index]) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      node = node.next[index];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> node.end;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 删除字符串</span></span><br><span class="line">  <span class="keyword">delete</span>(str) &#123;</span><br><span class="line">    <span class="keyword">if</span>(!<span class="keyword">this</span>.search(str)) <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">let</span> node = <span class="keyword">this</span>.root;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; str.length; i++)&#123;</span><br><span class="line">      <span class="keyword">let</span> index = str[i].charCodeAt() - <span class="string">'a'</span>.charCodeAt();</span><br><span class="line">      <span class="comment">// 如果索引对应的节点的Path为0，代表经过该节点的字符串</span></span><br><span class="line">      <span class="comment">// 已经一个，直接删除即可</span></span><br><span class="line">      <span class="keyword">if</span>(--node.next[index].path == <span class="number">0</span>)&#123;</span><br><span class="line">        node.next[index] = <span class="literal">null</span>;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      node = node.next[index];</span><br><span class="line">    &#125;</span><br><span class="line">    node.end -= <span class="number">1</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><hr><h2 id="并查集"><a href="#并查集" class="headerlink" title="并查集"></a>并查集</h2><h3 id="概念-4"><a href="#概念-4" class="headerlink" title="概念"></a>概念</h3><p>并查集是一种特殊的树结构，用于处理一些不交集的合并及查询问题。该结构中每个节点都有一个父节点，如果只有当前一个节点，那么该节点的父节点指向自己。</p><p>这个结构中有两个重要的操作，分别是</p><ul><li>Find：确定元素属于哪一个子集。它可以被用来确定两个元素是否属于同一子集。</li><li>Union：将两个子集合并成同一个集合。</li></ul><h3 id="实现-3"><a href="#实现-3" class="headerlink" title="实现"></a>实现</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">DisjointSet</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>(count) &#123;</span><br><span class="line">    <span class="comment">// 初始化时，每个节点的父节点都是自己</span></span><br><span class="line">    <span class="keyword">this</span>.parent = <span class="keyword">new</span> <span class="built_in">Array</span>(count);</span><br><span class="line">    <span class="comment">// 用于记录树的深度，优化搜索复杂度</span></span><br><span class="line">    <span class="keyword">this</span>.rank = <span class="keyword">new</span> <span class="built_in">Array</span>(count);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; count; i++)&#123;</span><br><span class="line">      <span class="keyword">this</span>.parent[i] = i;</span><br><span class="line">      <span class="keyword">this</span>.rank[i] = <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  find(p) &#123;</span><br><span class="line">    <span class="comment">// 寻找当前节点的父节点是否为自己，不是的话表示还没找到</span></span><br><span class="line">    <span class="comment">// 开始进行路径压缩优化</span></span><br><span class="line">    <span class="comment">// 假设当前节点父节点为A</span></span><br><span class="line">    <span class="comment">// 将当前节点挂载到A节点的父节点上，达到压缩深度的目的</span></span><br><span class="line">    <span class="keyword">while</span>(p != <span class="keyword">this</span>.parent[p]) &#123;</span><br><span class="line">      <span class="keyword">this</span>.parent[p] = <span class="keyword">this</span>.parent[<span class="keyword">this</span>.parent[p]];</span><br><span class="line">      p = <span class="keyword">this</span>.parent[p];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> p;</span><br><span class="line">  &#125;</span><br><span class="line">  isConnected(p, q) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.find(p) === <span class="keyword">this</span>.find(q);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 合并</span></span><br><span class="line">  union(p, q) &#123;</span><br><span class="line">    <span class="comment">// 找到两个数字的父节点</span></span><br><span class="line">    <span class="keyword">let</span> i = <span class="keyword">this</span>.find(p);</span><br><span class="line">    <span class="keyword">let</span> j = <span class="keyword">this</span>.find(q);</span><br><span class="line">    <span class="keyword">if</span>(i === j) <span class="keyword">return</span>;</span><br><span class="line">    <span class="comment">// 判断两棵树的深度，深度小的加到深度大的树下面</span></span><br><span class="line">    <span class="comment">// 如果两棵树深度相等，那就无所谓怎么加</span></span><br><span class="line">    <span class="keyword">if</span>(<span class="keyword">this</span>.rank[i] &lt; <span class="keyword">this</span>.rank[j]) &#123;</span><br><span class="line">      <span class="keyword">this</span>.parent[i] = j;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="keyword">this</span>.rank[i] &gt; <span class="keyword">this</span>.rank[j]) &#123;</span><br><span class="line">      <span class="keyword">this</span>.parent[j] = i;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="keyword">this</span>.parent[i] = j;</span><br><span class="line">      <span class="keyword">this</span>.rank[j] ++;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h2 id="堆"><a href="#堆" class="headerlink" title="堆"></a>堆</h2><h3 id="概念-5"><a href="#概念-5" class="headerlink" title="概念"></a>概念</h3><p>堆通常是一个可以被看做一棵树的数组对象。<br>堆的实现通过构造二叉堆，实为二叉树的一种。这种数据结构具有以下性质。</p><ul><li>任意节点小于（或大于）它的所有子节点</li><li>堆总是一棵完全树。即除了最底层，其他层的节点都被元素填满，且最底层从左到右填入。</li></ul><p>将根节点最大的堆叫做<strong>最大堆</strong>或<strong>大根堆</strong>，根节点最小的堆叫做<strong>最小堆</strong>或<strong>小根堆</strong>。<br>优先队列也完全可以用堆来实现，操作是一模一样的。</p><h3 id="实现大根堆"><a href="#实现大根堆" class="headerlink" title="实现大根堆"></a>实现大根堆</h3><p>堆的每个节点的左边子节点索引是 <code>i * 2 + 1</code> ，右边是 <code>i * 2 + 2</code> ，父节点是 <code>(i - 1) / 2</code> 。<br>堆有两个核心的操作，分别是 <code>shiftUp</code> 和 <code>shiftDown</code> 。前者用于添加元素，后者用于删除根节点。</p><p><code>shiftUp</code> 的核心思路是一路将节点与父节点对比大小，如果比父节点大，就和父节点交换位置。</p><p><code>shiftDown</code> 的核心思路是先将根节点和末尾交换位置，然后移除末尾元素。接下来循环判断父节点和两个子节点的大小，如果子节点大，就把最大的子节点和父节点交换。</p><p><img src="https://user-gold-cdn.xitu.io/2018/6/15/164009e58a5a21f8?w=537&amp;h=394&amp;f=png&amp;s=77222" alt="https://user-gold-cdn.xitu.io/2018/6/15/164009e58a5a21f8?w=537&amp;h=394&amp;f=png&amp;s=77222"></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MaxHeap</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>() &#123;</span><br><span class="line">    <span class="keyword">this</span>.heap = [];</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  size() &#123;</span><br><span class="line">    reurn <span class="keyword">this</span>.heap.length;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  empty() &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.size() == <span class="number">0</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  add(item) &#123;</span><br><span class="line">    <span class="keyword">this</span>.heap.push(item);</span><br><span class="line">    <span class="keyword">this</span>._shiftUp(<span class="keyword">this</span>.size() - <span class="number">1</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  removeMax() &#123;</span><br><span class="line">    <span class="keyword">this</span>._shiftDown(<span class="number">0</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  getParentIndex(k) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">parseInt</span>((k - <span class="number">1</span>) / <span class="number">2</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  getLeftIndex(k) &#123;</span><br><span class="line">    <span class="keyword">return</span> k * <span class="number">2</span> + <span class="number">1</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  _shiftUp(k) &#123;</span><br><span class="line">    <span class="comment">//如果当前节点比父节点大，就交换</span></span><br><span class="line">    <span class="keyword">while</span>(<span class="keyword">this</span>.heap[k] &gt; <span class="keyword">this</span>.heap[<span class="keyword">this</span>.getParentIndex(k)]) &#123;</span><br><span class="line">      <span class="keyword">this</span>._swap(k, <span class="keyword">this</span>.getParentIndex(k))</span><br><span class="line">      <span class="comment">//将索引变成父节点</span></span><br><span class="line">      k = <span class="keyword">this</span>.getParentIndex(k);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  _shiftDown(k) &#123;</span><br><span class="line">    <span class="comment">//交换首位并删除末尾</span></span><br><span class="line">    <span class="keyword">this</span>._swap(k, <span class="keyword">this</span>.size() - <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">this</span>.heap.splice(<span class="keyword">this</span>.size() - <span class="number">1</span>, <span class="number">1</span>);</span><br><span class="line">    <span class="comment">// 判断节点是否有左孩子，因为二叉堆的特性，有右必有左</span></span><br><span class="line">    <span class="keyword">while</span>(<span class="keyword">this</span>.getLeftIndex(k) &lt; <span class="keyword">this</span>.size())&#123;</span><br><span class="line">      left j = <span class="keyword">this</span>.getLeftIndex(k);</span><br><span class="line">      <span class="comment">// 判断是否有右孩子，并且右孩子是否大于左孩子</span></span><br><span class="line">      <span class="keyword">if</span>(j + <span class="number">1</span> &lt; <span class="keyword">this</span>.size() &amp;&amp; <span class="keyword">this</span>.heap[j + <span class="number">1</span>] &gt; <span class="keyword">this</span>.heap[j]) j++</span><br><span class="line">      <span class="comment">// 判断父节点是否已经比子节点都大</span></span><br><span class="line">      <span class="keyword">if</span>(<span class="keyword">this</span>.heap[k] &gt;= <span class="keyword">this</span>.heap[j] ) <span class="keyword">break</span></span><br><span class="line">      <span class="keyword">this</span>._swap(k, j);</span><br><span class="line">      k = j;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  _swap(left, right) &#123;</span><br><span class="line">    <span class="keyword">let</span> rightValue = <span class="keyword">this</span>.heap[right];</span><br><span class="line">    <span class="keyword">this</span>.heap[right] = <span class="keyword">this</span>.heap[left];</span><br><span class="line">    <span class="keyword">this</span>.heap[left] = rightValue;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;数据结构&quot;&gt;&lt;a href=&quot;#数据结构&quot; class=&quot;headerlink&quot; title=&quot;数据结构&quot;&gt;&lt;/a&gt;数据结构&lt;/h1&gt;&lt;h2 id=&quot;栈&quot;&gt;&lt;a href=&quot;#栈&quot; class=&quot;headerlink&quot; title=&quot;栈&quot;&gt;&lt;/a&gt;栈&lt;/h2&gt;&lt;h3 id=&quot;概念&quot;&gt;&lt;a href=&quot;#概念&quot; class=&quot;headerlink&quot; title=&quot;概念&quot;&gt;&lt;/a&gt;概念&lt;/h3&gt;&lt;p&gt;栈是一个线性结构，在计算机中是一个相当常见的数据结构。&lt;br&gt;栈的特点是只能在某一段添加或删除数据，遵循先进后出的原则。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://user-gold-cdn.xitu.io/2018/5/20/1637b785d2d68735?w=640&amp;amp;h=460&amp;amp;f=png&amp;amp;s=6932&quot; alt=&quot;https://user-gold-cdn.xitu.io/2018/5/20/1637b785d2d68735?w=640&amp;amp;h=460&amp;amp;f=png&amp;amp;s=6932&quot;&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="学习笔记" scheme="http://1eeing.github.io/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="学习笔记" scheme="http://1eeing.github.io/tags/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
      <category term="基础知识" scheme="http://1eeing.github.io/tags/%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"/>
    
      <category term="计算机通识" scheme="http://1eeing.github.io/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E9%80%9A%E8%AF%86/"/>
    
      <category term="数据结构" scheme="http://1eeing.github.io/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
  </entry>
  
  <entry>
    <title>【网络篇】Http、Https、Http 2.0 及 DNS</title>
    <link href="http://1eeing.github.io/2018/08/07/HTTP/"/>
    <id>http://1eeing.github.io/2018/08/07/HTTP/</id>
    <published>2018-08-07T10:22:08.000Z</published>
    <updated>2018-08-07T10:22:08.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="HTTP"><a href="#HTTP" class="headerlink" title="HTTP"></a>HTTP</h1><p>HTTP协议是个无状态协议，不会保存状态。</p><h2 id="POST和GET的区别"><a href="#POST和GET的区别" class="headerlink" title="POST和GET的区别"></a>POST和GET的区别</h2><p>先引入副作用和幂等的概念。<br>副作用指对服务器上的资源做改变，搜索是无副作用的，注册是副作用的。</p><p>幂等指发送M和N次请求（两者不同且都大于1），服务器上资源的状态一致，比如注册10个和11个账号是不幂等的，对文章进行更改10次和11次是幂等的。</p><p>在规范的应用场景上说，GET多用于无副作用、幂等的场景，例如搜索关键字。POST多用于副作用、不幂等的场景，例如注册。</p><p>在技术上说：</p><ul><li>GET请求能缓存，POST不能</li><li>POST相对GET安全一点点，因为GET请求都包含在URL里，且会被浏览器保存历史记录，POST不会，但是在抓包的情况下都是一样的。</li><li>POST可以通过request body来传输比GET更多的数据，GET没有这个技术</li><li>URL有长度限制，会影响GET请求，但是这个长度限制是浏览器规定的，不是RFC规定的</li><li>POST支持更多编码类型且不对数据类型限制</li></ul><a id="more"></a><h2 id="常见状态码"><a href="#常见状态码" class="headerlink" title="常见状态码"></a>常见状态码</h2><h3 id="2XX-成功"><a href="#2XX-成功" class="headerlink" title="2XX 成功"></a>2XX 成功</h3><ul><li>200 OK，表示从客户端发来的请求在服务器端被正确处理</li><li>204 No content，表示请求成功，但响应报文不含实体的主体部分</li><li>205 Reset Content，表示请求成功，但响应报文不含实体的主体部分，但是与204不同自傲与要求请求方重置内容</li><li>206 Partial Content，进行范围请求</li></ul><h3 id="3XX-重定向"><a href="#3XX-重定向" class="headerlink" title="3XX 重定向"></a>3XX 重定向</h3><ul><li>301 moved permanently，永久性重定向，表示资源已被分配了新的URL</li><li>302 found，临时性重定向，表示资源临时被分配了新的URL</li><li>303 see other，表示资源存在着另一个URL，应使用GET方法定向获取资源</li><li>304 not modified，表示服务器允许访问资源，但因发生请求未满足条件的情况</li><li>307 temporary redirect，临时重定向，同302</li></ul><h3 id="4XX-客户端错误"><a href="#4XX-客户端错误" class="headerlink" title="4XX 客户端错误"></a>4XX 客户端错误</h3><ul><li>400 bad request，请求报文存在语法错误</li><li>401 unauthorized，表示发送的请求需要有通过HTTP认证的认证信息</li><li>403 forbidden，表示对请求资源的访问被服务器拒绝</li><li>404 not found，表示在服务器上没有找到请求的资源</li></ul><h3 id="5XX-服务器错误"><a href="#5XX-服务器错误" class="headerlink" title="5XX 服务器错误"></a>5XX 服务器错误</h3><ul><li>500 internal server error，表示服务器端在执行请求时发生了错误</li><li>501 Not Implemented，表示服务器不支持当前请求所需要的某个功能</li><li>503 service unavailable，表示服务器暂时处于超负载或正在停机维护，无法处理请求</li></ul><h2 id="HTTP首部"><a href="#HTTP首部" class="headerlink" title="HTTP首部"></a>HTTP首部</h2><table><thead><tr><th>通用字段</th><th style="text-align:center">作用</th></tr></thead><tbody><tr><td>Cache-Control</td><td style="text-align:center">控制缓存的行为</td></tr><tr><td>Connection</td><td style="text-align:center">浏览器想要优先使用的链接类型，比如keep-alive</td></tr><tr><td>Date</td><td style="text-align:center">创建报文时间</td></tr><tr><td>Pragma</td><td style="text-align:center">报文指令</td></tr><tr><td>Via</td><td style="text-align:center">代理服务器相关信息</td></tr><tr><td>Transfer-Encoding</td><td style="text-align:center">传输编码方式</td></tr><tr><td>Upgrade</td><td style="text-align:center">要求客户端升级协议</td></tr><tr><td>Warning</td><td style="text-align:center">在内容中可能存在错误</td></tr></tbody></table><table><thead><tr><th>请求字段</th><th style="text-align:center">作用</th></tr></thead><tbody><tr><td>Accept</td><td style="text-align:center">能正确接收的媒体类型</td></tr><tr><td>Accept-Charset</td><td style="text-align:center">能正确接收的字符集</td></tr><tr><td>Accept-Encoding</td><td style="text-align:center">能正确接收的编码格式列表</td></tr><tr><td>Accept-Language</td><td style="text-align:center">能正确接收的语言列表</td></tr><tr><td>Expect</td><td style="text-align:center">期待服务端的指定行为</td></tr><tr><td>From</td><td style="text-align:center">请求方邮箱地址</td></tr><tr><td>Host</td><td style="text-align:center">服务器的域名</td></tr><tr><td>if-Match</td><td style="text-align:center">两端资源标记比较</td></tr><tr><td>if-Modified-Since</td><td style="text-align:center">本地资源未修改返回304（比较时间）</td></tr><tr><td>if-None-Match</td><td style="text-align:center">本地资源未修改返回304（比较标记）</td></tr><tr><td>User-Agent</td><td style="text-align:center">客户端信息</td></tr><tr><td>Max-Forwards</td><td style="text-align:center">限制可被代理及王网关转发的次数</td></tr><tr><td>Proxy-Authorization</td><td style="text-align:center">向代理服务器发送验证信息</td></tr><tr><td>Range</td><td style="text-align:center">请求某个内容的一部分</td></tr><tr><td>Referer</td><td style="text-align:center">表示浏览器所访问的前一个页面</td></tr><tr><td>TE</td><td style="text-align:center">传输编码方式</td></tr></tbody></table><table><thead><tr><th>响应字段</th><th style="text-align:center">作用</th></tr></thead><tbody><tr><td>Accept-Ranges</td><td style="text-align:center">是否支持某些种类的范围</td></tr><tr><td>Age</td><td style="text-align:center">资源在代理缓存中存在的时间</td></tr><tr><td>ETag</td><td style="text-align:center">资源标识</td></tr><tr><td>Location</td><td style="text-align:center">客户端重定向到某个URL</td></tr><tr><td>Proxy-Authenticate</td><td style="text-align:center">向代理服务器发送验证信息</td></tr><tr><td>Server</td><td style="text-align:center">服务器名字</td></tr><tr><td>WWW-Authenticate</td><td style="text-align:center">获取资源需要的验证信息</td></tr></tbody></table><table><thead><tr><th>实体字段</th><th style="text-align:center">作用</th></tr></thead><tbody><tr><td>Allow</td><td style="text-align:center">资源的正确请求方式</td></tr><tr><td>Content-Encoding</td><td style="text-align:center">内容的编码格式</td></tr><tr><td>Content-Language</td><td style="text-align:center">内容使用的语言</td></tr><tr><td>Content-Length</td><td style="text-align:center">request body 长度</td></tr><tr><td>Content-Location</td><td style="text-align:center">返回数据的备用地址</td></tr><tr><td>Content-MD5</td><td style="text-align:center">Base64加密格式的内容 MD5校验值</td></tr><tr><td>Content-Range</td><td style="text-align:center">内容的位置范围</td></tr><tr><td>Content-Type</td><td style="text-align:center">内容的媒体类型</td></tr><tr><td>Expires</td><td style="text-align:center">内容的过期时间</td></tr><tr><td>Last_modified</td><td style="text-align:center">内容的最后修改时间</td></tr></tbody></table><hr><h1 id="HTTPS"><a href="#HTTPS" class="headerlink" title="HTTPS"></a>HTTPS</h1><p>HTTPS还是通过了HTTP来传输信息，但是信息通过TLS协议进行了加密。</p><h2 id="TLS"><a href="#TLS" class="headerlink" title="TLS"></a>TLS</h2><p>TLS协议位于传输层智商，应用层之下。首次进行TLS协议传输需要两个RTT，接下来可以通过Session Resumption 减少到一个RTT。</p><p>在TLS中使用了两种加密技术，分别为：对称加密和非对称加密。</p><h3 id="对称加密"><a href="#对称加密" class="headerlink" title="对称加密"></a>对称加密</h3><p>对称加密就是两边拥有相同的秘钥，两边都知道如何将密文加密解密。</p><h3 id="非对称加密"><a href="#非对称加密" class="headerlink" title="非对称加密"></a>非对称加密</h3><p>有公钥私钥之分，公钥所有人都可以知道，可以将数据用公钥加密，但是将数据解密必须使用私钥解密，私钥只有分发公钥的一方才知道。</p><p>TSL握手过程如下：<br><img src="https://user-gold-cdn.xitu.io/2018/5/12/1635260126b3a10c?w=1558&amp;h=1006&amp;f=webp&amp;s=59424" alt="https://user-gold-cdn.xitu.io/2018/5/12/1635260126b3a10c?w=1558&amp;h=1006&amp;f=webp&amp;s=59424"></p><ol><li>客户端发送一个随机值，需要的协议和加密方式</li><li>服务端收到客户端的随机值，自己也产生一个随机值，并根据客户端需求的协议和加密方式来使用对应的方式，发送自己的证书（如果需要验证客户端证书需要说明）</li><li>客户端收到服务端的证书并验证是否有效，验证通过会再生成一个随机值，通过服务端证书的公钥去加密这个随机值并发送给服务端，如果服务端需要验证客户端证书的话会附带证书</li><li>服务端收到加密过的随机值并使用私钥解密获得第三个随机值，这时候两端都拥有了三个随机值，可以通过这三个随机值按照之前约定的加密方式生成密钥，接下来的通信就可以通过该密钥来加密解密。</li></ol><p>通过以上步骤可知，在TLS握手阶段，两端使用非对称加密的方式来通信，但是因为非对称加密损耗的性能比对称加密大，所以在正式传输数据时，两端使用对称加密的方式通信。</p><blockquote><p>以上说明的都是TLS 1.2协议的握手情况，在1.3协议中，首次建立连接只需要一个RTT，后面恢复连接不需要RTT了。</p></blockquote><hr><h1 id="HTTP-2-0"><a href="#HTTP-2-0" class="headerlink" title="HTTP 2.0"></a>HTTP 2.0</h1><p>HTTP 2.0相比于HTTP 1.X，可以说是大幅度提高了web的性能。</p><p>在HTTP 1.X中，为了性能考虑，我们会引入雪碧图、将小图内联、使用多个域名等等的方式。这一切都是因为浏览器限制了同一个域名下的请求数量，当页面中需要请求很多资源的时候，队头阻塞（Head of line blocking）会导致在达到最大请求数量时，剩余的资源需要等待其他资源请求完成后才能发起请求。</p><p>在HTTP 1.X中，因为队头阻塞的原因，你会发现请求是这样的<br><img src="https://user-gold-cdn.xitu.io/2018/5/12/163542c96df8563d?w=518&amp;h=642&amp;f=png&amp;s=72417" alt="https://user-gold-cdn.xitu.io/2018/5/12/163542c96df8563d?w=518&amp;h=642&amp;f=png&amp;s=72417"></p><p>在HTTP 2.0中，因为引入了多路复用，你会发现请求是这样的<br><img src="https://user-gold-cdn.xitu.io/2018/5/12/163542c9d3128c7a?w=900&amp;h=616&amp;f=png&amp;s=71014" alt="https://user-gold-cdn.xitu.io/2018/5/12/163542c9d3128c7a?w=900&amp;h=616&amp;f=png&amp;s=71014"></p><h2 id="二进制传输"><a href="#二进制传输" class="headerlink" title="二进制传输"></a>二进制传输</h2><p>HTTP 2.0中所有加强性能的核心点在于此。在之前的HTTP版本中，我们是通过文本的方式传输数据。<br>在HTTP 2.0中引入了新的编码机制，所有传输的数据都会被分割，并采用二进制格式编码。</p><p><img src="https://user-gold-cdn.xitu.io/2018/5/12/163543c25e5e9f23?w=874&amp;h=459&amp;f=png&amp;s=26320" alt="https://user-gold-cdn.xitu.io/2018/5/12/163543c25e5e9f23?w=874&amp;h=459&amp;f=png&amp;s=26320"></p><h2 id="多路复用"><a href="#多路复用" class="headerlink" title="多路复用"></a>多路复用</h2><p>在 HTTP 2.0 中，有两个非常重要的概念，分别是帧(frame)和流(stream)。<br>帧代表着最小的数据单位，每个帧会表示出该帧属于哪个流，流也就是多个帧组成的数据流。</p><p>多路复用，就是在一个TCP连接中可以存在多条流。换句话说，也就是可以发送多个请求，对端可以通过帧中的标识知道属于哪个请求。通过这个技术，可以避免 HTTP 旧版本中的队头阻塞问题，极大的提高传输性能。</p><h2 id="Header压缩"><a href="#Header压缩" class="headerlink" title="Header压缩"></a>Header压缩</h2><p>在 HTTP 1.X 中，我们使用文本的形式传输header，在header携带cookie的情况下，可能每次都需要重复传输几百到几千的字节。</p><p>在 HTTP 2.0 中，使用了HPACK压缩格式对传输的header进行编码，减少了header的大小。并在两端维护了索引表，用于记录出现过的header，后面再传输过程中就可以传输已经记录过的header的键名，对端收到数据后就可以通过键名找到对应的值。</p><h2 id="服务端Push"><a href="#服务端Push" class="headerlink" title="服务端Push"></a>服务端Push</h2><p>在 HTTP 2.0 中，服务端可以在客户端某个请求后，主动推送其他资源。</p><p>可以想象以下情况：<br>某些资源客户端是一定会请求的，这时就可以采取服务端push的技术，提前给客户端推送必要的资源，这样就可以相对减少一点延迟时间。当然在浏览器兼容的情况下你也可以使用prefetch。</p><h2 id="QUIC"><a href="#QUIC" class="headerlink" title="QUIC"></a>QUIC</h2><p>这是一个谷歌出品的基于UDP实现的同为传输层的协议，目标很远大，希望替代TCP协议。</p><ul><li>该协议支持多路复用，虽然 HTTP 2.0 也支持多路复用，但是下层仍是TCP，因为TCP的重传机制，只要一个包丢失就得判断丢失包并且重传，导致发生队头阻塞的问题，但是UDP没有这个机制。</li><li>实现了自己的加密协议，通过类似TCP的TFO机制可以实现O-RTT，当然TLS 1.3已经实现了O-RTT了</li><li>支持重传和纠错机制（向前恢复），在只丢失一个包的情况下不需要重传，使用纠错机制恢复丢失的包<ul><li>纠错机制：通过异或的方式，算出发出去的数据的异或值并单独发出一个包，服务端在发现有一个包丢失的情况下，通过其他数据包和异或值包算出丢失包</li><li>在丢失两个包或以上的情况就使用重传机制，因为算不出来了。</li></ul></li></ul><hr><h1 id="DNS"><a href="#DNS" class="headerlink" title="DNS"></a>DNS</h1><p>DNS的作用就是通过域名查询到具体的IP。</p><p>因为IP存在数字和英文的组合（IPv6），很不利于人类记忆，所以就出现了域名。你可以把域名看成是某个IP的别名，DNS就是去查询这个别名的真正名称是什么。</p><p>在TCP握手之前就已经进行了DNS查询，这个查询是操作系统自己做的。当你在浏览器中想访问<code>www.leeing.site</code>时，会进行以下操作：</p><ol><li>操作系统会首先在本地缓存中查询</li><li>没有的话会去系统配置的DNS服务器中查询</li><li>如果这时候还没得话，会直接去DNS根服务器查询，这一步查询会找出负责<code>site</code>这个一级域名的服务器</li><li>然后去该服务器查询<code>leeing</code>这个二级域名</li><li>接下来三级域名的查询其实是我们配置的，你可以给<code>www</code>这个域名配置一个IP，然后还可以给别的三级域名配置一个IP</li></ol><p>以上介绍的是DNS迭代查询，还有种是递归查询，区别就是前者是由客户端去做请求，后者是由系统配置的DNS服务器做请求，得到结果后将数据返回给客户端。</p><blockquote><p>PS：DNS是基于UDP做的查询</p></blockquote><hr><h1 id="从输入URL到页面加载完成的过程？"><a href="#从输入URL到页面加载完成的过程？" class="headerlink" title="从输入URL到页面加载完成的过程？"></a>从输入URL到页面加载完成的过程？</h1><ol><li>首先做DNS查询，如果这一步做了只能DNS解析的话，会提供访问速度最快的IP地址回来</li><li>接下来是TCP握手，应用层会下发数据给传输层，这里TCP协议会指明两端的端口号，然后下发给网络层。网络层中的IP协议会确定IP地址，并且指示了数据传输中如何跳转路由器。然后包会再被封装到数据链路层的数据帧结构中，最后就是物理层面的传输了</li><li>TCP握手结束后会进行TLS握手，然后就开始正式的传输数据</li><li>数据在进入服务端之前，可能还会先经过负载均衡的服务器，它的作用就是将请求合理的分发到多台服务器上，这时假设服务端会响应一个HTML文件</li><li>首先浏览器会判断状态码是什么，如果是200那就继续解析，如果是400或500的话就会报错，如果300的话会进行重定向，这里会有个重定向计数器，避免过多次的重定向，超过次数也会报错。</li><li>浏览器开始解析文件，如果是gzip格式的话会先解压一下，然后通过文件的编码格式知道该如何去解码文件。</li><li>文件解码成功后会正式开始渲染流程，先会根据HTML构建DOM树，有CSS的话会去构建CSSOM树。如果遇到<code>script</code>标签的话，会判断是否存在 <code>async</code> 或者 <code>defer</code> ，前者会并行进行下载并执行JS，后者会先下载文件，然后等待HTML解析完成后顺序执行，如果以上都没有，就会阻塞住渲染刘恒直到JS执行完毕。遇到文件下载的会去下载文件，这里如果使用HTTP 2.0协议的话会极大的提高多图的下载效率。</li><li>初始的HTML被完全加载和解析后会触发<code>DOMContentLoaded</code>事件</li><li>CSSOM树和DOM树构建完成后会开始生成Render树，这一步就是确定页面元素的布局、样式等等诸多方面的东西</li><li>在生成Render树的过程中，浏览器就开始调用GPU绘制，合成图层，将内容显示在屏幕上了。</li></ol>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;HTTP&quot;&gt;&lt;a href=&quot;#HTTP&quot; class=&quot;headerlink&quot; title=&quot;HTTP&quot;&gt;&lt;/a&gt;HTTP&lt;/h1&gt;&lt;p&gt;HTTP协议是个无状态协议，不会保存状态。&lt;/p&gt;
&lt;h2 id=&quot;POST和GET的区别&quot;&gt;&lt;a href=&quot;#POST和GET的区别&quot; class=&quot;headerlink&quot; title=&quot;POST和GET的区别&quot;&gt;&lt;/a&gt;POST和GET的区别&lt;/h2&gt;&lt;p&gt;先引入副作用和幂等的概念。&lt;br&gt;副作用指对服务器上的资源做改变，搜索是无副作用的，注册是副作用的。&lt;/p&gt;
&lt;p&gt;幂等指发送M和N次请求（两者不同且都大于1），服务器上资源的状态一致，比如注册10个和11个账号是不幂等的，对文章进行更改10次和11次是幂等的。&lt;/p&gt;
&lt;p&gt;在规范的应用场景上说，GET多用于无副作用、幂等的场景，例如搜索关键字。POST多用于副作用、不幂等的场景，例如注册。&lt;/p&gt;
&lt;p&gt;在技术上说：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;GET请求能缓存，POST不能&lt;/li&gt;
&lt;li&gt;POST相对GET安全一点点，因为GET请求都包含在URL里，且会被浏览器保存历史记录，POST不会，但是在抓包的情况下都是一样的。&lt;/li&gt;
&lt;li&gt;POST可以通过request body来传输比GET更多的数据，GET没有这个技术&lt;/li&gt;
&lt;li&gt;URL有长度限制，会影响GET请求，但是这个长度限制是浏览器规定的，不是RFC规定的&lt;/li&gt;
&lt;li&gt;POST支持更多编码类型且不对数据类型限制&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
      <category term="学习笔记" scheme="http://1eeing.github.io/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="学习笔记" scheme="http://1eeing.github.io/tags/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
      <category term="基础知识" scheme="http://1eeing.github.io/tags/%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"/>
    
      <category term="计算机通识" scheme="http://1eeing.github.io/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E9%80%9A%E8%AF%86/"/>
    
      <category term="网络" scheme="http://1eeing.github.io/tags/%E7%BD%91%E7%BB%9C/"/>
    
      <category term="HTTP" scheme="http://1eeing.github.io/tags/HTTP/"/>
    
      <category term="HTTPS" scheme="http://1eeing.github.io/tags/HTTPS/"/>
    
      <category term="HTTP 2.0" scheme="http://1eeing.github.io/tags/HTTP-2-0/"/>
    
      <category term="DNS" scheme="http://1eeing.github.io/tags/DNS/"/>
    
  </entry>
  
  <entry>
    <title>【浏览器篇】浏览器中的Event Loop</title>
    <link href="http://1eeing.github.io/2018/08/07/eventLoop/"/>
    <id>http://1eeing.github.io/2018/08/07/eventLoop/</id>
    <published>2018-08-07T10:14:56.000Z</published>
    <updated>2018-08-07T10:14:56.000Z</updated>
    
    <content type="html"><![CDATA[<p>在讲Event loop之前，我们先思考一个问题</p><h2 id="js为什么是单线程？"><a href="#js为什么是单线程？" class="headerlink" title="js为什么是单线程？"></a>js为什么是单线程？</h2><p>原因可能是如果js是多线程，在多个线程中处理DOM就可能会发生问题（一个线程添加新节点，另一个线程中删除节点），当然可以引入读写锁解决这个问题</p><p>好了，接下来我们开始讲Event loop</p><blockquote><p>简单的说，就是js在执行的过程中会产生执行环境，这些执行环境会被顺序的加入到执行栈中。如果遇到异步的代码，会被挂起并加入到Task（有多种Task）队列中。一旦执行栈为空，Event Loop就会从Task队列中拿出需要执行的代码并放入执行栈中执行，所以本质上来说，js中的异步行为还是同步的。</p></blockquote><a id="more"></a><p>我们看下以下代码，以下代码输出’1’, ‘3’, ‘2’<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(<span class="string">'1'</span>);</span><br><span class="line">setTimeout(<span class="function"><span class="params">()</span>=&gt;</span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'2'</span>);</span><br><span class="line">&#125;, <span class="number">0</span>);</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'3'</span>);</span><br><span class="line"><span class="comment">//'1'</span></span><br><span class="line"><span class="comment">//'3'</span></span><br><span class="line"><span class="comment">//'2'</span></span><br></pre></td></tr></table></figure></p><p>之前对setTimeout理解有偏差，虽然设置了为0，其实还是异步，是因为html5标准规定这个函数的第二个参数不得小于4ms，不足会自动增加。</p><h2 id="Task队列分为两种"><a href="#Task队列分为两种" class="headerlink" title="Task队列分为两种"></a>Task队列分为两种</h2><ul><li><p>微任务microtask，es6中称为jobs。以下这些行为属于微任务</p><ul><li>process.nextTick</li><li>promise</li><li>Object.observe</li><li>MutationObserver</li></ul></li><li><p>宏任务macrotask，es6中称为task。以下这些行为属于宏任务</p><ul><li>script</li><li>setTimeout</li><li>setInterval</li><li>setImmediate</li><li>I/O</li><li>UI rendering</li></ul></li></ul><blockquote><p>误区：很多人认为微任务快于宏任务，其实是错误的。因为宏任务汇中包括了script，浏览器会先执行一个宏任务，接下来有异步代码的话就先执行微任务。</p></blockquote><p>正确的一次Event loop顺序应该是这样的：</p><ol><li>执行同步代码（这属于宏任务）</li><li>执行栈为空，查询是否有微任务需要执行</li><li>执行所有微任务</li><li>必要的话渲染UI</li><li>开始下一轮Event loop，执行宏任务中的异步代码</li></ol><p>通过上述的Event loop顺序可知，如果宏任务中的异步代码有大量的计算并且需要操作DOM的话，为了更快的界面响应，我们可以把操作DOM放入微任务中。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;在讲Event loop之前，我们先思考一个问题&lt;/p&gt;
&lt;h2 id=&quot;js为什么是单线程？&quot;&gt;&lt;a href=&quot;#js为什么是单线程？&quot; class=&quot;headerlink&quot; title=&quot;js为什么是单线程？&quot;&gt;&lt;/a&gt;js为什么是单线程？&lt;/h2&gt;&lt;p&gt;原因可能是如果js是多线程，在多个线程中处理DOM就可能会发生问题（一个线程添加新节点，另一个线程中删除节点），当然可以引入读写锁解决这个问题&lt;/p&gt;
&lt;p&gt;好了，接下来我们开始讲Event loop&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;简单的说，就是js在执行的过程中会产生执行环境，这些执行环境会被顺序的加入到执行栈中。如果遇到异步的代码，会被挂起并加入到Task（有多种Task）队列中。一旦执行栈为空，Event Loop就会从Task队列中拿出需要执行的代码并放入执行栈中执行，所以本质上来说，js中的异步行为还是同步的。&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="学习笔记" scheme="http://1eeing.github.io/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="学习笔记" scheme="http://1eeing.github.io/tags/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
      <category term="基础知识" scheme="http://1eeing.github.io/tags/%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"/>
    
      <category term="计算机通识" scheme="http://1eeing.github.io/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E9%80%9A%E8%AF%86/"/>
    
      <category term="浏览器" scheme="http://1eeing.github.io/tags/%E6%B5%8F%E8%A7%88%E5%99%A8/"/>
    
      <category term="Event loop" scheme="http://1eeing.github.io/tags/Event-loop/"/>
    
  </entry>
  
  <entry>
    <title>【React篇】分析diff算法</title>
    <link href="http://1eeing.github.io/2018/08/07/ReactDiff/"/>
    <id>http://1eeing.github.io/2018/08/07/ReactDiff/</id>
    <published>2018-08-07T10:14:33.000Z</published>
    <updated>2018-08-07T10:14:33.000Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>diff算法大家都耳熟能详，React中最值得称道的部分莫过于Virtual DOM与diff的完美结合，特别是其高效的diff算法，可以让用户无需顾忌性能问题而“任性自由”地刷新页面。因为diff会帮助我们计算出Virtual DOM中真正变化的部分，并只针对该部分进行原生DOM操作，而非重新渲染整个页面，从而保证了每次操作更新后页面的高效渲染。</p></blockquote><h1 id="传统的diff算法"><a href="#传统的diff算法" class="headerlink" title="传统的diff算法"></a>传统的diff算法</h1><p>diff算法，即微分算法。计算一颗树形结构转换成另一颗树形结构的最少操作，是一个复杂且值得研究的问题。传统diff算法通过循环递归对节点进行依次对比，效率低下，算法复杂度达到O(n^3)，其中n是树中节点的总数。这意味着如果要展示1000个节点，就要依次执行上十亿次的比较。这种指数型的性能消耗对于前端渲染场景来说太可怕了！</p><h1 id="react中的diff算法"><a href="#react中的diff算法" class="headerlink" title="react中的diff算法"></a>react中的diff算法</h1><h3 id="diff策略"><a href="#diff策略" class="headerlink" title="diff策略"></a>diff策略</h3><p>首先，我们需要知道react的diff算法有3个策略</p><ol><li>WebUI中DOM节点跨层级的移动操作特别少，可以忽略不计</li><li>拥有相同类的两个组件将会生成相似的树形结构，拥有不同类的两个组件将会生成不同的属性结构</li><li>对于同一层级的一组子节点，它们可以通过唯一id进行区分</li></ol><a id="more"></a><h3 id="tree-diff"><a href="#tree-diff" class="headerlink" title="tree diff"></a>tree diff</h3><p>基于策略一，React对树的算法进行了简洁明了的优化，即对树进行分层比较，两棵树只会对同一层级进行比较。当发现节点不存在时，测该节点及其子节点会全部被删掉，不会进行进一步的比较。</p><blockquote><p>如果出现了节点跨层级的移动，diff会有怎样的表现呢？</p></blockquote><p>假设有A、B两个父节点，a、b两个子节点，形如A-&gt;a,B-&gt;b，当a从A之下移动到A、B平级时，当A发现a不在了，则会删除a及a的子节点，当A、B这一层级发现多出了a时，则会创建一个a。</p><h4 id="这是一种影响react性能的操作，因此官方建议不要进行dom节点跨层级的操作。"><a href="#这是一种影响react性能的操作，因此官方建议不要进行dom节点跨层级的操作。" class="headerlink" title="这是一种影响react性能的操作，因此官方建议不要进行dom节点跨层级的操作。"></a>这是一种影响react性能的操作，因此官方建议不要进行dom节点跨层级的操作。</h4><h3 id="component-diff"><a href="#component-diff" class="headerlink" title="component diff"></a>component diff</h3><p>react是基于组件构建应用的，对于组件间的比较所采取的策略也是非常简洁、高效的。</p><ol><li>如果是同一类型的组件，按照原策略继续比较Virtual Dom树即可</li><li>如果不是，则将该组件判断为dirty component，从而替换整个组件下的所有子节点。</li><li>对于同一类型的组件，有可能其Virtual Dom没有任何变化，如果能够确切的知道这点，那么就可以节省大量的diff运算时间。因此react提供shouldComponentUpdate()来判断该组件是否需要进行diff算法分析。</li></ol><blockquote><p>这里存在一个问题，如果有一个组件D，下面有E、F两个子节点，当D变为G时，虽然子节点依然是E、F，但react会认为它是不同类型的组件，会直接删除D，重新创建G，尽管D和G结构相似。这时虽然diff会影响性能，但正如diff策略二所言：不同类型的组件很少存在相似dom树的情况，因此这种极端因素很难在实际开发过程中造成重大的影响。</p></blockquote><h3 id="element-diff"><a href="#element-diff" class="headerlink" title="element diff"></a>element diff</h3><p>当节点处于同一层级时，diff提供了3种节点操作。</p><ul><li>增 INSERT_MARKUP</li><li>删 REMOVE_NODE</li><li>移 MOVE_EXISTING</li></ul><p>增和删比较好理解，这里不再赘述了，这里主要讲一下“移”。<br>按照diff策略三，我们在同一层级的节点上加入了唯一id，以下简称key。</p><ul><li>当没有添加key时，移是比较蛋疼的，假设有一组旧节点A、B、C、D和一组新节点B、A、D、C，此时diff发现 B!=A，则创建并插入B至新集合，删除旧集合A，以此类推，创建并插入A、D、C，删除B、C、D。这怎么玩？</li><li>当有了key之后，那就愉快多了。依然是上述的两组新旧节点，此时diff通过key发现新旧集合中的节点都是相同的节点，因此无需进行节点删除和创建，只需要将旧集合中节点的位置进行移动即可。</li></ul><h4 id="那么具体是怎么移动的呢？"><a href="#那么具体是怎么移动的呢？" class="headerlink" title="那么具体是怎么移动的呢？"></a>那么具体是怎么移动的呢？</h4><p>依然是上述的A、B、C、D和B、A、D、C。首先对新集合中的节点进行遍历，通过key判断新旧集合中是否存在相同的节点，如果存在，则移动。但在移动之前需要将当前节点在旧集合中的位置oldIndex与lastIndex进行比较，如果lastIndex &gt; oldIndex，则进行移动。</p><p>以A为例，在新集合中，发现A的lastIndex = 1，旧集合中oldIndex = 0，此时lastIndex &gt; oldIndex，则将A进行移动，并将lastIndex更新为新集合中A的位置。A.oldIndex此时为1。进入下一个节点的判断……</p><h3 id="react中diff的不足与待优化的点？"><a href="#react中diff的不足与待优化的点？" class="headerlink" title="react中diff的不足与待优化的点？"></a>react中diff的不足与待优化的点？</h3><p>如果A、B、C、D更新为D、A、B、C，理论上只要移动D即可，然而由于D在就集合中的位置是最大的，导致实际是A、B、C移动到D之后。因此建议在开发过程中，尽量减少类似将最后一个节点移动到列表首部的操作，当节点数量过大或更新操作过于频繁时，这在一定程度上会影响react的渲染性能。</p>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;diff算法大家都耳熟能详，React中最值得称道的部分莫过于Virtual DOM与diff的完美结合，特别是其高效的diff算法，可以让用户无需顾忌性能问题而“任性自由”地刷新页面。因为diff会帮助我们计算出Virtual DOM中真正变化的部分，并只针对该部分进行原生DOM操作，而非重新渲染整个页面，从而保证了每次操作更新后页面的高效渲染。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h1 id=&quot;传统的diff算法&quot;&gt;&lt;a href=&quot;#传统的diff算法&quot; class=&quot;headerlink&quot; title=&quot;传统的diff算法&quot;&gt;&lt;/a&gt;传统的diff算法&lt;/h1&gt;&lt;p&gt;diff算法，即微分算法。计算一颗树形结构转换成另一颗树形结构的最少操作，是一个复杂且值得研究的问题。传统diff算法通过循环递归对节点进行依次对比，效率低下，算法复杂度达到O(n^3)，其中n是树中节点的总数。这意味着如果要展示1000个节点，就要依次执行上十亿次的比较。这种指数型的性能消耗对于前端渲染场景来说太可怕了！&lt;/p&gt;
&lt;h1 id=&quot;react中的diff算法&quot;&gt;&lt;a href=&quot;#react中的diff算法&quot; class=&quot;headerlink&quot; title=&quot;react中的diff算法&quot;&gt;&lt;/a&gt;react中的diff算法&lt;/h1&gt;&lt;h3 id=&quot;diff策略&quot;&gt;&lt;a href=&quot;#diff策略&quot; class=&quot;headerlink&quot; title=&quot;diff策略&quot;&gt;&lt;/a&gt;diff策略&lt;/h3&gt;&lt;p&gt;首先，我们需要知道react的diff算法有3个策略&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;WebUI中DOM节点跨层级的移动操作特别少，可以忽略不计&lt;/li&gt;
&lt;li&gt;拥有相同类的两个组件将会生成相似的树形结构，拥有不同类的两个组件将会生成不同的属性结构&lt;/li&gt;
&lt;li&gt;对于同一层级的一组子节点，它们可以通过唯一id进行区分&lt;/li&gt;
&lt;/ol&gt;
    
    </summary>
    
      <category term="学习笔记" scheme="http://1eeing.github.io/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="React" scheme="http://1eeing.github.io/tags/React/"/>
    
      <category term="diff算法" scheme="http://1eeing.github.io/tags/diff%E7%AE%97%E6%B3%95/"/>
    
      <category term="学习笔记" scheme="http://1eeing.github.io/tags/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>【网络篇】UDP 和 TCP</title>
    <link href="http://1eeing.github.io/2018/08/07/UDP/"/>
    <id>http://1eeing.github.io/2018/08/07/UDP/</id>
    <published>2018-08-07T05:55:12.000Z</published>
    <updated>2018-08-07T10:17:20.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="UDP"><a href="#UDP" class="headerlink" title="UDP"></a>UDP</h1><h2 id="面向报文"><a href="#面向报文" class="headerlink" title="面向报文"></a>面向报文</h2><p>UDP是一个面向报文（报文可以理解为一段段的数据）的协议。意思就是UDP只是报文的搬运工，不会对报文进行任何拆分和拼接操作。</p><p>具体来说</p><ul><li>在发送端，应用层将数据传递给传输层的UDP协议，UDP只会给数据增加一个UDP头标识下是UDP协议，然后就传递给网络层了</li><li>在接收端，网络层将数据传递给传输层，UDP只去除IP报文头就传递给应用层，不会任何拼接操作</li></ul><h2 id="不可靠性"><a href="#不可靠性" class="headerlink" title="不可靠性"></a>不可靠性</h2><ol><li>UDP是无连接的，也就是说通信不需要建立和断开。</li><li>UDP是不可靠的，协议收到什么数据就传递什么数据，并且也不会备份数据，对方能不能收到也不关心。</li><li>UDP没有拥塞控制，一直会以恒定的速度发送数据。即使网络条件不好，也不会对发送速率进行调整。<ul><li>弊端：在网络条件不好的情况下会导致丢包</li><li>优点：在某些实时性要求高的场景（比如电话会议），就需要使用UDP而不是TCP</li></ul></li></ol><a id="more"></a><h2 id="高效"><a href="#高效" class="headerlink" title="高效"></a>高效</h2><p>因为UDP没有TCP那么复杂，需要保证数据不丢失且有序到达，所以UDP的头部开销小，只有八字节，相比TCP的至少二十字节要少得多，在传输数据报文时是很高效的。</p><p>头部包含了以下数据</p><ul><li>两个十六位的端口号，分别为源端口（可选字段）和目标端口</li><li>整个数据报文的长度</li><li>整个数据报文的校验和（IPv4可选字段），该字段用于发现头部信息和数据中的错误</li></ul><h2 id="传输方式"><a href="#传输方式" class="headerlink" title="传输方式"></a>传输方式</h2><p>UDP不止支持一对一的传输方式，同样支持一对多，多对多，多对一的方式，也就是说UDP提供了单播、多播、广播的功能。</p><h1 id="TCP"><a href="#TCP" class="headerlink" title="TCP"></a>TCP</h1><h2 id="头部"><a href="#头部" class="headerlink" title="头部"></a>头部</h2><p>TCP头部比UDP复杂的多，对于TCP头部来说，以下几个字段是很重要的</p><ul><li>Sequence number，这个序号保证了TCP传输的报文都是有序的，对端可以通过序号的顺序拼接报文。</li><li>Acknowledgement Number，这个序号表示数据接收端期望接收的下一个字节的编号是多少，同时也表示上一个序号的数据已经收到</li><li>Window Size，窗口大小，表示还能接收多少字节的数据，用于流量控制</li><li>标识符<ul><li>URG=1：该字段为一表示本数据报的数据部分包含紧急信息，是一个高优先级数据报文，此时紧急指针有效。紧急数据一定位于当前数据包数据部分的最前面，紧急指针表明了紧急数据的尾部。</li><li>ACK=1：该字段为一表示确认号字段有效。此外，TCP还规定在连接建立后传送的所有报文段都必须把ACK置为一。</li><li>PSH=1：该字段为一表示接收端应该立即将数据push给应用层，而不是等到缓冲区满后再提交。</li><li>RST=1：该字段为一表示当前TCP连接出现严重问题，可能需要重新建立TCP连接，也可以用于拒绝非法的报文段和拒绝连接请求。</li><li>SYN=1：当SYN=1，ACK=0时，表示当前报文段是一个连接请求报文。当SYN=1，ACK=1时，表示当前报文段是一个同意建立连接的应答报文。</li><li>FIN=1：该字段为一表示此报文段是一个释放连接的请求报文。</li></ul></li></ul><h2 id="状态机"><a href="#状态机" class="headerlink" title="状态机"></a>状态机</h2><p>HTTP是无连接的，所以作为下层的TCP协议也是无连接的，虽然看似TCP将两端连接了起来，但是其实只是两端共同维护了一个状态。</p><p>TCP的状态机是很复杂的，并且与建立断开连接时的握手息息相关，接下来就来详细描述下两种握手。<br>在这之前需要了解一个重要的性能指标RTT，该指标表示发送端发送数据到接收到对端数据所需的往返时间。</p><h2 id="建立连接的三次握手"><a href="#建立连接的三次握手" class="headerlink" title="建立连接的三次握手"></a>建立连接的三次握手</h2><p>在TCP协议中，主动发起请求的一端为客户端，被动连接的一端称为服务端。不管是客户端还是服务端，TCP连接建立完成后都能发送和接收数据，所以TCP也是一个全双工的协议。</p><p>起初，两端都为CLOSED状态。在通信开始前，双方都会创建TCB。服务器创建完TCB后变进入LISTEN状态，此时开始等待客户端发送数据。</p><h3 id="第一次握手（请求连接）"><a href="#第一次握手（请求连接）" class="headerlink" title="第一次握手（请求连接）"></a>第一次握手（请求连接）</h3><p>客户端向服务端发送连接请求报文段。该报文段中包含自身的数据通讯初始序号。请求发送后，客户端便进入SYN-SENT状态，<code>x</code>表示客户端的数据通信初始序号。</p><h3 id="第二次握手（同意连接）"><a href="#第二次握手（同意连接）" class="headerlink" title="第二次握手（同意连接）"></a>第二次握手（同意连接）</h3><p>服务端收到连接请求报文段后，如果同意连接，则会发送一个应答，该应答中也会包含自身的数据通讯出书序号，发送完成后便进入SYN-RECEIVED状态。</p><h3 id="第三次握手（确认应答）"><a href="#第三次握手（确认应答）" class="headerlink" title="第三次握手（确认应答）"></a>第三次握手（确认应答）</h3><p>当客户端收到连接同意的应答后，还要向服务端发送一个确认报文。客户端发完这个报文段后便进入ESTABLISHED状态，服务端收到这个应答后也进入ESTABLISHED状态，此时连接建立成功。</p><blockquote><p>第三次握手可以包含数据，通过TCP快速打开（TFO）技术。其实只要涉及到握手的协议，都可以使用类似TFO的方式，客户端和服务端存储相同cookie，下次握手时发出cookie达到减少RTT的目的。</p></blockquote><h3 id="明明两次握手就可以建立起链接，为什么还需要第三次应答"><a href="#明明两次握手就可以建立起链接，为什么还需要第三次应答" class="headerlink" title="明明两次握手就可以建立起链接，为什么还需要第三次应答"></a>明明两次握手就可以建立起链接，为什么还需要第三次应答</h3><p>这是为了防止失效的连接请求报文段被服务端接收，从而产生错误。</p><p>可以想象如下场景：客户端发送了一个连接请求A，但是因为网络原因造成了超时，这时TCP会启动超时重传的机制，再次发送一个连接请求B。此时请求顺利到达服务端，服务端应答完就建立了请求。如果连接请求A在两端关闭后终于抵达了服务端，那么这时服务端会认为客户端又需要建立TCP连接，从而应答了该请求并进入ESTABLISHED状态。此时客户端其实是CLOSED状态，那么就会导致服务端一直等待，造成资源的浪费。</p><blockquote><p>在建立连接中，任意一端掉线，TCP都会重发SYN包，一般会重试五次，在建立连接中可能会遇到SYN FLOOD攻击。遇到这种情况你可以选择调低重试次数或者干脆在不能处理的情况下拒绝请求。</p></blockquote><h2 id="断开连接的四次握手"><a href="#断开连接的四次握手" class="headerlink" title="断开连接的四次握手"></a>断开连接的四次握手</h2><p>TCP是全双工的，在断开连接时两端都需要发送FIN和ACK。</p><h3 id="第一次握手（请求释放）"><a href="#第一次握手（请求释放）" class="headerlink" title="第一次握手（请求释放）"></a>第一次握手（请求释放）</h3><p>若客户端A认为数据发送完成，则它需要向服务端B发送连接释放请求。</p><h3 id="第二次握手（同意释放）"><a href="#第二次握手（同意释放）" class="headerlink" title="第二次握手（同意释放）"></a>第二次握手（同意释放）</h3><p>B收到连接释放请求后，会告诉应用层要释放TCP连接。然后会发送ACK包，并进入CLOSE_WAIT状态，表示A到B的连接已经释放，不接收A发的数据了。但是因为TCP连接是双向的，所以B仍旧可以发送数据给A。</p><h3 id="第三次握手（继续发没发完的请求）"><a href="#第三次握手（继续发没发完的请求）" class="headerlink" title="第三次握手（继续发没发完的请求）"></a>第三次握手（继续发没发完的请求）</h3><p>B如果此时还有没发完的数据会继续发送，完毕后会向A发送连接释放请求，然后B遍进入LAST-ACK状态</p><blockquote><p>通过延迟确认的技术（通常有时间限制，否则对方会误认为需要重传），可以将第二次和第三次握手合并，延迟ACK包的发送。</p></blockquote><h3 id="第四次握手（确认应答）"><a href="#第四次握手（确认应答）" class="headerlink" title="第四次握手（确认应答）"></a>第四次握手（确认应答）</h3><p>A收到释放请求后，向B发送确认应答，此时A进入TIME-WAIT状态。该状态会持续2MSL（最大段生存期，指报文段在网络中生存的时间，超时会被抛弃）时间，若该时间段内没有B的重发请求的话，就进入CLOSED状态。当B收到确认应答后，也便进入CLOSED状态。</p><h3 id="为什么A要进入TIME-WAIT状态，等待2MSL时间后才进入CLOSED状态？"><a href="#为什么A要进入TIME-WAIT状态，等待2MSL时间后才进入CLOSED状态？" class="headerlink" title="为什么A要进入TIME-WAIT状态，等待2MSL时间后才进入CLOSED状态？"></a>为什么A要进入TIME-WAIT状态，等待2MSL时间后才进入CLOSED状态？</h3><p>为了保证B能收到A的确认应答。若A发完确认应答后直接进入CLOSED状态，如果确认应答因为网络问题一直没有到达，那么会造成B不能正常关闭。</p><h2 id="ARQ协议"><a href="#ARQ协议" class="headerlink" title="ARQ协议"></a>ARQ协议</h2><p>ARQ协议也就是超时重传机制。通过确认和超时机制保证了数据的正确发送。包含以下两部分</p><ul><li>停止等待ARQ</li><li>连续ARQ</li></ul><h3 id="停止等待ARQ"><a href="#停止等待ARQ" class="headerlink" title="停止等待ARQ"></a>停止等待ARQ</h3><p><strong><em> 正常传输过程 </em></strong><br>只要A向B发送一段报文，都要停止发送并启动一个定时器，等待对端回应，在定时器时间内接收到对端应答就取消定时器并发送下一段报文。</p><p><strong><em> 报文丢失或出错 </em></strong><br>在报文传输的过程中可能会出现丢包。这时候超时定时器设定的时间就会再次发送丢包的数据直到对端响应，所以需要每次都备份发送的数据。</p><p>即使报文正常的传输到对端，也可能出现在传输过程中报文出错的问题。这时候对端会抛弃该报文并等待A端重传。</p><blockquote><p>一般定时器设定的时间都会大于一个RTT的平均时间。</p></blockquote><p><strong><em> ACK超时或丢失 </em></strong><br>对端传输的应答也可能出现丢失或超时的情况。那么超过定时器时间A端照样会重传报文。这时候B端收到相同序号的报文会丢弃该报文并重传应答，直到A端发送下一个序号的报文。</p><p>在超时的情况下也可康出现应答很迟到达，这时A端会判断该序号是否已经接收过，如果接收过只需要丢弃应答即可。</p><blockquote><p>这个协议的缺点就是传输效率低，在良好的网络环境下每次发送报文都得等待对端的ACK。</p></blockquote><h3 id="连续ARQ"><a href="#连续ARQ" class="headerlink" title="连续ARQ"></a>连续ARQ</h3><p>在连续ARQ中，发送端拥有一个发送窗口，可以在没有收到应答的情况下持续发送窗口内的数据，这样相比停止等待ARQ协议来说减少了等待时间，提高了效率。</p><p><strong><em> 累计确认 </em></strong><br>连续ARQ中，接收端会持续不断收到报文。如果和停止等待ARQ中接收一个报文就发送一个应答一样，就太浪费资源了。通过累积确认，可以在收到多个报文后统一回复一个应答报文。报文中的ACK可以用来告诉发送端这个序号之前的数据已经全部接受到了，下次请发送这个序号+1的数据。</p><p>但是累计确认也有一个弊端。<br>在连续接收报文时，可能会遇到接收到序号5的报文后，并未接到序号6的报文，然而序号7以后的报文已经接收。遇到这种情况时，ACK只能回复6，这样会造成发送端重复发送数据，这种情况下可以通过Sack来解决，这个会在下文说到。</p><h2 id="滑动窗口"><a href="#滑动窗口" class="headerlink" title="滑动窗口"></a>滑动窗口</h2><p>上面讲到了发送窗口。在TCP中，两端都维护着窗口</p><ul><li>发送端窗口</li><li>接收端窗口</li></ul><p>发送端窗口包含已发送但未收到应答的数据和可以发送但是未发送的数据。<br>发送端窗口是由接收端窗口剩余大小决定的。接收方会把当前接收窗口的剩余大小写入应答报文，发送端收到应答后根据该值和当前网络拥塞情况设置发送端窗口大小，所以发送端窗口大小是不断变化的。</p><p>当发送端接收到应答报文后，会随之将窗口进行滑动</p><p>滑动窗口实现了流量控制。接收方通过报文告知发送方还可以发送多少数据，从而保证接收方能够来得及接收数据。</p><h3 id="Zero窗口"><a href="#Zero窗口" class="headerlink" title="Zero窗口"></a>Zero窗口</h3><p>在发送报文的过程中，可能会遇到对端出现零窗口的情况。在该情况下，发送端会停止发送数据，并启动persistent timer。该定时器会定时发送请求给对端，让对端告知窗口大小。在重试次数超过一定次数后，可能会中断TCP连接。</p><h2 id="拥塞处理"><a href="#拥塞处理" class="headerlink" title="拥塞处理"></a>拥塞处理</h2><p>拥塞处理和流量控制不同，后者是作用于接收方，保证接收方来得及接受数据。而前者是作用于网络，防止过多的数据拥塞网络，避免出现网络负载过大的情况。</p><p>拥塞处理包括了四个算法，分别为</p><ul><li>慢开始</li><li>拥塞避免</li><li>快速重传</li><li>快速恢复</li></ul><h3 id="慢开始算法"><a href="#慢开始算法" class="headerlink" title="慢开始算法"></a>慢开始算法</h3><p>顾名思义，就是在传输开始时将发送窗口慢慢指数级扩大，从而避免一开始就传输大量数据导致网络拥塞。<br>具体步骤如下</p><ol><li>连接初始设置拥塞窗口（Congestion Window）为1MSS（一个分段的最大数据量）</li><li>每过一个RTT就将窗口大小乘二</li><li>指数级增长肯定不能没有限制的，所以有一个阈值限制，当窗口大小大于阈值时就会启动拥塞避免算法。</li></ol><h3 id="拥塞避免算法"><a href="#拥塞避免算法" class="headerlink" title="拥塞避免算法"></a>拥塞避免算法</h3><p>此算法相对简单点，每过一个RTT窗口大小只加一，这样能够避免指数级增长导致网络拥塞，慢慢将大小调整到最佳值。</p><p>在传输过程中可能出现定时器超时的情况，这时候TCP会认为网络拥塞了，会马上进行以下步骤：</p><ol><li>将阈值设为当前拥塞窗口的一半</li><li>将拥塞窗口设为1MSS</li><li>启动拥塞避免算法</li></ol><h3 id="快速重传"><a href="#快速重传" class="headerlink" title="快速重传"></a>快速重传</h3><p>快速重传一般和快速恢复一起出现。一旦接收端收到的报文出现失序的情况，接收端只会回复最后一个顺序正确的报文序号（没有Sack的情况下）。如果收到三个重复的ACK，无需等待定时器超时再重发而是启动快速重传。具体算法分为两种：</p><p><strong><em> TCP Taho </em></strong></p><ul><li>将阈值设为当前拥塞窗口的一半</li><li>将拥塞窗口设为1MSS</li><li>重新开始慢开始算法</li></ul><p><strong><em> TCP Reno </em></strong></p><ul><li>拥塞窗口减半</li><li>将阈值设为当前拥塞窗口</li><li>进入快恢复阶段（重发对端需要的包，一旦收到一个新的ACK答复就退出该阶段）</li><li>使用拥塞避免算法</li></ul><h3 id="TCP-New-Reno-改进后的快速恢复"><a href="#TCP-New-Reno-改进后的快速恢复" class="headerlink" title="TCP New Reno 改进后的快速恢复"></a>TCP New Reno 改进后的快速恢复</h3><p>TCP New Reno 算法改进了之前 TCP Reno 算法的缺陷。在之前，快恢复中只要收到一个新的ACK包，就会退出快恢复。</p><p>在 TCP New Reno 中，TCP发送方先记下三个重复ACK的分段的最大序号。</p><p>假如我有一个分段数据是1~10这十个序号的报文，其中丢失了序号为3和7的报文，那么该分段的最大序号就是10。发送端只会收到ACK序号为3的应答。这时候重发序号为3的报文，接收方顺利接收并会发送ACK序号为7的应答。这时候TCP知道对端是有多个包未收到，会继续发送序号为7的报文，接收方顺利接收并会发送ACK序号为11的应答，这时发送端认为这个分段接收端已经顺利接收，接下来会退出快速恢复阶段。</p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;UDP&quot;&gt;&lt;a href=&quot;#UDP&quot; class=&quot;headerlink&quot; title=&quot;UDP&quot;&gt;&lt;/a&gt;UDP&lt;/h1&gt;&lt;h2 id=&quot;面向报文&quot;&gt;&lt;a href=&quot;#面向报文&quot; class=&quot;headerlink&quot; title=&quot;面向报文&quot;&gt;&lt;/a&gt;面向报文&lt;/h2&gt;&lt;p&gt;UDP是一个面向报文（报文可以理解为一段段的数据）的协议。意思就是UDP只是报文的搬运工，不会对报文进行任何拆分和拼接操作。&lt;/p&gt;
&lt;p&gt;具体来说&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;在发送端，应用层将数据传递给传输层的UDP协议，UDP只会给数据增加一个UDP头标识下是UDP协议，然后就传递给网络层了&lt;/li&gt;
&lt;li&gt;在接收端，网络层将数据传递给传输层，UDP只去除IP报文头就传递给应用层，不会任何拼接操作&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&quot;不可靠性&quot;&gt;&lt;a href=&quot;#不可靠性&quot; class=&quot;headerlink&quot; title=&quot;不可靠性&quot;&gt;&lt;/a&gt;不可靠性&lt;/h2&gt;&lt;ol&gt;
&lt;li&gt;UDP是无连接的，也就是说通信不需要建立和断开。&lt;/li&gt;
&lt;li&gt;UDP是不可靠的，协议收到什么数据就传递什么数据，并且也不会备份数据，对方能不能收到也不关心。&lt;/li&gt;
&lt;li&gt;UDP没有拥塞控制，一直会以恒定的速度发送数据。即使网络条件不好，也不会对发送速率进行调整。&lt;ul&gt;
&lt;li&gt;弊端：在网络条件不好的情况下会导致丢包&lt;/li&gt;
&lt;li&gt;优点：在某些实时性要求高的场景（比如电话会议），就需要使用UDP而不是TCP&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ol&gt;
    
    </summary>
    
      <category term="学习笔记" scheme="http://1eeing.github.io/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="学习笔记" scheme="http://1eeing.github.io/tags/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
      <category term="基础知识" scheme="http://1eeing.github.io/tags/%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"/>
    
      <category term="计算机通识" scheme="http://1eeing.github.io/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E9%80%9A%E8%AF%86/"/>
    
      <category term="网络" scheme="http://1eeing.github.io/tags/%E7%BD%91%E7%BB%9C/"/>
    
      <category term="TCP" scheme="http://1eeing.github.io/tags/TCP/"/>
    
      <category term="UDP" scheme="http://1eeing.github.io/tags/UDP/"/>
    
  </entry>
  
</feed>
